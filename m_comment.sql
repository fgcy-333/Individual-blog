/*
 Navicat Premium Data Transfer

 Source Server         : MySQL 8.0.26
 Source Server Type    : MySQL
 Source Server Version : 80026
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80026
 File Encoding         : 65001

 Date: 20/06/2022 22:14:06
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for m_comment
-- ----------------------------
DROP TABLE IF EXISTS `m_comment`;
CREATE TABLE `m_comment`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '评论的内容',
  `parent_id` bigint NULL DEFAULT -1 COMMENT '回复的评论ID',
  `blog_id` bigint NOT NULL COMMENT '评论的内容ID',
  `user_id` bigint NOT NULL COMMENT '评论的用户ID',
  `status` tinyint NULL DEFAULT 0 COMMENT '评论的状态',
  `created` datetime NULL DEFAULT NULL COMMENT '评论的时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of m_comment
-- ----------------------------
INSERT INTO `m_comment` VALUES (15, '风格差异---》测试评论', -1, 2, 1, 0, '2022-06-12 09:50:45');
INSERT INTO `m_comment` VALUES (17, '17665661294------->测试回复', 15, 2, 8, 0, '2022-06-12 16:19:31');
INSERT INTO `m_comment` VALUES (18, 'ben---->测试回复17665661294', 17, 2, 7, 0, '2022-06-14 16:27:02');

-- ----------------------------
-- Table structure for m_user
-- ----------------------------
DROP TABLE IF EXISTS `m_user`;
CREATE TABLE `m_user`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `username` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '昵称',
  `password` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '密码',
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '邮件',
  `mobile` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '手机电话',
  `sign` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '个性签名',
  `wechat` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '微信',
  `birthday` datetime NULL DEFAULT NULL COMMENT '生日',
  `avatar` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '头像',
  `status` tinyint NOT NULL DEFAULT 0 COMMENT '状态 0正常 1停用',
  `gmt_create` datetime NOT NULL COMMENT '创建日期',
  `gmt_modified` datetime NULL DEFAULT NULL COMMENT '最后修改时间',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE,
  UNIQUE INDEX `mobile`(`mobile`) USING BTREE,
  UNIQUE INDEX `email`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of m_user
-- ----------------------------
INSERT INTO `m_user` VALUES (1, 'fgcy', '$2a$10$kj6eUakfiK4NG295nU/45.eu8MNH0hIy9ZpvaUFiFD6bK1fNou3fy', '123@123com', '123', '0.0', '0', '2022-05-26 16:52:37', 'https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/susu,jpeg.webp', 0, '2022-05-26 16:52:45', '2022-05-26 16:52:48');
INSERT INTO `m_user` VALUES (7, 'ben', '$2a$10$kj6eUakfiK4NG295nU/45.eu8MNH0hIy9ZpvaUFiFD6bK1fNou3fy', '132@qq.com', '110', '1321231', '123231', '2022-06-16 15:31:19', 'https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/625b1f7be7bce73f28a97b43.jpg', 0, '2022-06-08 15:34:40', '2022-06-08 15:34:44');
INSERT INTO `m_user` VALUES (8, '17665661294', '$2a$10$iEafyaIhZ/6gPMvSrHYvB.X5iiS42RSP95VkMi2Wl..DfYqVyUzEa', NULL, NULL, NULL, NULL, NULL, 'https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/454545.jpeg', 0, '2022-06-11 10:29:08', '2022-06-11 10:29:08');

-- ----------------------------
-- Table structure for m_user_collection
-- ----------------------------
DROP TABLE IF EXISTS `m_user_collection`;
CREATE TABLE `m_user_collection`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL,
  `blog_id` bigint NOT NULL,
  `post_user_id` bigint NOT NULL,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  `status` bit(1) NULL DEFAULT b'0' COMMENT '0收藏 1取消收藏',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of m_user_collection
-- ----------------------------
INSERT INTO `m_user_collection` VALUES (1, 7, 1, 1, '2022-06-15 23:05:01', '2022-06-17 23:05:04', b'0');
INSERT INTO `m_user_collection` VALUES (2, 7, 2, 1, '2021-05-01 10:56:30', '2020-06-11 10:56:47', b'0');
INSERT INTO `m_user_collection` VALUES (5, 8, 2, 1, '2022-06-12 11:44:05', '2022-06-12 11:44:05', b'1');

-- ----------------------------
-- Table structure for m_user_message
-- ----------------------------
DROP TABLE IF EXISTS `m_user_message`;
CREATE TABLE `m_user_message`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `from_user_id` bigint NOT NULL COMMENT '发送消息的用户ID',
  `to_user_id` bigint NOT NULL COMMENT '接收消息的用户ID',
  `post_id` bigint NULL DEFAULT NULL COMMENT '消息可能关联的帖子',
  `comment_id` bigint NULL DEFAULT NULL COMMENT '消息可能关联的评论',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL,
  `type` tinyint NULL DEFAULT NULL COMMENT '消息类型',
  `created` datetime NOT NULL,
  `modified` datetime NULL DEFAULT NULL,
  `status` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of m_user_message
-- ----------------------------

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT 'NULL' COMMENT '菜单名',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `create_by` bigint NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `del_flag` int NULL DEFAULT 0 COMMENT '是否删除（0未删除 1已删除）',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '备注',
  `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '权限标识',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '菜单表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, '对后台数据的全权', '0', 1, '2022-06-02 22:28:45', 1, '2022-06-24 22:28:54', 0, NULL, 'admin');
INSERT INTO `sys_menu` VALUES (2, '评论，收藏', '0', 1, '2022-06-03 22:28:49', 1, '2022-06-26 22:28:57', 0, NULL, 'user');

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '角色权限字符串',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT '0' COMMENT '角色状态（0正常 1停用）',
  `del_flag` int NULL DEFAULT 0 COMMENT 'del_flag',
  `create_by` bigint NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT NULL,
  `update_by` bigint NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '角色表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (1, 'admin', 'admin', '0', 0, 1, '2022-06-08 22:25:08', 1, '2022-06-08 22:25:15', NULL);
INSERT INTO `sys_role` VALUES (2, 'user', 'user', '0', 0, 1, '2022-06-08 22:25:43', 1, '2022-06-08 22:25:47', NULL);

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `role_id` bigint NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `menu_id` bigint NOT NULL DEFAULT 0 COMMENT '菜单id',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (1, 1);
INSERT INTO `sys_role_menu` VALUES (1, 2);
INSERT INTO `sys_role_menu` VALUES (2, 2);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `user_id` bigint NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `role_id` bigint NOT NULL DEFAULT 0 COMMENT '角色id',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (1, 1);
INSERT INTO `sys_user_role` VALUES (7, 2);
INSERT INTO `sys_user_role` VALUES (8, 2);
INSERT INTO `sys_user_role` VALUES (9, 2);

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容',
  `first_picture` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '首图',
  `flag` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '标记(原创，转载，翻译)',
  `view` bigint NULL DEFAULT 0 COMMENT '浏览人数',
  `share_statement` bit(1) NULL DEFAULT b'0' COMMENT '可否转载',
  `appreciation` bit(1) NULL DEFAULT b'0' COMMENT '有无赞赏',
  `publiced` bit(1) NULL DEFAULT b'0' COMMENT '是否发布',
  `commentabled` bit(1) NULL DEFAULT b'0' COMMENT '可否评论',
  `recommend` bit(1) NULL DEFAULT b'0' COMMENT '是否推荐',
  `gmt_create` datetime NULL DEFAULT NULL,
  `gmt_modified` datetime NULL DEFAULT NULL,
  `user_id` int NULL DEFAULT NULL,
  `type_id` int NULL DEFAULT NULL,
  `description` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `tag_ids` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '该博客的标签ids,拼接成字符串',
  `comment_count` bigint NULL DEFAULT 0 COMMENT '评论人数',
  `collect_count` bigint NULL DEFAULT 0 COMMENT '收藏人数',
  `status` bit(1) NULL DEFAULT b'0' COMMENT '0正常',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 30 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (1, 'springboot在⼯具类注⼊bean的⽅法', '# 方法一：获取ApplicationContext上下文\r\n\r\n第⼀步: 准备一个获取ApplicationContext上下文的工具类 SpringUtils，该类实现ApplicationContextAware的实现类,⽤于获取applicationContext对象\r\n\r\n- 创建工具类 SpringUtils\r\n```java\r\npackage com.fgcy.util;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.ApplicationContextAware;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.util.Assert;\r\nimport org.springframework.util.StringUtils;\r\n@Component\r\npublic class SpringUtils implements ApplicationContextAware {\r\n    private static ApplicationContext applicationContext;\r\n    @Override\r\n    public void setApplicationContext(ApplicationContext applicationContext) {\r\n        SpringUtils.applicationContext = applicationContext;\r\n    }\r\n\r\n    private static ApplicationContext getContext() {\r\n        return applicationContext;\r\n    }\r\n\r\n    public static Object getBean(String beanId) {\r\n        return SpringUtils.getBean(Object.class, beanId);\r\n    }\r\n\r\n    public static <T> T getBean(Class<T> clazz, String beanId) throws ClassCastException {\r\n        ApplicationContext context = SpringUtils.getContext();\r\n        Assert.isTrue(StringUtils.hasText(beanId), \"beanId must not null!\");\r\n        boolean a = context.containsBean(beanId);\r\n        Assert.isTrue(context.containsBean(beanId), \"beanId :[\" + beanId + \"] is not exist!\");\r\n        Object bean = null;\r\n        bean = context.getBean(beanId);\r\n        return (T) bean;\r\n    }\r\n}\r\n```\r\n注意：\r\n  在applicationContext对象中可以获取到所有的bean\r\n\r\n- 想要在工具类中注入的bean\r\n```java\r\npackage com.fgcy.config;\r\n\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.stereotype.Component;\r\n\r\n/**\r\n * @Author fgcy\r\n * @Date 2022/5/25\r\n */\r\n@Component(\"COSConfig\")//指定bean的id，因为SpringUtils是根据bean的名字获取的\r\n@ConfigurationProperties(prefix = \"cos\")\r\npublic class COSConfig {\r\n    private String baseUrl;\r\n    private String accessKey;\r\n    private String secretKey;\r\n    private String regionName;\r\n    private String bucketName;\r\n    private String folderPrefix;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"COSConfig{\" +\r\n                \"baseUrl=\'\" + baseUrl + \'\\\'\' +\r\n                \", accessKey=\'\" + accessKey + \'\\\'\' +\r\n                \", secretKey=\'\" + secretKey + \'\\\'\' +\r\n                \", regionName=\'\" + regionName + \'\\\'\' +\r\n                \", bucketName=\'\" + bucketName + \'\\\'\' +\r\n                \", folderPrefix=\'\" + folderPrefix + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n	//getter、setter、toString\r\n}\r\n```\r\n\r\n- 获取bean的工具类\r\n```java\r\n/**\r\n * 腾讯云COS文件上传工具类\r\n */\r\npublic class COSClientUtil {\r\n    static COSConfig cosConfig;\r\n\r\n    static {\r\n        cosConfig = SpringUtils.getBean(COSConfig.class, \"COSConfig\");\r\n    }\r\n\r\n\r\n    private COSClientUtil() {\r\n    }\r\n}\r\n```\r\n\r\n# 方法二：\r\n使用@component注解将工具类交由spring管理，这样就可以使用spring容器中的bean；\r\n通过@Autowired注解注入bean\r\n\r\n', 'https://picsum.photos/seed/52kogb/800/450', '原创', 17, b'1', b'1', b'1', b'1', b'1', '2022-03-17 11:36:47', '2022-06-14 09:39:19', 1, 1, 'springboot在⼯具类注⼊bean的⽅法：1.将该bean赋值到工具类的实例成员变量 2.将该bean交给spring管理', '1,4,13,14', 1, 0, b'0');
INSERT INTO `t_blog` VALUES (2, 'markdown', '# 简介\r\n\r\n- 当前许多网站都支持用 Markdown 来撰写文档\r\n如 博客园、CSDN、简书、语雀 等，有了这么多网站的支持，你可以随时随地上传本地 MarkDown 文件到博客中\r\n\r\n- MarkDown的语法简单，记住几个常用的就可以释放鼠标了\r\n\r\n# MarkDown 基本语法\r\n\r\n## 标题\r\n语法格式：\r\n`#+空格+标题`\r\n一个#是一级标题，两个##是两级标题，以此类推，支持六级标题\r\n\r\n## 字体\r\n加粗语法格式：**加粗**\r\n\r\n斜体语法格式：*斜体*\r\n\r\n斜体加粗语法格式：``斜体加粗`\r\n\r\n删除线 语法格式：~~删除线~~\r\n\r\n高亮\r\n\r\n语法格式：==高亮==\r\n\r\n## 引用\r\n语法格式:\r\n`>+引用文字`\r\n\r\n> 我是引用文字\r\n>> 我是引用文字二级\r\n>>> 我是引用文字三级\r\n\r\n## 分割线\r\n语法格式：三个或者三个以上的 - 或者 * 都可以**\r\n\r\n---\r\n\r\n***\r\n\r\n\r\n## 图片\r\n语法格式：\r\n`![alt](图片地址 \'\'title\'\')`\r\n\r\n![](https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/wallhaven-28v8wm.jpg)\r\n\r\n\r\n## 超链接\r\n语法格式：\r\n`[超链接名](超链接地址)`\r\n\r\n\r\n\r\n## 列表\r\n- 无序列表\r\n语法格式：\r\n`无序列表用 - + * 任何一种都可以`\r\n加号和内容之间需要放置一个空格\r\n\r\n1. 有序列表\r\n语法格式：\r\n`数字+点+空格+内容`\r\n\r\n子列表\r\n在子列表前按下tab键即可构成子列表\r\n\r\n## 代码\r\n- 行内代码\r\n语法格式：用一个反引号包起来 代码内容，代码会以主题中设置的样式出现在行内，但不会实现代码高亮\r\n\r\n\r\n- 多行代码\r\n语法格式：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\r\n\r\n\r\n## 转义\r\nMarkdown中需要使用反斜杠转义特殊字符\r\n    \\   反斜线\r\n    `   反引号\r\n    *   星号\r\n    _   下划线\r\n    {}  花括号\r\n    []  方括号\r\n    ()  小括号\r\n    #   井字号\r\n    +   加号\r\n    -   减号\r\n    .   英文句点\r\n    !   感叹号\r\n\r\n# 在Typora中书写MarkDown快捷键\r\n![](https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/img/2022/6/b3065cf6451759.png)\r\n![](https://fgcy-oss-1307808810.cos.ap-guangzhou.myqcloud.com/img/2022/6/3cefc585795403.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'https://picsum.photos/seed/1dfb/800/450', '原创', 4, b'1', b'1', b'1', b'1', b'1', '2022-04-12 10:07:49', '2022-06-11 15:53:14', 1, 1, 'markdown的基本使用', '12', 2, 1, b'0');
INSERT INTO `t_blog` VALUES (6, 'redis的字符串类型', ' 应用场景：\r\n\r\n​	计数器、统计多单位的数量、粉丝数、对象缓存存储。\r\n\r\n\r\n\r\n\r\n\r\n# 赋值\r\n\r\n\r\n\r\n## 普通赋值\r\n\r\n **set** 	键	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set name zhang3\r\nOK\r\n~~~\r\n\r\n\r\n\r\n## 不存在才赋值\r\n\r\n **setnx**	键	值\r\n\r\n\r\n\r\n~~~redis\r\n127.0.0.1:6379> set name zhang3\r\nOK\r\n\r\n127.0.0.1:6379> setnx name li4\r\n(integer) 0\r\n\r\n127.0.0.1:6379> get name\r\n\"zhang3\"\r\n\r\n127.0.0.1:6379> setnx age 12\r\n(integer) 1\r\n\r\n127.0.0.1:6379> get age\r\n\"12\"\r\n~~~\r\n\r\n​	注意：不存在的 key 才能赋值 （分布式锁）\r\n\r\n\r\n\r\n## 带过期时间赋值\r\n\r\n **setex** 	键	秒	 值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> setex kk 10 name\r\nOK\r\n\r\n127.0.0.1:6379> ttl kk\r\n(integer) 6\r\n127.0.0.1:6379> ttl kk\r\n(integer) 1\r\n127.0.0.1:6379> ttl kk\r\n(integer) -2\r\n~~~\r\n\r\n\r\n\r\n## 批量赋值\r\n\r\n**mset**	键1 值1	键2 值2	键3 值3...... \r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3 k4 v4 k5 v5\r\nOK\r\n\r\n127.0.0.1:6379> keys *\r\n1) \"k5\"\r\n2) \"k4\"\r\n3) \"k2\"\r\n4) \"k1\"\r\n5) \"k3\"\r\n~~~\r\n\r\n\r\n\r\n## 批量获取\r\n\r\n **mget** 	键1	键2	键3	键4..... \r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> mget k1 k2 k3 k4 k5\r\n1) \"v1\"\r\n2) \"v2\"\r\n3) \"v3\"\r\n4) \"v4\"\r\n5) \"v5\"\r\n~~~\r\n\r\n\r\n\r\n## 原子性批量赋值\r\n\r\n **批量不存在才赋值**\r\n\r\n **msetnx**	键1 值1	键2 值2	键3 值3...... \r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> msetnx hello2 \"Hello World2\" hello3 \"Hello World3\"\r\n(integer) 0\r\n\r\n127.0.0.1:6379> get hello2\r\n\"Hello2\"\r\n\r\n127.0.0.1:6379> get hello3\r\n(nil)\r\n~~~\r\n\r\n注意：这是原子性操作 要么同时成功，要么同时失败。\r\n\r\n\r\n\r\n\r\n\r\n## 设置对象\r\n\r\n **set** 	对象\r\n\r\n\r\n\r\n 普通做法\r\n\r\n​	设置一个 **user:1** 和 **user:2** 对象，值为 Json 字符串来保存一个对象\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set user:1 {name:sail,age:27}\r\nOK\r\n\r\n127.0.0.1:6379> set user:2 {name:hello,age:28}\r\nOK\r\n\r\n127.0.0.1:6379> get user:1\r\n\"{name:sail,age:27}\"\r\n\r\n127.0.0.1:6379> get user:2\r\n\"{name:hello,age:28}\"\r\n~~~\r\n\r\n\r\n\r\n- 高阶做法\r\n\r\n~~~shell\r\n127.0.0.1:6379> mset user:1:name zhangsan user:1:age 12\r\nOK\r\n127.0.0.1:6379> mget user:1:name user:1:age\r\n1) \"zhangsan\"\r\n2) \"12\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 字符串追加\r\n\r\n **append** 	key 	value\r\n\r\n\r\n\r\n 在已有的字符串上追加\r\n\r\n~~~shell\r\n127.0.0.1:6379> set k1 zhi1\r\nOK\r\n127.0.0.1:6379> append k1 zhi2\r\n(integer) 8\r\n127.0.0.1:6379> get k1\r\n\"zhi1zhi2\"\r\n~~~\r\n\r\n\r\n\r\n 如果当前 key 不存在，就相当于 `set key`\r\n\r\n~~~shell\r\n127.0.0.1:6379> flushall\r\nOK\r\n127.0.0.1:6379> keys *\r\n(empty list or set)\r\n127.0.0.1:6379> append k2 zhangsan\r\n(integer) 8\r\n127.0.0.1:6379> keys *\r\n1) \"k2\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n# 取值\r\n\r\n## 普通取值\r\n\r\n **get** 	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> get hello\r\n\"Hello World\"\r\n~~~\r\n\r\n\r\n\r\n## 先取值再赋值\r\n\r\n **getset** 	key 	value\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> getset name li4\r\n(nil)\r\n~~~\r\n\r\n由于 name前面没有赋值，这里先取值为空\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set name li3\r\nOK\r\n127.0.0.1:6379> getset name zhang4\r\n\"li3\"\r\n127.0.0.1:6379> get name\r\n\"zhang4\"\r\n~~~\r\n\r\n\r\n\r\n\r\n## 获取长度\r\n\r\n **strlen**键\r\n\r\n \r\n\r\n~~~shell\r\n127.0.0.1:6379> strlen hello\r\n(integer) 11\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 与键相关的操作\r\n\r\n## 查看全部 key\r\n\r\n **keys  **\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> keys *\r\n1) \"hello\"\r\n~~~\r\n\r\n\r\n\r\n## 删除 key\r\n\r\n **del** 	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> keys *\r\n1) \"hello\"\r\n\r\n127.0.0.1:6379> del hello\r\n(integer) 1\r\n\r\n127.0.0.1:6379> keys *\r\n(empty array)\r\n~~~\r\n\r\n\r\n\r\n## key 是否存在\r\n\r\n **exists** 	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> exists hello\r\n(integer) 1\r\n\r\n127.0.0.1:6379> exists hello1\r\n(integer) 0\r\n~~~\r\n\r\n注意:存在返回 **1**，不存在返回 **0**。\r\n\r\n\r\n\r\n\r\n\r\n# 增减\r\n\r\n\r\n\r\n## 自增一\r\n\r\n **incr** 	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set views 0\r\nOK\r\n\r\n127.0.0.1:6379> incr views\r\n(integer) 1\r\n\r\n127.0.0.1:6379> incr views\r\n(integer) 2\r\n\r\n127.0.0.1:6379> get views\r\n\"2\"\r\n\r\n~~~\r\n\r\n\r\n\r\n## 自减1\r\n\r\n **desr** 	值\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> get views\r\n\"2\"\r\n\r\n127.0.0.1:6379> decr views\r\n(integer) 1\r\n\r\n127.0.0.1:6379> decr views\r\n(integer) 0\r\n\r\n127.0.0.1:6379> get views\r\n\"0\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 带步长自增\r\n\r\n **incrby** 	键	 step\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> get views\r\n\"0\"\r\n\r\n127.0.0.1:6379> incrby views 10\r\n(integer) 10\r\n\r\n127.0.0.1:6379> get views\r\n\"10\"\r\n~~~\r\n\r\n\r\n\r\n## 带步长自减\r\n\r\n **decrby** 	键	 step\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> get views\r\n\"10\"\r\n\r\n127.0.0.1:6379> desrby views 9\r\n(integer) 1\r\n\r\n127.0.0.1:6379> get views\r\n\"1\"\r\n~~~\r\n\r\n\r\n\r\n# 字符串截取\r\n\r\n\r\n\r\n## 截取指定下标\r\n\r\n **getrange** 	键	begin 	end\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> flushall\r\nOK\r\n\r\n127.0.0.1:6379> set k1 hello,fgcy\r\nOK\r\n\r\n127.0.0.1:6379> GETRANGE k1 0 2\r\n\"hel\"\r\n~~~\r\n\r\n 注意：这里截取的规则是**含头含尾**\r\n\r\n\r\n\r\n## 截取全部\r\n\r\n **getrange**	 键	0	 -1\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> GETRANGE k1 0 -1\r\n\"hello,fgcy\"\r\n~~~\r\n\r\n注意：这样与 `get key` 的效果一致，建议还是用 `get key`，更加简洁。\r\n\r\n\r\n\r\n## 替换字符串\r\n\r\n **setrange** 	键	begin str\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set k2 abcdefg\r\nOK\r\n\r\n127.0.0.1:6379> get k2\r\n\"abcdefg\"\r\n\r\n127.0.0.1:6379> SETRANGE k2 3 xxxxx\r\n(integer) 8\r\n\r\n127.0.0.1:6379> get k2\r\n\"abcxxxxx\"\r\n~~~\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> set k3 abcdefghijklmnopqrst\r\nOK\r\n\r\n127.0.0.1:6379> get k3\r\n\"abcdefghijklmnopqrst\"\r\n\r\n127.0.0.1:6379> SETRANGE k3 3 123\r\n(integer) 20\r\n\r\n127.0.0.1:6379> get k3\r\n\"abc123ghijklmnopqrst\"\r\n~~~\r\n\r\n​	注意：从指定位置开始替换，有多少个字符，就替换多少个字符\r\n\r\n\r\n\r\n# 过期\r\n\r\n\r\n\r\n## 设置值得同时带上过期时间\r\n **setex** 	键	过期时间	值\r\n\r\n​	单位：秒\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> setex hello 60 \"Hello World\"\r\nOK\r\n\r\n127.0.0.1:6379> ttl hello\r\n(integer) 56\r\n127.0.0.1:6379> ttl hello\r\n(integer) 55\r\n127.0.0.1:6379> ttl hello\r\n(integer) -2\r\n127.0.0.1:6379> get hello\r\n(nil)\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 查看过期剩余时间\r\n\r\n**ttl** 	键\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> ttl hello\r\n(integer) 56\r\n127.0.0.1:6379> ttl hello\r\n(integer) 55\r\n127.0.0.1:6379> ttl hello\r\n(integer) -2\r\n127.0.0.1:6379> get hello\r\n(nil)\r\n~~~\r\n\r\n注意：当结果为 **-2** 时代表已到期，其值为空\r\n\r\n', 'https://picsum.photos/seed/1/800/450', '原创', 0, b'1', b'1', b'1', b'1', b'1', '2022-05-24 15:22:17', '2022-06-12 20:37:24', 1, 1, 'redis的字符串类型', '11', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (10, 'redis的基本命令', '**版本**\r\n\r\n本文章基于 **Redis 6.2.6**\r\n\r\n\r\n\r\n**注意：**\r\n\r\n​		Redis 默认有 **16** 个数据库\r\n\r\n​		默认使用的是第 **0** 个数据库\r\n\r\n​		不同数据库存不同的值\r\n\r\n\r\n\r\n# 数据库shell相关命令\r\n\r\n\r\n\r\n## 切换数据库\r\n\r\n**select**	 数据库序号\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> select 1\r\nOK\r\n127.0.0.1:6379[1]>\r\n~~~\r\n\r\n默认是0号数据库\r\n\r\n`[]` 中的数字即为数据库编号 0 号数据库为默认，不展示编号\r\n\r\n\r\n\r\n\r\n\r\n## 查看当前数据库大小\r\n\r\n**dbszie**\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> dbszie\r\n(integer) 1xxxxxxxxxx dbszie127.0.0.1:6379[1]> dbszie(integer) 1\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 清空当前库\r\n\r\n**flushall**\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> flushdb\r\nOK\r\n~~~\r\n\r\n\r\n\r\n# 操作键相关命令\r\n\r\n\r\n\r\n## 查看当前数据库所有的键\r\n\r\n**keys**\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> keys *\r\n1) \"hello\"\r\n~~~\r\n\r\n\r\n\r\n## 判断键是否存在\r\n\r\n**exists**\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> exists age\r\n(integer) 0\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 移动键到其他数据库\r\n\r\n**move**	键	数据库序号\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> select 0\r\nOK\r\n\r\n127.0.0.1:6379> get name\r\n(nil)\r\n\r\n127.0.0.1:6379> select 0\r\nOK\r\n\r\n127.0.0.1:6379> set age 12\r\nOK\r\n\r\n127.0.0.1:6379> get age\r\n\"12\"\r\n\r\n127.0.0.1:6379> move age 1\r\n(integer) 1\r\n\r\n127.0.0.1:6379> get age\r\n(nil)\r\n\r\n127.0.0.1:6379> select 1\r\nOK\r\n\r\n127.0.0.1:6379[1]> get age\r\n\"12\"\r\n~~~\r\n\r\n\r\n\r\n## 设置键生存时间\r\n\r\n**expire**	键	时间\r\n\r\n​	单位：秒\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> get age\r\n\"12\"\r\n\r\n127.0.0.1:6379[1]> expire age 10\r\n(integer) 1\r\n\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 6\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 4\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 3\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 2\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 1\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) -2\r\n\r\n127.0.0.1:6379[1]> get age\r\n(nil)\r\n~~~\r\n\r\n\r\n\r\n## 查看键生存时间\r\n\r\n**ttl**	键\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 6\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 4\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 3\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 2\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) 1\r\n127.0.0.1:6379[1]> ttl age\r\n(integer) -2\r\n~~~\r\n\r\n​	结果为 **-2** 则代表该键已经过期。\r\n\r\n\r\n\r\n## 查看键类型\r\n\r\n**type** 	键\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379[1]> set k v\r\nOK\r\n\r\n127.0.0.1:6379[1]> type k\r\nstring\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 查看端口占用命令\r\n\r\nnetstat -ano | findstr 名字\r\n\r\n\r\n\r\n~~~shell\r\nnetstat -ano | findstr 6379\r\n~~~\r\n\r\n\r\n\r\n', 'https://picsum.photos/seed/2/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-05-27 19:01:57', '2022-06-13 10:19:08', 1, 1, 'redis的基本命令', '11', 1, 0, b'0');
INSERT INTO `t_blog` VALUES (11, 'redis的列表List', '\r\n\r\n 在 Redis 里面，可以把 List 当成**栈**、**队列**、**阻塞队列**使用。\r\n\r\n list 实际是一个链表，左右都可以插入值。\r\n\r\n 如果 key 不存在，创建新的链表。\r\n\r\n 如果移除了所有元素，空链表也代表不存在。\r\n\r\n 在两边插入或者改动值，效率最高；操作中间元素，效率相对低一些。\r\n\r\n 应用场景：消息排队\r\n\r\n\r\n\r\n**redis不区分大小写命令**\r\n\r\n\r\n\r\n# 赋值\r\n\r\n\r\n\r\n## 从左插入\r\n\r\n **Lpush** 	**列表名	 值**\r\n\r\n\r\n\r\n将一个值或者多个值，插入列表的头部，即从左插入\r\n\r\n~~~bash\r\n127.0.0.1:6379> flushall\r\nOK\r\n127.0.0.1:6379> LPUSH list one\r\n(integer) 1\r\n127.0.0.1:6379> LPUSH list two\r\n(integer) 2\r\n127.0.0.1:6379> LPUSH list three\r\n(integer) 3\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n127.0.0.1:6379> LRANGE list 0 1\r\n1) \"three\"\r\n2) \"two\"\r\n~~~\r\n\r\n先进的排在后面，后进的排在前面\r\n\r\n\r\n\r\n## 从右插入\r\n\r\n **Rpush** 	列表名 	值\r\n\r\n\r\n\r\n将一个值或者多个值，插入列表的尾部，即从右插入\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n\r\n127.0.0.1:6379> RPUSH list final\r\n(integer) 4\r\n\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n4) \"final\"\r\n~~~\r\n\r\n\r\n\r\n## 指定下标更新值\r\n\r\n **Lset** 	列表名 	下标 	值\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> flushall\r\nOK\r\n\r\n127.0.0.1:6379> LPUSH ls 1 2 32 2\r\n(integer) 4\r\n\r\n127.0.0.1:6379> lset ls 0 one\r\nOK\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"one\"\r\n2) \"32\"\r\n3) \"2\"\r\n4) \"1\"\r\n~~~\r\n\r\n\r\n\r\n 想要修改的下标不存在\r\n\r\n~~~shell\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"one\"\r\n2) \"32\"\r\n3) \"2\"\r\n4) \"1\"\r\n\r\n127.0.0.1:6379> lset ls 100 100\r\n(error) ERR index out of range\r\n~~~\r\n\r\n\r\n\r\n 想要修改的列表不存在\r\n\r\n~~~shell\r\n127.0.0.1:6379> FLUSHALL\r\nOK\r\n127.0.0.1:6379> LSET key index value\r\n(error) ERR unknown command \'lse\'\r\n127.0.0.1:6379> lset ls 0 8\r\n(error) ERR no such key\r\n~~~\r\n\r\n\r\n\r\n注意：如果列表不存在或者列表指定下标不存在，赋值失败\r\n\r\n\r\n\r\n## 元素前后插入值\r\n\r\n **Linsert**	 列表名 	前\\后 	list中的值 	想要插入的值\r\n\r\n​	即：把想要插入的值放到 list中某个值的前或后\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> FLUSHALL\r\nOK\r\n\r\n127.0.0.1:6379> lpush ls 1 2\r\n(integer) 2\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"2\"\r\n2) \"1\"\r\n\r\n127.0.0.1:6379> linsert ls before 2 and #左边是头部，所以2的前面是2的左边\r\n(integer) 3\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"and\"\r\n2) \"2\"\r\n3) \"1\"\r\n\r\n127.0.0.1:6379> LINSERT ls before and first\r\n(integer) 4\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"first\"\r\n2) \"and\"\r\n3) \"2\"\r\n4) \"1\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 移除\r\n\r\n## 从左移除\r\n\r\n **Lpop** 	列表\r\n\r\n​	移除最左边的元素\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n\r\n127.0.0.1:6379> lpop list\r\n\"three\"\r\n\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"two\"\r\n2) \"one\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 从右移除\r\n\r\n **Rpop**	 列表名\r\n\r\n移除最右边的元素\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n4) \"final\"\r\n\r\n127.0.0.1:6379> RPOP list\r\n\"final\"\r\n\r\n127.0.0.1:6379> LRANGE list 0 -1\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n~~~\r\n\r\n\r\n\r\n## 根据值移除元素\r\n **lrem** 	列表名 	个数 	值\r\n\r\n\r\n\r\n 移除一个\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n4) \"b\"\r\n5) \"a\"\r\n\r\n127.0.0.1:6379> lrem ls1 1 a\r\n(integer) 1\r\n\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n4) \"b\"\r\n~~~\r\n\r\n\r\n\r\n 移除多个\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"a\"\r\n2) \"a\"\r\n3) \"a\"\r\n4) \"a\"\r\n5) \"a\"\r\n6) \"e\"\r\n7) \"d\"\r\n8) \"c\"\r\n9) \"b\"\r\n\r\n127.0.0.1:6379> lrem ls1 5 a\r\n(integer) 5\r\n\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n4) \"b\"\r\n~~~\r\n\r\n\r\n\r\n 想移除多个，实际只移除一个\r\n\r\n~~~shell\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n4) \"b\"\r\n\r\n127.0.0.1:6379> lrem ls1 5 b\r\n(integer) 1\r\n\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n~~~\r\n\r\n\r\n\r\n## 移除列表最后一个元素并移动到新列表中\r\n\r\n **RpopLpush	** 列表名 	新列表名\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n4) \"3\"\r\n5) \"4\"\r\n\r\n127.0.0.1:6379> RPOPLPUSH ls newls\r\n\"4\"\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n4) \"3\"\r\n\r\n127.0.0.1:6379> LRANGE newls 0 -1\r\n1) \"4\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n# 取值\r\n\r\n\r\n\r\n## 根据下标查看列表\r\n **Lrange** 	列表名 	begin 	end\r\n\r\n\r\n\r\n~~~shell\r\n127.0.0.1:6379> Lrange list 0 -1 # -1 即表示查询所有元素\r\n1) \"three\"\r\n2) \"two\"\r\n3) \"one\"\r\n\r\n127.0.0.1:6379> Lrange list 0 1 # 查询指定下标范围元素\r\n1) \"three\"\r\n2) \"two\"\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 通过下标获取元素\r\n\r\n **Lindex** 	列表名	 index\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379>  LRANGE list 0 -1\r\n1) \"two\"\r\n2) \"one\"\r\n\r\n127.0.0.1:6379> LINDEX list 0\r\n\"two\"\r\n\r\n127.0.0.1:6379> LINDEX list 1\r\n\"one\"\r\n\r\n127.0.0.1:6379> LINDEX list 2\r\n(nil)\r\n~~~\r\n\r\n注意：Redis 显示的下标是从 1 开始的，实际的下标还是从 0 开始的\r\n\r\n\r\n\r\n\r\n\r\n## 列表长度\r\n\r\n **Llen** 	列表名\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE ls1 0 -1\r\n1) \"e\"\r\n2) \"d\"\r\n3) \"c\"\r\n4) \"b\"\r\n5) \"a\"\r\n\r\n127.0.0.1:6379> LLEN ls1\r\n(integer) 5\r\n~~~\r\n\r\n\r\n\r\n## 列表是否存在\r\n\r\n **exists**	 列表名\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> exists list\r\n(integer) 1\r\n\r\n127.0.0.1:6379> exists list3\r\n(integer) 0\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n# 截取\r\n\r\n\r\n\r\n## 截取下标范围的元素\r\n\r\n **Ltrim** 	列表名 	begin 	end\r\n\r\n\r\n\r\n~~~bash\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"1\"\r\n2) \"2\"\r\n3) \"3\"\r\n4) \"4\"\r\n\r\n127.0.0.1:6379> LTRIM ls 1 2\r\nOK\r\n\r\n127.0.0.1:6379> LRANGE ls 0 -1\r\n1) \"2\"\r\n2) \"3\"\r\n~~~\r\n\r\n注意：该list已被改变 只剩下被截取的元素\r\n\r\n\r\n\r\n# 小结\r\n\r\n\r\n\r\n Redis中的List，实际上是一个链表 , left , right 都可以插入值\r\n\r\n 如果key不存在,创建新的链表\r\n\r\n 如果key存在,新增内容.\r\n\r\n 如果移除了所有值,空链表,也代表不存在!.\r\n\r\n 在两边插入或者改动值,效率最高!中间元素,相对来说效率会低一点\r\n\r\n 消息排队!消息队列(Lpush Rpop) \r\n\r\n 栈( Lpush Lpop) \r\n\r\n', 'https://picsum.photos/seed/752/800/450', '原创', 2, b'1', b'1', b'1', b'1', b'1', '2022-05-27 21:04:16', '2022-05-27 21:04:16', 1, 1, 'redis的列表List', '11', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (13, 'java类型转换、常见运算符', '## 一、类型转换\r\n\r\n### 1.0 自动类型转换\r\n\r\n类型范围小的变量，可以直接赋值给类型范围大的变量\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-02-27_14-55-27.png)\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-02-27_15-01-43.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n### 2.0 自动类型转换运算\r\n\r\n1. 在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算。\r\n2. 表达式的最终结果类型由表达式中的最高类型决定。\r\n3. 在表达式中，byte、short、char 是直接转换成int类型参与运算的\r\n4. **字面量**是整数且没有后缀L、l的当成是int来运算\r\n5. **字面量**是小数且没有F、f作为后缀的当成是double运算\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-02-27_15-04-38.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n        byte a = 100;\r\n        byte b = 90;\r\n 		//byte short char 其中一个或多个在进行运算时自动转成int，再运算\r\n        int i = a + b; \r\n        System.out.println(i);\r\n~~~\r\n\r\n### 3.0 强制类型转换\r\n\r\n可以 强行将类型范围大的变量、数据赋值给类型范围小的变量\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-02-27_15-41-14.png)\r\n\r\n---\r\n\r\n强制类型转换可能造成数据(丢失)溢出；\r\n浮点型强转成整型，直接丢掉小数部分，保留整数部分返回\r\n\r\njava中数值类型都有正负，计算机用补码存储负数；在输出时将存储的补码转为源码 既是-36\r\n\r\n## 二、toString、valueOf、(String)的区别\r\n\r\n- 代码体现\r\n\r\n~~~java\r\npackage api_object;\r\n\r\nimport java.util.Calendar;\r\n\r\n/**\r\n * date: 2022/3/21 16:40\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\npublic class StringDemo1 {\r\n    public static void main(String[] args) {\r\n        int a1 = 10;\r\n        Integer a2 = 10;\r\n        byte b1 = 12;\r\n        Byte b2 = 12;\r\n        short ss1 = 2;\r\n        Short ss2 = 2;\r\n        Long l1 = 888L;\r\n        long l2 = 888L;\r\n        char c1 = \'a\';\r\n        Character c2 = \'a\';\r\n        Float f1 = 1.29f;\r\n        float f2 = 1.29f;\r\n        double d1 = 9.9;\r\n        Double d2 = 9.8;\r\n\r\n        //编译报错，基本数据类型及其包装类不能强转为String类\r\n        //同样的的String类也不能强转为基本数据类型及其包装类\r\n//        String s1 = (String) a1;\r\n//        String s1 = (String) a2;\r\n//        String s1 = (String) b1;\r\n//        String s1 = (String) b2;\r\n//        String s1 = (String) ss1;\r\n//        String s1 = (String) ss2;\r\n//        String s1 = (String) l1;\r\n//        String s1 = (String) l2;\r\n//        String s1 = (String) c1;\r\n//        String s1 = (String) c2;\r\n//        String s1 = (String) f1;\r\n//        String s1 = (String)f2;\r\n//        String s1 = (String) d1;\r\n//        String s1 = (String) d2;\r\n\r\n        //基本数据类型没有toString方法\r\n//      a1.toString();\r\n        System.out.println(a2.toString());//10\r\n\r\n        //null.toString()会报错\r\n        a2 = null;\r\n        //println()底层使用了String.valueOf()方法，源码如下：\r\n        	//return (obj == null) ? \"null\" : obj.toString();\r\n        System.out.println(a2);//null\r\n//      System.out.println(a2.toString());\r\n\r\n        //基本数据类型及其包装类转String类型推荐做法是String.valueOf()\r\n        //如果是null会返回字符串null\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(a1));//10\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(a2));//null\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(b1));//12\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(b2));//12\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(c2));//a\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(c1));//a\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(ss1));//2\r\n        System.out.println(\"通过String.valueOf(x)，使得基本数据类型及其包装类变为String：\" + String.valueOf(ss2));//2\r\n\r\n        //通过拼接字符串的方法，将基本数据类型及其包装类变为String\r\n        //基本数据类型转String除了拼接空字符就是String.valueOf(x)\r\n        System.out.println(\"通过拼接空字符串将基本数据类型及其包装类变为String：\" + b1 + \"\");//12\r\n        System.out.println(\"通过拼接空字符串将基本数据类型及其包装类变为String：\" + b2 + \"\");//12\r\n        System.out.println(\"通过拼接空字符串将基本数据类型及其包装类变为String：\" + ss2 + \"\");//2\r\n        System.out.println(\"通过拼接空字符串将基本数据类型及其包装类变为String：\" + ss1 + \"\");//2\r\n\r\n\r\n        //包装类型与String 无论谁强转转谁 都报错，编译就出错\r\n//        Integer integer = (Integer) \"aaa\";\r\n\r\n\r\n        //用Object类型的变量(接基本数据类型的字面值)，强制转换为String(向下转型)，编译不报错\r\n        Object o = 12;\r\n        //用Object类型的变量接包装类(向上转型)，强制转换为String(向下转型)，编译不报错\r\n        Object object = a2;\r\n        //运行的时候就报错，类型转换异常\r\n        //java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\r\n//      String rs = (String) o;\r\n        Object obj = \"a\";\r\n        Integer r = obj instanceof Integer ? (Integer) obj : -1;\r\n        System.out.println(\"String类与包装类强制类型转换：\" + r);//-1\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n10\r\nnull\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：10\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：null\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：12\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：12\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：a\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：a\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：2\r\n通过String.valueOf(x)，使得基本数据类型及其包装类变为String：2\r\n通过拼接空字符串将基本数据类型及其包装类变为String：12\r\n通过拼接空字符串将基本数据类型及其包装类变为String：12\r\n通过拼接空字符串将基本数据类型及其包装类变为String：2\r\n通过拼接空字符串将基本数据类型及其包装类变为String：2\r\nString类与包装类强制类型转换：-1\r\n~~~\r\n\r\n\r\n\r\n- 总结\r\n\r\n1、toString()，可能会抛空指针异常\r\n\r\n​    在这种使用方法中，因为java.lang.Object类里已有public方法toString()，所以java对象都可以调用此方法。\r\n\r\n​	但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。\r\n\r\n​	采用这种方法时，通常派生类会覆盖Object里的toString()方法。\r\n\r\n\r\n\r\n2、String.valueOf()，推荐使用\r\n\r\n​	  因为当对象为null时，返回字符串“null”\r\n​	  String.valueOf()方法是推荐使用的，因为它不会出现空指针异常，而且是静态的方法，直接通过String调用即可\r\n\r\n​	 只是有一点需要注意，就是上面提到的，如果为对象为null，String.valueOf()返回结果是字符串“null”。而不是null\r\n\r\n\r\n\r\n3、(String)强转，不推荐使用\r\n\r\n​	（String）是标准的类型转换，将Object类型转为String类型，使用(String)强转时，最好使用instanceof做一个类型检查，以判断是否可以进行强转，\r\n\r\n​		否则容易抛出ClassCastException异常。需要注意的是编写的时候，编译器并不会提示有语法错误，所以这个方法要谨慎的使用\r\n\r\n\r\n\r\n4.基本数据类型及其包装类与String 无论谁【强转】转谁 都报错，编译就出错\r\n5.基本数据类型没有toString方法，对象独有\r\n6.println()底层使用了String.valueOf()方法，源码如下：return (obj == null) ? \"null\" : obj.toString();\r\n\r\n## 三、常见运算符\r\n\r\n### 1.0 算数运算符\r\n\r\n~~~\r\n*  /  %\r\n+  -\r\n~~~\r\n\r\n如果两个整数做除法，其结果一定是整数，因为最高类型是整数。10/3=3  10*1.0/3=3.333335\r\n\r\n\r\n\r\n- 数值拆分\r\n\r\n~~~java\r\n    @Test\r\n    public void testBasic() {\r\n        int score = 123;\r\n        //取模运算符可以得到最尾端的数字\r\n        System.out.println(\"个位：\" + score % 10 + \" 十位:\" + score / 10 % 10 + \" 百位\" + score / 100);\r\n    }\r\n~~~\r\n\r\n### 2.0 **+** 做连接符\r\n\r\n~~~java\r\n能算则算，不能算就在一起。（计算机很聪明）\r\nint a = 5 ;\r\nSystem.out.println(“abc” + ‘a’); // abca   \r\nSystem.out.println(\"abc\" + a);  // abc5\r\nSystem.out.println(5 + a);   // 10\r\nSystem.out.println(\"abc\" + 5 + ‘a’);//abc5a\r\nSystem.out.println(15 + \"abc\" + 15);//15abc15\r\nSystem.out.println(a + \'a’);//102\r\nSystem.out.println(a + \"\" +\'a’);//5a\r\nSystem.out.println(a + \'a\'+\" itheima \");//102itheima\r\nSystem.out.println(\"itheima\"+ a + \'a’);//itheima5a\r\nSystem.out.println(\"itheima\"+ ( a + \'a\' ));//itheima102\r\n~~~\r\n\r\n### 3.0 自增自减运算符\r\n\r\n- 概念\r\n\r\n1. ++ 、-- 只能操作变量，不能操作字面量的\r\n2. 放在变量的前面，先对变量进行+1、-1，再拿变量的值进行运算。 \r\n3. 放在变量的后面，先拿变量的值进行运算，再对变量的值进行+1、-1 \r\n\r\n\r\n\r\n- 代码体现\r\n\r\n~~~java\r\n @Test\r\n    public void testBasic1() {\r\n        int c = 10;\r\n        int d = 5;\r\n        int rs3 = c++ + ++c - --d - ++d + 1 + c--;\r\n        System.out.println(rs3);\r\n    }\r\n~~~\r\n\r\n~~~\r\n26\r\n~~~\r\n\r\n\r\n\r\n### 4.0 赋值运算符\r\n\r\n- 基本赋值运算符\r\n\r\n~~~\r\n=\r\n~~~\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-02-28_21-50-48.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n	@Test\r\n    public void testBasic2() {\r\n        int c = 10;\r\n        int d = 5;\r\n        c = c + d;\r\n        c += d;//等价于 c = (int)(c + d)\r\n\r\n        byte a = 30;\r\n        byte b = 120;\r\n        a += b;//等价于  a = (byte)(a + b)\r\n        System.out.println(a);//精度丢失\r\n    }\r\n~~~\r\n\r\n~~~\r\n15\r\n-106\r\n~~~\r\n\r\n\r\n\r\n### 5.0 关系运算符\r\n\r\n- 概念\r\n\r\n​	是对数据进行条件判断的符号，最终会返回一个比较的布尔结果（false,true）\r\n\r\n- 形式\r\n\r\n~~~\r\n== < <= >= !=\r\n~~~\r\n\r\n### 6.0**逻辑运算符**\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-01_08-03-58.png)\r\n\r\n---\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-01_08-05-26.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 代码体现\r\n\r\n~~~java\r\n    @Test\r\n    public void testBasic3() {\r\n        int c = 10;\r\n        int d = 5;\r\n        System.out.println(\"短路与：\" + (c >= 99 && d++ < 100) + \" d=\" + d);\r\n        System.out.println(\"逻辑与：\" + (c >= 99 & d++ < 100) + \" d=\" + d);\r\n        System.out.println(\"----------------------------------------\");\r\n        System.out.println(\"短路或：\" + (c <= 99 || d++ < 100) + \" d=\" + d);\r\n        System.out.println(\"逻辑或：\" + (c >= 99 | d++ < 100) + \" d=\" + d);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~\r\n短路与：false d=5\r\n逻辑与：false d=6\r\n----------------------------------------\r\n短路或：true d=6\r\n逻辑或：true d=7\r\n~~~\r\n\r\n\r\n\r\n- 小结\r\n\r\n逻辑与：同真为真\r\n逻辑异或：不同为真\r\n逻辑或：同假为假\r\n短路性能更好\r\n\r\n### 7.0三元运算符（嵌套）\r\n\r\n~~~java\r\n	@Test\r\n    public void testBasic4() {\r\n        int c = 120;\r\n        int d = 5;\r\n        int b = 78;\r\n        System.out.println(c > d ? (c > b ? c : b ):( d > b ? d : b));\r\n    }\r\n~~~\r\n\r\n~~~\r\n120\r\n~~~\r\n\r\n\r\n\r\n### 8.0运算符优先级\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-02_15-01-07.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~\r\n()\r\n! - ++ --\r\n* / %\r\n+ -\r\n<< >> >>>\r\n< <= > >= instanceof\r\n== !=\r\n& \r\n^\r\n|\r\n&&\r\n||\r\n?:\r\n= += =+ *= /= %= &=\r\n~~~\r\n\r\n~~~\r\n算数运算符 > 位移运算符 > 关系运算符 > 逻辑运算符 > 三元运算符 > 赋值运算符\r\n~~~\r\n\r\n\r\n\r\n', 'https://picsum.photos/seed/aaa/800/450', '原创', 5, b'1', b'1', b'1', b'1', b'1', '2022-06-13 11:23:50', '2022-06-13 14:17:07', 1, 1, 'java类型转换、常见运算符、toString、valueOf、(String)的区别', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (14, '程序流程', '# 一、程序流程\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-02_15-40-32.png)\r\n\r\n---\r\n\r\n\r\n\r\n### 1.0 顺序结构[默认流程]\r\n\r\n~~~java\r\npublic class Test {\r\npublic static void main(String[] args) {\r\n    System.out.println(\"A\");\r\n    System.out.println(\"B\");\r\n    System.out.println(\"C\");\r\n    }\r\n}\r\n//如果你没有写其他的结构，按照代码的先后顺序，依次执行程序中大多数的代码都是这样执行的。\r\n~~~\r\n\r\n### 2.0 分支结构\r\n\r\n- 两种：if、switch\r\n  - if其实在功能上远远强大于switch，效率较于switch要低\r\n  - if适合做区间匹配。\r\n  - switch适合做值匹配，代码优雅,效率高\r\n\r\n### 3.0 循环结构\r\n\r\n- 三种：for、while、do while\r\n\r\n# 二、分支\r\n\r\n### 1.0 switch\r\n\r\n- 概述\r\n\r\n值匹配，性能好，功能没有if强大（if可以范围匹配）\r\n\r\n\r\n\r\n- 代码体现\r\n\r\n~~~JAVA\r\n		public static void main(String[] args) {\r\n        //switch天然与枚举结合进行信息分类，对入参类型进行校验，但只适合信息标志\r\n        //如果需要记录一些信息的就使用常量\r\n        choose(CaseType.FIFTH);\r\n    }\r\n    private static void choose(CaseType caseType) {\r\n        //这里可以是byte short int char String 枚举 不支持小数和long（小数不精确不利于比对，long太大了，没有可能有这么多的标志位）\r\n        switch (caseType) {\r\n            //这里只能是字面量或枚举或常量，不能重复\r\n            case FIFTH:\r\n                System.out.println(\"1\");\r\n                //不加beak会发生switch穿透，有时候会有用到switch穿透\r\n                break;\r\n            case SECOND:\r\n                System.out.println(\"2\");\r\n                break;\r\n                break;\r\n                System.out.println(\"4\");\r\n                break;\r\n            case FIRST:\r\n                System.out.println(\"5\");\r\n                break;\r\n        }\r\n    }\r\n~~~\r\n\r\n- switch配合枚举类使用\r\n\r\n  - 定义枚举类\r\n\r\n  ~~~java\r\n  public enum Season{\r\n  	SPRING,SUMMER,AUTUMN,WINTER;\r\n  }\r\n  ~~~\r\n\r\n  - 枚举类反编译\r\n\r\n  ~~~java\r\n  Compiled from \"Season. java\"\r\n      public final class Season extends java.lang. Enum<Season> {\r\n          public static final Season SPRING=new Season ();\r\n          public static final Season SUMMER = new Season ();\r\n          public static final Season AUTUMN = new Season ();\r\n          public static final Season WINTER = new Season ();\r\n          public static Season [] values ();\r\n          public static Season valueOf (java.lang.String); \r\n      }\r\n  ~~~\r\n\r\n  - 枚举类java代码形式\r\n\r\n  ~~~java\r\n  public final class Season extends Enum{\r\n        public static final Season SPRING;\r\n        public static final Season SUMMER;\r\n        public static final Season AUTUMN;\r\n        public static final Season WINTER;\r\n      \r\n      public Season(String name,int orgin){\r\n          super(name,orgin);\r\n      }\r\n      static{\r\n          SPRING=new Season(\"SPRING\",0);\r\n          SUMMER=new Season(\"SUMMER\",1);\r\n          AUTUMN=new Season(\"AUTUMN\",2);  \r\n          WINTER=new Season(\"WINTER\",3);\r\n      }\r\n      .........\r\n  }\r\n  ~~~\r\n\r\n  - 枚举特性\r\n\r\n  \r\n\r\n  1. 继承了java.lang下的Enum类的类就是枚举类\r\n  2. 枚举类是最终类不可以继承\r\n  3. 枚举类的构造器都是私有的，即是不能对外创建对象；\r\n  4. 枚举类相当于多例模式,可以通过枚举实现单例\r\n  5. 枚举类第一行默认是罗列所有对象名称,修饰符是public static final\r\n  6. 每一个名称都代表一个该枚举类的实例，且类型为常量\r\n  7. 选择枚举类型作为信息的标志与分类比选择常量更为严谨\r\n\r\n  \r\n\r\n### 2.0 if\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-03_15-15-57.png)\r\n\r\n---\r\n\r\n\r\n\r\n# 三、循环\r\n\r\n## 1.0 for\r\n\r\n- 格式\r\n\r\n~~~\r\nfor(初始语句;循环条件;迭代语句){\r\n	//循环逻辑\r\n}\r\n~~~\r\n\r\n- 注意\r\n\r\n\r\n\r\n1. 初始化语句、循环条件、迭代语句如果有多个，用逗号隔开 但分号不能省略\r\n2. 用break打破循环和switch\r\n3. 用continue结束本次循环\r\n\r\n\r\n\r\n- 代码实现\r\n\r\n~~~java\r\n    @Test\r\n    public void testFor() {\r\n        int sum = 0;\r\n        for (int i = 2; i <= 102; i += 2) {\r\n            sum += i;\r\n        }\r\n        System.out.println(\"2-102求和：\" + sum);\r\n    }\r\n~~~\r\n\r\n- 水仙花数\r\n\r\n~~~java\r\n	/*\r\n     * 水仙花（每一位上的数的三次方相加等于原来的数）\r\n     * */\r\n    @Test\r\n    public static void testFor_() {\r\n        final Scanner sc = new Scanner(System.in);\r\n        System.out.println(\"请输入数字\");\r\n        final String s = sc.nextLine();\r\n        final String[] strings = s.split(\",\");\r\n        for (String s1 : strings) {\r\n            //当字符串为不符合数字特征的字符时，数字转换异常\r\n            //java.lang.NumberFormatException（数字转换异常）\r\n            //静态方法valueOf底层调用的是，静态方法parseInt，使用valueOf的目的是方便记忆\r\n            yes(Integer.valueOf(s1));\r\n			// Integer.parseInt(s);//将字符串转为整数 java.lang.NumberFormatException（数字转换异常）\r\n        }\r\n    }\r\n\r\n    private static void yes(Integer valueOf) {\r\n        if (valueOf / 100 != 0) {\r\n            //通过取模得到的是末尾数值，通过除法控制末位\r\n            final int bai = valueOf / 100;//百位\r\n            final int ge = valueOf % 10;//个位\r\n            final int shi = valueOf / 10 % 10;//十位\r\n            if (bai * bai * bai + ge * ge * ge + shi * shi * shi == valueOf) {\r\n                System.out.println(valueOf + \"是水仙花\");\r\n            } else {\r\n                System.out.println(valueOf + \"不是水仙花\");\r\n            }\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n请输入数字\r\n153,370,371,111\r\n153是水仙花\r\n370是水仙花\r\n371是水仙花\r\n111不是水仙花\r\n~~~\r\n\r\n\r\n\r\n## 2.0 while\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-03_15-49-05.png)\r\n\r\n---\r\n\r\n\r\n\r\n2、什么时候用for循环，什么时候用while循环？\r\n    功能上是完全一样的，for能解决的while也能解决，反之亦然。\r\n    使用规范是：知道循环几次：使用for；不知道循环几次建议使用：while\r\n\r\n\r\n\r\n- 代码实现(折叠纸张达到珠穆朗玛峰高度 )\r\n\r\n~~~java\r\n @Test\r\n    public void test_() {\r\n        final double mountain = 8848860;\r\n        double paper = 0.1;\r\n\r\n        //当不知道次数是用while，确定次数时用for\r\n    /*    while (paper < mountain) {\r\n            paper *= 2;\r\n        }*/\r\n\r\n        //不专业\r\n        for (; paper < mountain; ) {\r\n            paper *= 2;\r\n        }\r\n        System.out.println(paper);\r\n    }\r\n~~~\r\n\r\n## 3.0 do...while \r\n\r\n~~~JAVA\r\n初始化语句；\r\n    do{\r\n        循环语句；\r\n        迭代语句；\r\n    }while（循环条件）；\r\n~~~\r\n\r\n~~~\r\n（第一次先执行后判断）\r\n~~~\r\n\r\n\r\n\r\n## 4.0 死循环\r\n\r\n~~~java\r\n    @Test\r\n    public void test() {\r\n  /*      for (; ; ) {\r\n            System.out.println(\"1\");\r\n        }*/\r\n\r\n    /*    while (true) {\r\n            System.out.println(\"1\");\r\n        }*/\r\n\r\n        do {\r\n            System.out.println(\"2\");\r\n        } while (true);\r\n    }\r\n~~~\r\n\r\n## 5.0 跳转语句\r\n\r\nbreak : \r\n		只能用于结束所在循环,\r\n		或者结束所在switch分支的执行。\r\n		不能用break打破if；\r\n		break OUT;用于打破外层循环；将OUT放在外层循环语句的上一行\r\n\r\ncontinue : \r\n		只能在循环中进行使用。\r\n\r\n\r\n\r\n# 六、随机数Random类\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final Random random = new Random();\r\n        for (int i = 0; i < 100; i++) {\r\n            //加减法\r\n            //比如42-55 \r\n            //直接 r.nextInt(x)+42  , 然后55-42=13 ， 包前不包后 x=14\r\n            //r.nextInt(14)+42\r\n            final int r = random.nextInt(10) + 1;//1-----9+1\r\n            System.out.println(r);\r\n        }\r\n    }\r\n~~~\r\n\r\n', 'https://picsum.photos/seed/45jjk/800/450', '原创', 3, b'1', b'1', b'1', b'1', b'1', '2022-06-13 13:04:45', '2022-06-13 14:23:09', 1, 1, '程序流程', '1,15', 1, 0, b'0');
INSERT INTO `t_blog` VALUES (15, 'java数组', '## 一、定义数组存储数据\r\n\r\n- 数组的概念\r\n\r\n用来存储一批同种类型数据（可以理解成容器）                                   \r\n\r\n### 1.0 静态初始化数组\r\n\r\n~~~java\r\n    //数据类型[] 变量名 = new 数据类型[]{数据.......}\r\n    int[] arr =new int[]{1,2,3,4}\r\n    //简化\r\n    //数据类型[] 变量名 ={数据.......}\r\n    int[] arr ={1,2,3,4,5}\r\n	//c语言\r\n	//数据类型 变量名[] =new 数据类型[]{数据.......}\r\n	//类型 变量名[] = 数据.......}\r\n    int a[] = new int[]{12, 3, 4, 5};\r\n    int b[] = {12, 3, 4, 5};\r\n\r\n    @Test\r\n    public void testArray1() {\r\n        final int[] arrays = {1, 2, 3, 4, 5};\r\n        final double[] arrays2 = {1.0, 2.0, 3, 4, 5};\r\n        final float[] arrays3 = {1.0f, 2.0f, 3f, 4f, 5f};\r\n        System.out.println(arrays);\r\n        System.out.println(arrays2);\r\n        System.out.println(arrays3);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[I@ba8a1dc\r\n[D@4f8e5cde\r\n[F@504bae78\r\n\r\n  \'[\'---->数组\r\n  \'@\'之后的是十六进制地址\r\n  数组是引用数据类型，引用(数组地址)放在栈中，数组对象放在堆中\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 2.0 动态初始化数组\r\n\r\n1. 先确定元素的类型和数组的长度，之后再存入具体数据（会默认初始化数组中的数据)\r\n\r\n2. 默认类型初始值：\r\n\r\n   ~~~\r\n       byte short int long 0\r\n       char \'/u0000\'转为int是0\r\n       boolean false\r\n       double float 0.0\r\n       String Object null\r\n   ~~~\r\n\r\n   \r\n\r\n3. 格式：\r\n   数据类型[] 变量名 =new 数据类型[数组长度];\r\n   4.使用场景：\r\n    当前已经知道存入的元素值，用静态初始化。\r\n    当前还不清楚要存入哪些数据，用动态初始化\r\n\r\n4. 注意：\r\n   两种类型的写法是独立的，不能两边都用\r\n\r\n   ~~~\r\n   int[] arrs new int[3]{1,2,3}----------->是错误的写法\r\n   ~~~\r\n\r\n   \r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-03_20-07-02.png)\r\n\r\n---\r\n\r\n\r\n\r\n## 二、操作数组\r\n\r\n### 1.0 数组的访问\r\n\r\n数组名[索引]\r\n通过这种方式寻找数组中的元素的时间复杂度是O(1)\r\n因为可以通过简单的计算得到所找元素的地址【目的地址=首元素地址+数据类型大小*索引值】\r\n\r\n### 2.0 数组的长度\r\n\r\n数组名.length   数组属性length\r\n当元素个数大于0；数组的最大索引length - 1\r\n\r\n### 3.0 遍历\r\n\r\n访问数组中的每一个元素\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void testArray3() {\r\n        //存储的是二进制数字，\'a\'存的是97的二进制数，\'4\'存的是52的二进制，65存的是65的二进制\r\n        final char[] ints = new char[]{\'a\', \'4\', 65, 99, 48};\r\n        //这种方法操作比较灵活\r\n        for (int i = 0; i < ints.length; i++) {\r\n            System.out.print(i == ints.length - 1 ? ints[i] : ints[i] + \",\");\r\n        }\r\n        System.out.println();\r\n        System.out.println(\"----------------------------------------------\");\r\n        //增强for循环也称为foreach\r\n        for (char anInt : ints) {\r\n            System.out.print(anInt + \" \");\r\n        }\r\n        System.out.println();\r\n        System.out.println(\"----------------------------------------------\");\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\na,4,A,c,0\r\n----------------------------------------------\r\na 4 A c 0 \r\n~~~\r\n\r\n\r\n\r\n### 4.0 去掉做高最低的平均分\r\n\r\n~~~java\r\n    @Test\r\n    public void testArray4() {\r\n        //简化静态初始化\r\n        final int[] arrs = {32, 3, 55, 1, 39, 54, 0};\r\n        int max, min, sum = 0;\r\n        max = min = arrs[0];\r\n        for (int arr : arrs) {\r\n            if (arr > max) {\r\n                max = arr;\r\n            }\r\n            if (arr < min) {\r\n                min = arr;\r\n            }\r\n            sum += arr;\r\n        }\r\n        System.out.println(\"去掉最高最低的平均分为：\" + sum / (arrs.length - 2));\r\n    }\r\n~~~\r\n\r\n\r\n\r\n### 5.0 猜数游戏\r\n\r\n~~~java\r\n    public static void main(String[] args) {\r\n        final int[] ints = new int[4];\r\n        final Random r = new Random();\r\n        for (int i = 0; i < 4; i++) {\r\n            ints[i] = r.nextInt(6) + 45;//45----50\r\n        }\r\n        final Scanner sc = new Scanner(System.in);\r\n        //外层循环标志\r\n        OUT:\r\n        //死循环\r\n        while (true) {\r\n            System.out.println(\"请输入45-----50之间的整数进行猜数\");\r\n            final int i = sc.nextInt();\r\n            for (int a = 0; a < ints.length; a++) {\r\n                if (ints[a] == i) {\r\n                    System.out.println(\"恭喜猜对了，位置位于:\" + a);\r\n                    System.out.println(Arrays.toString(ints));\r\n                    break OUT;//用于结束外层循环（break循环和switch） continue循环\r\n                }\r\n            }\r\n            System.out.println(\"猜错了！\");\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n请输入45-----50之间的整数进行猜数\r\n45\r\n恭喜猜对了，位置位于:2\r\n[48, 50, 45, 45]\r\n~~~\r\n\r\n\r\n\r\n### 6.0 数组打乱\r\n\r\n~~~java\r\n    @Test\r\n    public void testArray5() {\r\n        final int[] arrs = {32, 3, 55, 1, 39, 54, 0};\r\n        System.out.println(\"原数组：\" + Arrays.toString(arrs));\r\n        final Random random = new Random();\r\n        //遍历数组中的每一个元素\r\n        for (int i = 0; i < arrs.length; i++) {\r\n            //随机一个数组范围内的数字\r\n            final int r = random.nextInt(arrs.length);\r\n            //将遍历到的元素与随机索引的元素交换位置\r\n            int tempAr = arrs[i];\r\n            arrs[i] = arrs[r];\r\n            arrs[r] = tempAr;\r\n        }\r\n        System.out.println(\"打乱后数组：\" + Arrays.toString(arrs));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n原数组：[32, 3, 55, 1, 39, 54, 0]\r\n打乱后数组：[3, 55, 54, 32, 0, 1, 39]\r\n~~~\r\n\r\n\r\n\r\n### 7.0 冒泡排序\r\n\r\n- 1\r\n\r\n~~~java\r\n    /**\r\n     * 没有优化\r\n     */\r\n    @Test\r\n    public void testArrays2() {\r\n        int[] arrs = {12, 33, 4, -3, 1, 90};\r\n        for (int i = 0; i < arrs.length - 1; i++) {\r\n            for (int j = 0; j < arrs.length - 1; j++) {\r\n                if (arrs[j] > arrs[j + 1]) {\r\n                    swap(arrs, j, j + 1);\r\n                }\r\n            }\r\n            System.out.println(\"第\" + (i + 1) + \"轮\" + Arrays.toString(arrs));\r\n        }\r\n        System.out.println(\"长度为:\" + arrs.length);\r\n        System.out.println(\"结果:\" + Arrays.toString(arrs));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n第1轮[12, 4, -3, 1, 33, 90]\r\n第2轮[4, -3, 1, 12, 33, 90]\r\n第3轮[-3, 1, 4, 12, 33, 90]\r\n第4轮[-3, 1, 4, 12, 33, 90]\r\n第5轮[-3, 1, 4, 12, 33, 90]\r\n长度为:6\r\n结果:[-3, 1, 4, 12, 33, 90]\r\n~~~\r\n\r\n\r\n\r\n- 2\r\n\r\n~~~java\r\n    /**\r\n     * 优化一\r\n     */\r\n    @Test\r\n    public void bubbleSortedArray() {\r\n        int[] array = {12, 33, 4, -3, 1, 90};\r\n        for (int i = 0; i < array.length - 1; i++) {\r\n            //没有进行过交换\r\n            boolean flag = false;\r\n            for (int j = 0; j < array.length - 1 - i; j++) {\r\n                if (array[j] > array[j + 1]) {\r\n                    swap(array, j, j + 1);\r\n                    //有进行过交换\r\n                    flag = true;\r\n                }\r\n            }\r\n            System.out.println(\"第\" + (i + 1) + \"轮\" + Arrays.toString(array));\r\n            //没有尽心过交换就退出\r\n            if (!flag) break;\r\n        }\r\n        System.out.println(\"长度为:\" + array.length);\r\n        System.out.println(\"结果:\" + Arrays.toString(array));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n第1轮[12, 4, -3, 1, 33, 90]\r\n第2轮[4, -3, 1, 12, 33, 90]\r\n第3轮[-3, 1, 4, 12, 33, 90]\r\n第4轮[-3, 1, 4, 12, 33, 90]\r\n长度为:6\r\n结果:[-3, 1, 4, 12, 33, 90]\r\n~~~\r\n\r\n\r\n\r\n- 3\r\n\r\n~~~java\r\n	/**\r\n     * 优化二\r\n     */\r\n    @Test\r\n    public void bubbleSortedArray2() {\r\n        int[] array = {12, 33, 4, -3, 1, 90};\r\n        int count = 0;\r\n        int n = array.length - 1;\r\n        while (true) {\r\n            //当数组已经有序，不出现交换时，让其退出\r\n            int last = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                if (array[i] > array[i + 1]) {\r\n                    swap(array, i, i + 1);\r\n                    //记录每次的交换位置\r\n                    last = i;\r\n                }\r\n            }\r\n            //记录最后的交换位置，并以此为次数的条件\r\n            n = last;\r\n            System.out.println(\"第\" + (++count) + \"轮\" + Arrays.toString(array));\r\n            if (n == 0) break;\r\n        }\r\n        System.out.println(\"长度为:\" + array.length);\r\n        System.out.println(\"结果:\" + Arrays.toString(array));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n第1轮[12, 4, -3, 1, 33, 90]\r\n第2轮[4, -3, 1, 12, 33, 90]\r\n第3轮[-3, 1, 4, 12, 33, 90]\r\n第4轮[-3, 1, 4, 12, 33, 90]\r\n长度为:6\r\n结果:[-3, 1, 4, 12, 33, 90]\r\n~~~\r\n\r\n\r\n\r\n## 三、数组内存原理\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_09-22-40.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 说明\r\n\r\n1. java源代码通过javac.exe编译成字节码文件再通过java.exe将字节码文件加载进jvm中\r\n2. 字节码文件会加载进方法区，字节码文件会暴露静态方法的访问地址\r\n3. 栈内存用来运行方法的(方法中又包含局部变量)，局部变量的引用在栈中\r\n4. 基本数据类型的变量直接存储值\r\n5. 引用数据类型的变量存储地址\r\n6. 对象存在于堆内存中\r\n\r\n## 四、java参数的传递方式【值传递】\r\n\r\n~~~java\r\n    /**\r\n     * java参数传递方式都是值传递（数组地址值）\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        int[] arrs = {1, 255, 3, 23, 0, -43};\r\n        System.out.println(\"原来的值：\" + Arrays.toString(arrs));\r\n        System.out.println(\"原来的地址：\" + arrs);\r\n        set(arrs);\r\n        System.out.println(\"变化后的值：\" + Arrays.toString(arrs));\r\n\r\n    }\r\n    private void set(int[] arrs) {\r\n        System.out.println(\"方法获得的地址：\" + arrs);\r\n        for (int i = 0; i < arrs.length; i++) {\r\n            arrs[i] = 8;\r\n        }\r\n        System.out.println(\"方法内部的值：\" + Arrays.toString(arrs));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n原来的值：[1, 255, 3, 23, 0, -43]\r\n原来的地址：[I@61e717c2\r\n方法获得的地址：[I@61e717c2\r\n方法内部的值：[8, 8, 8, 8, 8, 8]\r\n变化后的值：[8, 8, 8, 8, 8, 8]\r\n~~~\r\n\r\n\r\n\r\n### 1.0 地址交换\r\n\r\n~~~java\r\n /**\r\n     * java参数传递方式都是值传递（字符串地址值）\r\n     两个局部变量交换地址，对成员变量没有半毛钱影响\r\n     */\r\n    @Test\r\n    public void test2() {\r\n        String a = \"aaa\";\r\n        String b = \"bbb\";\r\n        System.out.println(\"原值：a=\" + a + \" b=\" + b);\r\n        swap(a, b);\r\n        System.out.println(\"更改后：a=\" + a + \" b=\" + b);\r\n\r\n    }\r\n\r\n    private void swap(String a, String b) {\r\n        String temp = a;\r\n        a = b;\r\n        b = temp;\r\n        System.out.println(\"方法内：a=\" + a + \" b=\" + b);\r\n    }\r\n~~~\r\n\r\n~~~\r\n原值：a=aaa b=bbb\r\n方法内：a=bbb b=aaa\r\n更改后：a=aaa b=bbb\r\n~~~\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_12-44-12.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n## 五、数组使用注意点\r\n\r\n1. 为了吸引c语言的使用者，数组也可以定义为 数据类型 变量名[] =new 数据类型[x]\r\n2. 什么类型的数组就存放什么类型的数据\r\n3. 数组一但定义出来，其长度，类型就固定了（无论动静）\r\n4. 动态初始化时，数组中各个元素都有默认值\r\n5. 数组有两种遍历的方法:for、foreach(增强for)\r\n6. 动静初始化数组不可以混着用\r\n7. java.lang.ArrayIndexOutOfBoundsException\r\n\r\n- 数组下标越界异常\r\n\r\n~~~java\r\n    @Test\r\n    public void test3() {\r\n        final int[] ints = new int[4];\r\n        System.out.println(ints[3]);\r\n        System.out.println(ints[4]);//java.lang.ArrayIndexOutOfBoundsException: 4 \r\n        System.out.println(\"程序结束！\");//(如果不处理异常)以下代码不会执行\r\n    }\r\n~~~\r\n\r\n- 空指针异常\r\n\r\n~~~java\r\n    @Test\r\n    public void test4() {\r\n        int[] ints = new int[4];\r\n        System.out.println(ints[1]);\r\n        ints = null;\r\n        System.out.println(ints[1]);//java.lang.NullPointerException\r\n        System.out.println(\"程序结束！\");//如果不处理异常，将无法执行此代码\r\n    }\r\n~~~\r\n\r\n问题1：如果访问的元素位置超过最大索引，执行时会出现ArrayIndexOutOfBoundsException(数组索引越界异常)\r\n\r\n问题2：如果数组变量中没有存储数组的地址，而是null, 在访问数组信息时会出现NullPointerException(空指针异常)\r\n\r\n## 六、IDEA DEBUG\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_10-29-46.png)\r\n\r\n---\r\n\r\n', 'https://picsum.photos/seed/52knb/800/450', '原创', 1, b'1', b'0', b'1', b'1', b'1', '2022-06-13 13:44:47', '2022-06-13 14:23:23', 1, 1, 'java数组', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (16, 'java方法', '## 一、什么是方法\r\n\r\n### 1.0 方法概念\r\n\r\n它可以把一段代码封装成一个功能，以方便重复调用\r\n\r\n### 2.0 好处\r\n\r\n1. 提高代码复用\r\n2. 逻辑清晰\r\n\r\n### 3.0 定义格式\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_10-48-19.png)\r\n\r\n---\r\n\r\n![](D:/learn/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/java%E5%9F%BA%E7%A1%80/day05-%E6%96%B9%E6%B3%95/PPT/004%E6%96%B9%E6%B3%95.assets/Snipaste_2022-03-04_10-54-15.png)\r\n\r\n---\r\n\r\n\r\n\r\n注意：\r\n\r\n1. 权限修饰符：pulic 所有类都可以访问，protected同一个包下的类一级该类的子类，不写（缺省）包权限同一个包内有效，private本类有效\r\n2. static修饰代表这是一个静态方法，随类加载一次\r\n3. 如果方法申明了具体的返回值类型，内部必须使用return返回对应类型的数据。\r\n4. 如果是void 就直接return; 方法中看到return就会结束方法(会先返回返回值)\r\n5. return语句下面，不能编写代码，因为永远执行不到，属于无效的代码。\r\n6. 形参列表可以有多个，甚至可以没有； 如果有多个形参，多个形参必须用\",\"隔开，且不能给初始化值。\r\n7. 同一个类中的同名方法的不同形参列表构成的两个以上的方法称为方法重载（方法名，形参列表）\r\n8. 用final修饰的入参不赋初始值，入参不能赋初值\r\n\r\n\r\n\r\n### 4.0 方法常见问题\r\n\r\n1. 方法的编写顺序无所谓。\r\n2. 方法与方法之间是平级关系，不能嵌套定义。可以嵌套使用\r\n3. 方法不调用就不执行, 调用时必须严格匹配方法的参数情况。\r\n4. 有返回值的方法调用时可以选择定义变量接收结果，或者直接输出调用，甚至直接调用；无返回值方法的调用只能直接调用。\r\n5. 有static修饰符修饰的是静态成员方法，一般通过类名调用；也可以通过该类实例调用(不推荐)\r\n\r\n\r\n\r\n## 二、方法内存图\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_11-12-56.png)\r\n\r\n---\r\n\r\n字节码文件存放在方法区中，在字节码文件中会暴露访问静态方法的入口\r\n但方法是运行在栈内存中的，存放在方法中的局部变量也是存放在栈中\r\n\r\n\r\n\r\n## 三、方法参数转递机制（都是值传递）\r\n\r\n- 基本类型的参数传递形式\r\n\r\n 		传输实参给方法的形参的时候，并不是传输实参变量本身， 而是传输实参变量中存储的数据值，这就是值传递\r\n\r\n- 引用数据类型的参数传递形式\r\n\r\n传输实参给方法的形参的时候，并不是传输实参变量本身， 而是传输实参变量中存储的地址值，这就是值传递\r\n\r\n- Java的参数传递机制是什么\r\n\r\n​	值传递，传输的是实参存储的值。\r\n\r\n- 打印整型数组内容\r\n\r\n~~~java\r\n    /**\r\n     * 数组打印\r\n     */\r\n    @Test\r\n    public void test5() {\r\n        int[] array = {};\r\n        System.out.println(toString(array));\r\n    }\r\n\r\n    public String toString(int[] array) {\r\n        String temp = \"\";\r\n        if (array == null) {\r\n            return null;\r\n        } else {\r\n            temp += \"[\";\r\n            if (array.length > 0) {\r\n                for (int i = 0; i < array.length; i++) {\r\n                    temp += i == array.length - 1 ? array[i] : array[i] + \",\";\r\n                }\r\n            }\r\n            temp += \"]\";\r\n        }\r\n        return temp;\r\n    }\r\n~~~\r\n\r\n- 从数组中查询指定元素的索引\r\n\r\n~~~java\r\n    /**\r\n     * 返回索引\r\n     */\r\n    @Test\r\n    public void test6() {\r\n//        int[] array = {4,2,1,4};\r\n        int[] array = null;\r\n        System.out.println(indexOf(array, 4));\r\n    }\r\n\r\n    public Integer indexOf(int[] ints, int target) {\r\n        if (ints == null) {\r\n            return null;\r\n        } else {\r\n            for (int i = 0; i < ints.length; i++) {\r\n                if (ints[i] == target) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n~~~\r\n\r\n- 比较两个数组内容是否一致\r\n\r\n~~~java\r\n    /**\r\n     * 比较数组是否一致\r\n     */\r\n    @Test\r\n    public void test7() {\r\n        int[] array = {4, 2, 1, 4};\r\n        int[] array1 = {4, 2, 4};\r\n        System.out.println(equals(array, array1));\r\n    }\r\n\r\n    public boolean equals(int[] ints1, int[] ints2) {\r\n        if (ints1 == null || ints2 == null) {\r\n            return false;\r\n        }\r\n        if (ints1.length != ints2.length) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < ints1.length; i++) {\r\n            if (ints1[i] != ints2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n~~~\r\n\r\n## 四、方法的其他形势、技术\r\n\r\n### 1.0 方法重载\r\n\r\n1. 同一个类中，出现多个方法名称相同，但是形参列表是不同的，那么这些方法就是重载方法\r\n2. 调用方法的时候,会通过参数的不同来区分调用的是哪个方法\r\n3. 方法重载的作用\r\n   可读性好，方法名称相同提示是同一类型的功能，通过形参不同实现功能差异化的选择，这是一种专业的代码设计.(同一功能的差异化实现)\r\n4. 提高开发效率（调用兄弟方法）\r\n\r\n\r\n\r\n- 代码体现\r\n\r\n~~~java\r\n    public static void main(String[] args) {\r\n        fire();\r\n        fire(\"中国\");\r\n        fire(\"一百\", \"中国\");\r\n    }\r\n\r\n    public static void fire(String numbers, String location) {\r\n        System.out.println(\"发射\" + numbers + \"枚导弹给\" + location);\r\n    }\r\n\r\n    public static void fire(String location) {\r\n        fire(\"一\", location);\r\n    }\r\n\r\n\r\n    public static void fire() {\r\n        fire(\"美国\");\r\n    }\r\n~~~\r\n\r\n### 2.0 方法重载的识别技巧\r\n\r\n1. 形参列表不同指的是：形参的个数、类型、顺序不同，不关心形参的名称 (顺序 个数 类型)\r\n2. 只要是同一个类中，方法名称相同、形参列表不同，那么他们就是重载的方法，其他都不管！（如：修饰符，返回值类型都无所谓）\r\n\r\n\r\n\r\n~~~java\r\nprivate void open(){}\r\n\r\nprotece void open(int a){}\r\n\r\npublic void open(int a,int b){}\r\n\r\nvoid open(int a,int b){}//不是\r\n\r\npublic void open(double a,int b){}\r\n\r\npublic void open(int a,double b){}\r\n~~~\r\n\r\n### 3.0 return关键字\r\n\r\n​	作用:结束当前方法\r\n\r\n## 五、综合案例\r\n\r\n### 1.0 买飞机票\r\n\r\n~~~java\r\npublic static void main(String[] args) {\r\n        final Scanner sc = new Scanner(System.in);\r\n        System.out.print(\"请输入月份：\");\r\n        final int month = sc.nextInt();\r\n        System.out.print(\"请输入飞机票类型（头等舱，经济舱）：\");\r\n        final String type = sc.next();\r\n        System.out.print(\"请输入飞机票价格：\");\r\n        final double price = sc.nextDouble();\r\n        System.out.println(calc(month, type, price));\r\n    } \r\n\r\n    private static double calc(int month, String type, double price) {\r\n        if (month >= 5 && month <= 10) {\r\n            switch (type) {\r\n                case \"头等舱\":\r\n                    price *= 0.9;\r\n                    break;\r\n\r\n                case \"经济舱\":\r\n                    price *= 0.85;\r\n                    break;\r\n                default:\r\n                    System.out.println(\"机票类型输入有误！\");\r\n                    price = -1;\r\n            }\r\n        } else if (month == 11 || month == 12 || month >= 1 && month <= 4) {\r\n            switch (type) {\r\n                case \"头等舱\":\r\n                    price *= 0.7;\r\n                    break;\r\n\r\n                case \"经济舱\":\r\n                    price *= 0.65;\r\n                    break;\r\n                default:\r\n                    System.out.println(\"机票类型输入有误！\");\r\n                    price = -1;\r\n            }\r\n        } else {\r\n            System.out.println(\"月份输入有误\");\r\n            price = -1;\r\n        }\r\n        return price;\r\n    }\r\n~~~\r\n\r\n### 2.0 找素数\r\n\r\n~~~java\r\n  /**\r\n     * ClassName: MethodDemo2\r\n     * Description:素数判断\r\n     * date:2022/3/4\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test1() {\r\n        for (int i = 101; i <= 200; i++) {\r\n            //标志位，默认判断这个数是素数，当有一个数（范围2-sqrt（数））可以被这个数整除，则这个数不是素数\r\n            boolean flags = true;\r\n            for (int j = 2; j <= Math.sqrt(i); j++) {\r\n                if (i % j == 0) {\r\n                    //这个数不是素数\r\n                    flags = false;\r\n                    //可以判断下一个数\r\n                    break;\r\n                }\r\n            }\r\n            if (flags) {\r\n                System.out.print(i + \" \");\r\n            }\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 \r\n~~~\r\n\r\n\r\n\r\n### 3.0 验证码\r\n\r\n~~~java\r\n@Test\r\n    public void test2() {\r\n        System.out.println(createCode(5));\r\n    }\r\n\r\n    private String createCode(int i) {\r\n        final Random random = new Random();\r\n        String code = \"\";\r\n        for (int j = 0; j < i; j++) {\r\n            final int type = random.nextInt(3);\r\n            switch (type) {\r\n                //大写字母\r\n                case 0:\r\n                    code += (char) (random.nextInt(26) + 65);//65----->65+25\r\n                    break;\r\n                //小写字母\r\n                case 1:\r\n                    code += (char) (random.nextInt(26) + 97);//97----->97+25\r\n                //0----9数字\r\n                case 2:\r\n                    code += random.nextInt(10);\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n0Dp34C\r\n~~~\r\n\r\n\r\n\r\n### 4.0 数组数据加密\r\n\r\n~~~java\r\n    @Test\r\n    public void test3() {\r\n        int[] arrays = {1, 9, 8, 3};\r\n        System.out.println(\"原始数据：\" + printAray(arrays));\r\n        System.out.println(\"加密后数据：\" + md5(arrays));\r\n    }\r\n\r\n    /**\r\n     * Description:数据加密\r\n     * date:2022/3/4\r\n     */\r\n\r\n    private String md5(int[] arrays) {\r\n        for (int i = 0; i < arrays.length; i++) {\r\n            arrays[i] = (arrays[i] + 5) % 10;\r\n        }\r\n        return printAray(arrays);\r\n    }\r\n\r\n    /**\r\n     * Description:int类型数组反转\r\n     * date:2022/3/4\r\n     */\r\n    private int[] reverce(int[] arrays) {\r\n        for (int i = 0, j = arrays.length - 1;\r\n             i < j;\r\n             i++, j--) {\r\n            int temp = arrays[i];\r\n            arrays[i] = arrays[j];\r\n            arrays[j] = temp;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n\r\n    /**\r\n     * Description:数组打印\r\n     * date:2022/3/4\r\n     */\r\n\r\n    public String printAray(int[] arrays) {\r\n        String s = \"\";\r\n        if (arrays == null) {\r\n            return null;\r\n        } else {\r\n            s += \"[\";\r\n            for (int i = 0; i < arrays.length; i++) {\r\n                s += i == arrays.length - 1 ? arrays[i] : arrays[i] + \",\";\r\n            }\r\n            s += \"]\";\r\n        }\r\n        return s;\r\n    }\r\n~~~\r\n\r\n### 5.0 抽奖\r\n\r\n~~~java\r\n    /**\r\n     * Description: 抽奖\r\n     * date:2022/3/4\r\n     */\r\n\r\n    @Test\r\n    public void test6() {\r\n        int[] arrays = {2, 588, 888, 1000, 10000};\r\n        int[] indexs = {-1, -1, -1, -1, -1};\r\n        final Random r = new Random();\r\n\r\n        while (true) {\r\n            boolean flag = true;\r\n            final int index = r.nextInt(5);\r\n            for (int i = 0; i < indexs.length; i++) {\r\n                if (indexs[i] == index) {\r\n                    flag = false;//有人抽到过\r\n                    break;\r\n                }\r\n            }\r\n            if (flag) {//没人抽到过\r\n                for (int i = 0; i < indexs.length; i++) {\r\n                    if (indexs[i] == -1) {\r\n                        indexs[i] = index;\r\n                        System.out.println(\"已经抽取\" + arrays[index] + \"￥的红包\");\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (indexs[indexs.length - 1] != -1) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n~~~\r\n\r\n### 6.0 双色球\r\n\r\n~~~java\r\n public static void main(String[] args) {\r\n        judge(createLuckNumbers(), userNumber());\r\n    }\r\n\r\n\r\n    /**\r\n     * ClassName: MethodDemo3\r\n     * Description:判断是否中奖\r\n     * date:2022/3/4\r\n     */\r\n\r\n    private static void judge(int[] luckNumbers, int[] userNumber) {\r\n        int blue = 0;\r\n        int red = 0;\r\n\r\n        //0 1 2 3 4 5\r\n\r\n        for (int i = 0; i < userNumber.length - 1; i++) {\r\n            for (int i1 = 0; i1 < luckNumbers.length - 1; i1++) {\r\n                if (userNumber[i] == luckNumbers[i1]) {\r\n                    red++;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        blue = luckNumbers[luckNumbers.length - 1] == userNumber[userNumber.length - 1] ? 1 : 0;\r\n\r\n        System.out.print(\"您的号码：\");\r\n        printAray(userNumber);\r\n        System.out.print(\"中奖号码:\");\r\n        printAray(luckNumbers);\r\n        if (blue == 1 && red <= 2) {\r\n            System.out.println(\"五鸡\");\r\n        } else if (red == 4 && blue == 0 || red == 3 && blue == 1) {\r\n            System.out.println(\"十鸡\");\r\n        } else if (red == 5 && blue == 0 || red == 4 && blue == 1) {\r\n            System.out.println(\"两百\");\r\n        } else if (red == 5 && blue == 1) {\r\n            System.out.println(\"三千\");\r\n        } else if (red == 6 && blue == 0) {\r\n            System.out.println(\"五百万\");\r\n        } else if (red == 6 && blue == 1) {\r\n            System.out.println(\"一百万\");\r\n        } else {\r\n            System.out.println(\"恭喜，又没中奖！\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ClassName: MethodDemo2\r\n     * Description:从键盘中获取数据\r\n     */\r\n\r\n    private static int[] userNumber() {\r\n        final int[] ints = new int[7];\r\n        final Scanner sc = new Scanner(System.in);\r\n        System.out.print(\"请输入六个红球号码（1--33）用逗号隔开：\");\r\n        final String s = sc.nextLine();\r\n        final String[] strings = s.split(\",\");\r\n        for (int i = 0; i < ints.length - 1; i++) {\r\n            ints[i] = Integer.valueOf(strings[i]);\r\n        }\r\n        System.out.print(\"请输入一个蓝球（1----16）:\");\r\n        ints[ints.length - 1] = sc.nextInt();\r\n        return ints;\r\n    }\r\n\r\n\r\n    /**\r\n     * ClassName: MethodDemo20\r\n     * Description: 生成双色球\r\n     */\r\n\r\n    private static int[] createLuckNumbers() {\r\n        final int[] luckNumbers = new int[7];\r\n        final Random r = new Random();\r\n        for (int i = 0; i < luckNumbers.length - 1; i++) {\r\n            while (true) {\r\n                boolean flag = true;\r\n                final int tempNumber = r.nextInt(33) + 1;\r\n                for (int j = 0; j < i; j++) {\r\n                    if (luckNumbers[j] == tempNumber) {\r\n                        flag = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (flag) {\r\n                    luckNumbers[i] = tempNumber;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        luckNumbers[luckNumbers.length - 1] = r.nextInt(17) + 1;\r\n        return luckNumbers;\r\n    }\r\n\r\n\r\n    /**\r\n     * ClassName: MethodDemo2\r\n     * Description:数组打印\r\n     */\r\n\r\n    public static void printAray(int[] arrays) {\r\n        String s = \"\";\r\n        if (arrays == null) {\r\n            System.out.println(\"null\");\r\n            return;\r\n        } else {\r\n            s += \"[\";\r\n            for (int i = 0; i < arrays.length; i++) {\r\n                s += i == arrays.length - 1 ? arrays[i] : arrays[i] + \",\";\r\n            }\r\n            s += \"]\";\r\n        }\r\n        System.out.println(s);\r\n    }\r\n~~~\r\n\r\n', 'https://picsum.photos/seed/gv12/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-06-13 14:45:45', '2022-06-13 14:45:45', 1, 1, 'java方法', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (20, '面向对象', '## 一、初识面向对象\r\n\r\n1. 面向对象并不是一个技术，而是一种编程指导思想\r\n2. 面向对象是指把现实世界的具体事物全部看成一个一个的对象来解决实际问题\r\n3. 生活中我们是按照对象化的方式解决问题的。如果程序也能够按照生活的中的方式来解决问题，那么程序就更符合人类的思维习惯，代码看	起来会更易理解、更简单、更易维护。\r\n\r\n\r\n\r\n## 二、类、对象\r\n\r\n对象: 是对现实世界具体事物的抽象,是类的具体实例 。\r\n类(可以看成是设计图)：同类事物的共性，是对对象的抽象。\r\n在Java中，必须先设计类，才能获得对象\r\n\r\n\r\n\r\n### 1.0 类的定义\r\n\r\n~~~java\r\npublic class 类名{\r\n    //类中四大金刚\r\n    //1.属性\r\n        成员变量:实例成员变量、静态成员变量\r\n        局部变量:方法中的变量、代码块中的变量、入参\r\n    //2.构造器\r\n    		有参构造器\r\n    		无参构造器\r\n    		私有构造器\r\n    		公有构造器\r\n    //3.方法\r\n            静态方法\r\n            实例方法\r\n    //4.代码块\r\n            静态代码块\r\n            实例代码块\r\n    //5.内部类\r\n            成员内部类\r\n            静态内部类\r\n            局部内部类\r\n            匿名内部类\r\n}\r\n~~~\r\n\r\n\r\n\r\n### 2.0 注意事项\r\n\r\n1. 成员变量的完整定义格式是：修饰符 数据类型 变量名称 = 初始化值； 一般无需指定初始化值，存在默认值。\r\n2. 类名大驼峰模式,方法名小驼峰\r\n3. 一个Java文件中可以定义多个class类，且只能一个类是public修饰，而且public修饰的类名必须成为代码文件名。该java文件编译后	 会生成多个字节码文件\r\n4. 实际开发中建议还是一个文件定义一个class类。\r\n5. 成员变量 不同数据类型的默认初始值\r\n\r\n~~~\r\n	 byte short int char=\'\\u0000\'     0\r\n     float double 					  0.0\r\n     boolean                          false\r\n     类 接口 数组 String                null\r\n~~~\r\n\r\n\r\n\r\n## 三、Java对象内存图\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-04_22-47-20.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 内存图说明\r\n\r\n1. 加载Test的字节码文件进入方法区，其中字节码文件包括成员方法和成员变量(这里没有)\r\n2. 将Test字节码中的main方法提取到栈中，开始执行main方法里面的内容\r\n3. 将Car的字节码文件加载进方法区，其中包括成员变量name、price和成员方法start()、run(),\r\n   在堆内存中开辟一块内存空间代表汽车对象，其中会开辟一些区域用来存放属性信息（有默认值），还会汽车对象区域中开辟一些空间用于    存储属于该对象的存放在方法区中的	成员方法引用地址\r\n4. 在（main方法中）栈内存中开辟一块空间作为main方法的局部变量，用于存放汽车对象的地址\r\n5. 通过局部变量中存放的汽车对象地址找到汽车对象，然后对其name属性进行赋值操作\r\n   .........\r\n6. 通过局部变量c1存储的对象地址找到汽车对象，再通过汽车对象中的成员方法引用地址找到方法区中的方法提取到栈中运行，因为该方法	知到是哪个对象调用自己的，所以可以获取该对象的成员属性进行操作\r\n   ....................\r\n\r\n\r\n\r\n- 垃圾回收\r\n\r\n1. 注意：当堆内存中的类对象或数组对象，没有被任何变量引用（指向）时，就会被判定为内存中的“垃圾”。\r\n2. Java存在自动垃圾回收器，会定期进行清理。\r\n\r\n\r\n\r\n## 四、构造器\r\n\r\n- 构造器定义\r\n\r\n构造器的作用用于初始化一个类的对象，并返回对象的地址\r\n\r\n\r\n\r\n- 构造器定义格式：\r\n\r\n~~~\r\n修饰符 类名(形参列表){\r\n\r\n}\r\n~~~\r\n\r\n不同修饰符的权限\r\nprivate         本类有效\r\n缺省			   包权限\r\nprotected	    包权限+子类有效\r\npublic          所有类皆有效\r\n\r\n\r\n\r\n- 构造器分类\r\n\r\n1. 无参数构造器（默认存在的）：初始化的对象时，成员变量的数据均采用默认值。\r\n2. 有参数构造器：在初始化对象的时候，同时可以为对象进行赋值\r\n\r\n\r\n\r\n- 注意\r\n\r\n1. 任何类定义出来，默认就自带了无参数构造器，写不写都有。\r\n2. 一旦定义了有参数构造器，默认的无参数构造器就没有了，此时就需要自己写一个无参数构造器了\r\n\r\n\r\n\r\n## 五、this关键字\r\n\r\n1. this关键字可以出现在成员方法、构造器中，代表当前对象的地址。\r\n2. 作用：访问当前对象的成员变量、成员方法。\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-05_10-30-38.png)\r\n\r\n---\r\n\r\n\r\n\r\n## 六、封装\r\n\r\n- 概念\r\n\r\n1. 将同一类事物共性（属性和方法）归到一个类中\r\n2. 对象代表什么，就封装对应的数据，并提供相应的方法\r\n3. 使用一些修饰符尽可能的隐藏内部细节，只暴露一些接口与外界发生联系\r\n\r\n\r\n\r\n- 好处\r\n\r\n1. 实现专业化分工（有事，找对象，调方法）\r\n2. 隐藏信息，实现细节\r\n\r\n\r\n\r\n- JavaBean\r\n\r\n也可以称为实体类，其对象用于在程序中封装数据\r\n\r\n\r\n\r\n- 格式\r\n\r\n1. 成员变量使用 private 修饰。\r\n2. 提供每一个成员变量对应的 setXxx() / getXxx()。\r\n3. 必须提供一个无参构造器。\r\n\r\n\r\n\r\n### 1.0 成员变量与局部变量\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-05_11-03-05.png)\r\n\r\n---\r\n\r\n', 'https://picsum.photos/seed/iuy88/800/450', '原创', 2, b'1', b'1', b'1', b'1', b'1', '2022-06-13 15:51:50', '2022-06-13 15:52:49', 1, 1, '面向对象基础', '1,15', 1, 0, b'0');
INSERT INTO `t_blog` VALUES (21, 'String、ArrayList的常用API', '# 一、String定义变量存储字符串\r\n\r\n- API （Application Programming Interface,应用程序编程接口）\r\n\r\n1. Java写好的技术(功能代码)，咱们可以直接调用。\r\n2. Oracle 也为Java提供的这些功能代码提供了相应的 API文档(程序使用说明书) \r\n\r\n\r\n\r\n- String类的概述\r\n\r\n1. java.lang.String 类代表字符串，String类定义的变量可以用于指向字符串对象，同时String类提供了很多操作字符串的功能\r\n2. Java 程序中的所有字符串文字（例如“abc”）都为此类的对象。 \r\n   这种是存放由于字符串常量池中;new String(\"xx\")是存放于堆中的,产生了两个对象，一个在字符串常量池中，一个在堆中\r\n\r\n\r\n\r\n- 一些特点\r\n\r\n1. String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。\r\n       String变量每次的修改其实都是产生并指向了新的字符串对象。\r\n       原来的字符串对象 都是没有改变的，所以称不可变字符串\r\n2. 字符串常量池中的字符通过拼接(运算)，产生一个新的字符串存放于堆中\r\n   先创建StringBuilder实例用于拼接字符串，然后再把StringBuilder转换成字符串\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_09-37-14.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: StringDemo\r\n     * Description:不可变字符串验证\r\n     * date:2022/3/5\r\n     */\r\n\r\n    @Test\r\n    public void test1() {\r\n        String name = \"1\";\r\n        //String类重写了Object的toString方法，所以打出来的不是地址，而是字符串\r\n        System.out.println(\"1的hashcode\" + \"1\".hashCode());\r\n        System.out.println(\"1的hashcode\" + name.hashCode());\r\n        name += \"2\";\r\n        System.out.println(\"2的hashcode\" + \"2\".hashCode());\r\n        System.out.println(\"12的hashcode\" + name.hashCode());\r\n        name += \"3\";\r\n        System.out.println(\"3的hashcode\" + \"3\".hashCode());\r\n        System.out.println(\"123的hashcode\" + name.hashCode());\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n1的hashcode49\r\n1的hashcode49\r\n2的hashcode50\r\n12的hashcode1569\r\n3的hashcode51\r\n123的hashcode48690\r\n~~~\r\n\r\n\r\n\r\n- 创建String对象的两种方式\r\n\r\n1. 直接通过双引号获得String对象（常用）\r\n2. 通过String类的构造器创建对象\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_10-00-02.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: StringDemo\r\n     * Description:创建String对象的两种方式\r\n     * date:2022/3/6\r\n     */\r\n\r\n    @Test\r\n    public void test2() throws Exception {\r\n        java.lang.String name = \"苏未晓\";\r\n        System.out.println(\"name1=\" + name);\r\n\r\n        final String name2 = new String();//相当于name2 = \"\"\r\n        System.out.println(\"name2=\" + name2);\r\n\r\n        final String name3 = new String(\"苏未晓\");\r\n        System.out.println(\"name3=\" + name3);\r\n\r\n        //字符数组\r\n        char[] chars = {\'我\', \'是\', \'你\'};\r\n        final String name4 = new String(chars);\r\n        System.out.println(\"name4=\" + name4);\r\n        //字节数组\r\n        byte[] bytes = {65, 97, 66, 98, 46, 47, 48, 49, 50};\r\n        //将字节数组按特定编码转为字符串，指定起始位置，长度\r\n        final String name5 = new String(bytes, 4, 5, \"utf-8\");\r\n        System.out.println(\"name5=\" + name5);\r\n    }\r\n~~~\r\n\r\n~~~\r\nname1=苏未晓\r\nname2=\r\nname3=苏未晓\r\nname4=我是你\r\nname5=./012\r\n~~~\r\n\r\n\r\n\r\n- 两种创建对象的方式有什么区别？\r\n\r\n~~~java\r\n /**\r\n     * ClassName: StringDemo\r\n     * Description: String类的两种创建方式的区别\r\n     * date:2022/3/6\r\n     */\r\n    @Test\r\n    public void test3() {\r\n        String s1 = \"abc\";\r\n        String s2 = \"abc\";\r\n        //以“”方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份 true\r\n        System.out.println(s1 == s2); \r\n        //字符数组\r\n        char[] chs = {\'a\', \'b\', \'c\'};//数组的静态初始化3\r\n        String s3 = new String(chs);\r\n        String s4 = new String(chs);\r\n        System.out.println(s3 == s4); //通过构造器new对象，每new一次都会产生一个新对象，放在堆内存中 false\r\n    }\r\n~~~\r\n\r\n\r\n\r\n- 小结\r\n\r\n1. 以“”方式给出的字符串对象，在字符串常量池中存储，而且相同内容只会在其中存储一份。\r\n2. 通过构造器new对象，每new一次都会产生一个新对象，放在堆内存中\r\n\r\n\r\n\r\n- 常见面试题\r\n\r\n~~~java\r\n    @Test\r\n    public void test4() {\r\n		//创建了两个对象，字面量在字符串常量池中，构造器的在堆中\r\n        final String s = new String(\"abc\");\r\n        //String的hashCode()方法是返回对象的哈希码\r\n        System.out.println(\"s的hashcode：\" + s.hashCode());\r\n        //没有创建对象，因为字符串常量池中已经有了\r\n        final String s2 = \"abc\";\r\n        //String的hashCode()方法是返回对象的哈希码\r\n        System.out.println(\"s2的hashcode：\" + s2.hashCode());\r\n        //  == 比较的是地址，s的对象在堆内存中，s2的对象在字符串常量池中，所以不同\r\n        //String重写了equals方法，比较的是字符串的内容\r\n        System.out.println(s == s2);\r\n    }\r\n~~~\r\n\r\n~~~\r\ns的hashcode：96354\r\ns2的hashcode：96354\r\nfalse\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n	@Test\r\n    public void test5() {\r\n        String s1 = \"abc\";\r\n        String s2 = \"ab\";\r\n        //字符串在进行运算（拼接）时，产生的\r\n        //通过StringBuilder将s2和”c“拼接起来，再转为字符串\r\n        String s3 = s2 + \"c\";\r\n        System.out.println(s1 == s3);\r\n		//因为都是字面量值，java存在编译优化机制，在编译期间就可以将字符串拼接成 “abc”\r\n        String s4 = \"a\" + \"b\" + \"c\";\r\n        System.out.println(s1 == s4);\r\n    }\r\n~~~\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_11-45-23.png)\r\n\r\n---\r\n\r\n\r\n\r\n### String的内存原理\r\n\r\n- 通过String类的构造器得到String对象\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_10-21-19.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 通过双引号（字面量）的形式获得String对象\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_10-21-12.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n### String类的常用API\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_11-58-30.png)\r\n\r\n---\r\n\r\n1. == 是用来比较引用数据类型的地址，基本数据类型的数据值\r\n2. String 的equals方法用于比较内容是否相同，Object的equals方法比较是地址，因为底层还是调用了==；\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n![](D:\\Photos\\Snipaste_2022-03-06_12-03-12.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test6() {\r\n        String s = \"我是一个不知道是什么的人\";\r\n        //String的length属性得到的是字符串长度\r\n        for (int i = 0; i < s.length(); i++) {\r\n            //String的charAt方法是获取字符串某个索引的字符的值\r\n            System.out.print(s.charAt(i));\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n我是一个不知道是什么的人\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test7() {\r\n        String info = \"竹杖芒鞋轻胜马\";\r\n        final String information = new String(\"竹杖芒鞋轻胜马\");\r\n		//将字符串转为字符数组\r\n        final char[] charArray = info.toCharArray();\r\n        System.out.println(Arrays.toString(charArray));//[竹, 杖, 芒, 鞋, 轻, 胜, 马]\r\n		//截取字符串，只有一个参数就是，参数值索引到结尾\r\n        final String s1 = info.substring(4);\r\n        System.out.println(s1);//轻胜马\r\n        //截取字符串，两个参数就是，开始索引到结束索引 开始下标和结束下标（不是长度）包前不包后\r\n        final String s2 = info.substring(2, 4);\r\n        System.out.println(s2);//芒鞋\r\n		//字符串替换，将字符串中的某些字符替换成某些字符\r\n        final String s3 = info.replace(\"马\", \"*\");\r\n        System.out.println(s3);//竹杖芒鞋轻胜*\r\n		//判断字符串是否包含某些字符\r\n        System.out.println(info.contains(\"胜\"));//true\r\n		//判断字符串是否以某些字符打头的\r\n        System.out.println(info.startsWith(\"竹杖芒\"));//true \r\n        System.out.println(info.startsWith(\"杖芒\"));//false\r\n		//判断字符串是否以某些字符结尾的\r\n        System.out.println(info.endsWith(\"马\"));//true\r\n        System.out.println(info.endsWith(\"胜\"));//false\r\n		//判断两个字符串的内容是否相等\r\n        System.out.println(info.equals(information));//true\r\n        //判断两个字符串地址是否相等\r\n        System.out.println(info == information);//false\r\n    }\r\n~~~\r\n\r\n\r\n\r\n### String解决实际案例\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: StringDemo\r\n     * Description:三次输入验证登录\r\n     * date:2022/3/6\r\n     */\r\n\r\n    private static void login() {\r\n        final Scanner sc = new Scanner(System.in);\r\n        final String username = \"admin\";\r\n        final String password = \"admin\";\r\n        int count = 0;\r\n        while (true) {\r\n            System.out.println(\"请输入用户名：\");\r\n            final String name = sc.next();\r\n            System.out.println(\"请输入密码：\");\r\n            final String pwd = sc.next();\r\n            if (username.equals(name) && password.equals(pwd)) {\r\n                System.out.println(\"登陆成功！\");\r\n                break;\r\n            }\r\n            System.out.println(\"第\" + ++count + \"输入错误\");\r\n            //第一次过来是一；\r\n            if (count >= 3) {\r\n                System.out.println(\"次数已用完\");\r\n                break;\r\n            }\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: StringDemo\r\n     * Description:验证码\r\n     * date:2022/3/6\r\n     */\r\n\r\n    @Test\r\n    public void test8() {\r\n        String info = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n        final Random r = new Random();\r\n        String code = new String();\r\n        for (int i = 0; i < 5; i++) {\r\n            final int s = r.nextInt(info.length());\r\n            code += info.charAt(s);\r\n        }\r\n        System.out.println(code);\r\n    }\r\n~~~\r\n\r\nnext() 方法遇见第一个有效字符（非空格，非换行符）时，开始扫描，当遇见第一个分隔符或结束符(空格或换行符)时，结束扫描，获取扫描到的内容，即获得第一个扫描到的不含空格、换行符的单个字符串。\r\n可以看到，nextLine()自动读取了被next()去掉的Enter作为他的结束符，所以没办法给s2从键盘输入值。\r\n\r\n经过验证，我发现其他的next的方法，如double nextDouble() ， float nextFloat() ， int nextInt() 等与nextLine()连用时都存在这个问题，解决的办法是：在每一个 next()、nextDouble() 、 nextFloat()、nextInt() 等语句之后加一个nextLine()语句，将被next()去掉的Enter结束符过滤掉\r\n\r\n\r\n\r\n### 集合概述\r\n\r\n1. 集合是与数组类似，也是一种容器，用于装数据的\r\n   数组定义完成并启动后，类型确定、长度固定。\r\n   问题：在个数不能确定，且要进行增删数据操作的时候，数组是不太合适的\r\n2. 集合的大小不固定，启动后可以动态变化，类型也（可以）选择不固定。\r\n3. 集合非常适合做元素个数不确定，且要进行增删操作的业务场景\r\n\r\n\r\n\r\n### ArrayList快速入门\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_14-19-11.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        List list = new ArrayList();\r\n        //可以添加任意类型元素，但不建议，所以有泛型这种东西\r\n        list.add(\"交易延迟 毫无疑问\");\r\n        list.add(\'我\');\r\n        list.add(100);\r\n        list.add(100L);\r\n        list.add(1.0);\r\n        list.add(1.0F);\r\n        list.add(false);//存什么就什么，printWriter\r\n        list.add(1, \"deal late no doubt\");//指定索引，插入数据\r\n        System.out.println(list);//集合重写了toString方法，会直接输出内容\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[交易延迟 毫无疑问, deal late no doubt, 我, 100, 100, 1.0, 1.0, false]\r\n~~~\r\n\r\n\r\n\r\n### ArrayList对于泛型的支持\r\n\r\n~~~\r\n ArrayList<E>：其实就是一个泛型类可以在编译阶段约束集合对象只能操作某种数据类型\r\n            ArrayList<String> ：此集合只能操作字符串类型的元素。\r\n            ArrayList<Integer>：此集合只能操作整数类型的元素\r\n~~~\r\n\r\n注意：集合中只能存储引用类型，不支持基本数据类型 泛型也不支持基本数据类型(所以出现了包装类)\r\n\r\n\r\n\r\n### ArrayList常用API\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_14-33-52.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n增:boolean add(E e)\r\n删:boolean remove(Object o);E remove(int index);\r\n查:E get(int index)\r\n改:set(int index,E e)\r\n长度:size()\r\n~~~\r\n\r\n\r\n\r\n- 常用api代码\r\n\r\n~~~JAVA\r\n    /**\r\n     * ClassName: ArrayListDemo\r\n     * Description:ArrayList的常用API\r\n     * date:2022/3/6\r\n     */\r\n\r\n    @Test\r\n    public void test2() {\r\n        final List<String> list = new ArrayList<>();\r\n        list.add(\"java\");\r\n        list.add(\"java\");\r\n        list.add(\"oracle\");\r\n        list.add(\"phthon\");\r\n\r\n        final List list2 = list;//绕过泛型添加其他类型的变量，另外一种方法是通过反射绕过编译阶段\r\n        list2.add(1);\r\n\r\n        final Object o1 = list.get(1);\r\n        //集合中第二个位置的是字符串类型\r\n        //字符串强转必须判断类型\r\n        Object a1 = o1 instanceof String ? o1 : null;\r\n        //String类重写了toString方法，多态，对于方法而言，运行看右边，编译看左边 跑子类的方法\r\n        System.out.println(a1);\r\n\r\n        final Object o = list.get(4);\r\n        //集合中第二个位置的是整形的包装类 \r\n        Object a = o instanceof Integer ? o : null; \r\n        //包装类重写了toString方法，多态，对于方法而言，运行看右边，编译看左边 跑子类的方\r\n        System.out.println(a);法\r\n        //println方法，在输出前先使用String.valueOf,这个在判断不为空是就会调用该类的toString方法 [java, java, 																							oracle, phthon, 1]\r\n        System.out.println(list);\r\n        System.out.println(list.size());//5\r\n        System.out.println(list.remove(2));//删除集合中指定索引的元素，返回元素\r\n        System.out.println(list.remove(\"java\"));//删除集合中指定名字的元素（由前往后找，第一个），返回是否成功\r\n        list.set(0, \"123\");//修改指定索引下的元素值，返回原来的元素值   java\r\n    }\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### ArrayList遍历\r\n\r\n- arraylist遍历删除元素\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ArrayListDemo2\r\n     * Description:集合遍历删除，第一种方法 正向删\r\n     * date:2022/3/6\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        final List<Integer> list = new ArrayList<>();\r\n        Collections.addAll(list, 98, 77, 66, 89, 79, 50, 100);\r\n        System.out.println(list);\r\n        for (int i = 0; i < list.size(); i++) {\r\n            if (list.get(i) < 80) {\r\n                list.remove(i);\r\n                i--;//每删除一位就往前移一位，防止漏删\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n	/**\r\n     * ClassName: ArrayListDemo2\r\n     * Description:集合遍历删除，第一种方法 逆向删\r\n     * date:2022/3/6\r\n     */\r\n\r\n    @Test\r\n    public void test2() {\r\n        final List<Integer> list = new ArrayList<>();\r\n        Collections.addAll(list, 98, 77, 66, 89, 79, 50, 100);\r\n        System.out.println(list);\r\n        for (int i = list.size() - 1; i >= 0; i--) {\r\n            if (list.get(i) <= 80) {\r\n                list.remove(i);\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n\r\n\r\n- ArrayList存储自定义类型\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_15-39-50.png)\r\n\r\n---\r\n\r\n', 'https://picsum.photos/seed/pppz/800/450', '原创', 5, b'1', b'1', b'1', b'1', b'1', '2022-06-13 16:07:15', '2022-06-13 16:07:15', 1, 1, 'String、ArrayList的常用API', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (22, '面向对象中级(1)', '### static概述\r\n\r\nstatic是静态的意思，可以修饰成员变量和成员方法，内部类和代码块；\r\nstatic修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改\r\n\r\n\r\n\r\n### 成员变量可以分为两种\r\n\r\n1. 实例成员变量：类内方法外，无static修饰，属于每一个对象\r\n2. 静态成员变量：类内方法外，有static修饰，属于类（类的每一个对象）需要被共享的信息，可以被共享访问\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_17-04-40.png)\r\n\r\n---\r\n\r\n1. 加载User.class文件进入方法区内存\r\n2. 将静态成员变量加载进堆内存\r\n3. 将方法区中的main方法加载进栈内存中运行\r\n4. 通过类名操作静态成员变量\r\n5. 在栈内存中开辟一块存储User类型的空间，再到堆内存中开辟一块存放User实例的空间，并为成员变量赋初始值；然后把实例的地址交给栈中的user变量\r\n6. 通过实例的地址操作实例的成员变量\r\n7. 通过实例的地址找到实例再操作静态成员变量\r\n\r\n\r\n\r\n- 两种成员方法\r\n\r\n实例成员方法：(无static修饰，属于对象），只能用对象触发访问 表示对象自己的行为的，且方法中需要访问实例成员的，则该方法必须申明成实例方法或者实例一个对象，通过对象访问；\r\n静态成员方法：（有static修饰，属于类），建议用类名访问【子类类名也可以】，也可以用对象访问。如果该方法是以执行一个共用功能为目的，或者想要方便访问则可以申明成静态方法；\r\n\r\n\r\n\r\n~~~java\r\npublic class StaticDemo {\r\n    private String ip;\r\n    private String time;\r\n    //静态成员变量属于类,可以被所有该类的实例访问\r\n    private static int onlineNumber;\r\n\r\n    /**\r\n     * 实例成员方法可以访问本类中全部的成员变量和成员方法\r\n     */\r\n    public void say() {\r\n        ip = \"123\";\r\n        time = \"123\";\r\n        onlineNumber = 123;\r\n        test1();\r\n        StaticDemo.test2();\r\n        System.out.println(\"实例成员方法\");\r\n    }\r\n\r\n    /**\r\n     * 静态成员方法只能访问静态成员变量和静态成员方法\r\n     */\r\n    public static void funcSay() {\r\n        //ip = \"1 你你 23\";   //报错\r\n        //time = \"123\";//报错\r\n        onlineNumber = 123;\r\n        //test1();//报错\r\n        StaticDemo.test2();\r\n        System.out.println(\"静态成员方法\");\r\n    }\r\n\r\n\r\n    public void test1() {\r\n    }\r\n\r\n    public static void test2() {\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final StaticDemo staticDemo = new StaticDemo();\r\n        System.out.println(StaticDemo.onlineNumber);//访问静态成员变量\r\n        System.out.println(onlineNumber);//访问静态成员变量（在本类中可以这么写）\r\n        StaticDemo.funcSay();//访问静态成员方法\r\n        funcSay();//访问静态方法（在本类中可以这么写）\r\n        staticDemo.onlineNumber = 222;//可以通过实例访问静态成员变量（不推荐）\r\n        staticDemo.funcSay();//可以通过实例访问静态成员方法（不推荐）\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n- static成员方法内存原理\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_18-46-08.png)\r\n\r\n---\r\n\r\n\r\n\r\n1. 加载Student.class文件到方法区，此时会暴露静态方法的访问入口\r\n2. 提取main方法到栈内存中运行\r\n3. 通过类名访问该类的静态方法，从方法区中提取到栈中运行\r\n4. 在该类中调用该类的静态方法，可以省略不写 类名. ；从方法区中提取到栈中运行；编译后会不写\r\n5. 在栈中开辟一快存储Student类型的空间，用于存储在堆中开辟Student实例的空间的地址\r\n6. 通过句柄（Student实例的地址）对该实例的实例成员变量进行操作\r\n7. 通过实例地址，找到实例中的方法引用，从方法区中提取到占内存中运行\r\n\r\n\r\n\r\n- 工具类\r\n\r\n1. 工具类中定义的都是一些静态方法，每个方法都是以完成一个共用的功能为目的。\r\n2. 工具类既可方便调用，又可提高了代码复用（一次编写，处处可用）\r\n   为什么工具类中的方法不用实例方法做？ \r\n   		 实例方法需要创建对象调用，此时用对象只是为了调用方法，这样只会浪费内存\r\n3. 建议将工具类的构造器进行私有，工具类无需创建对象。\r\n4. 工具类里面都是静态方法，直接用类名访问即可\r\n\r\n\r\n\r\n- 注意点\r\n\r\n1. 静态方法只能访问静态的成员，不可以直接访问实例成员。可以间接---》通过构造器获取一个实例，再通过句柄调用实例方法\r\n2. 实例方法可以访问静态的成员，也可以访问实例成员。（属性和方法）\r\n3. 静态方法中是不可以出现this关键字和super\r\n\r\n\r\n\r\n- 代码块\r\n\r\n1. 代码块是类的5大成分之一（成员变量、构造器，成员方法，代码块，内部类），定义在类中方法外。\r\n2. 在Java类下，使用 {} 括起来的代码被称为代码块 \r\n\r\n\r\n\r\n- 静态代码块\r\n\r\n~~~\r\n    格式：static{}\r\n~~~\r\n\r\n特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次；优先执行，比main还早\r\n\r\n使用场景：在类加载的时候做一些静态数据初始化的操作，以便后续使用\r\n\r\n\r\n\r\n~~~java\r\npublic class StaticDemo2 {\r\n    private static String name;\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"===============main=================\");\r\n        System.out.println(name);\r\n    }\r\n\r\n    /**\r\n     * 随类一起加载，优先执行 用于对静态变量的初始化\r\n     */\r\n    static {\r\n        System.out.println(\"静态代码块执行\");\r\n        name = \"fgcy\";\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n静态代码块执行\r\n===============main=================\r\nfgcy\r\n~~~\r\n\r\n\r\n\r\n- 构造(实例 )代码块\r\n\r\n~~~\r\n格式：{}\r\n~~~\r\n\r\n特点：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行（相当于把实例代码块中的代码放到构造器最开始）\r\n使用场景：初始化实例资源\r\n\r\n\r\n\r\n~~~java\r\npackage static_demo;\r\n\r\n/**\r\n * ClassName: StaticDemo3 <br/>\r\n * Description: <br/>\r\n * date: 2022/3/6 20:18<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class StaticDemo3 {\r\n    private String name;\r\n\r\n    public StaticDemo3() {\r\n        System.out.println(\"构造器执行\");\r\n        System.out.println(name);\r\n    }\r\n\r\n    /**\r\n     * 优先于构造器执行，调用构造器先执行该代码段\r\n     */ {\r\n        System.out.println(\"构造代码块执行\");\r\n        name = \"123\";\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new StaticDemo3();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n构造代码块执行\r\n构造器执行\r\n123\r\n~~~\r\n\r\n\r\n\r\n- 一副扑克牌\r\n\r\n~~~java\r\npackage static_demo;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\npublic class StaticDemo4 {\r\n    private static List<String> cards = new ArrayList<>();\r\n\r\n    static {\r\n        String[] colors = {\"♠\", \"♥\", \"♣\", \"♦\"};\r\n        // 5、定义点数\r\n        String[] sizes = {\"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\"};\r\n        for (int i = 0; i < sizes.length; i++) {\r\n            for (int j = 0; j < colors.length; j++) {\r\n                cards.add(sizes[i] + colors[j]);\r\n            }\r\n        }\r\n        cards.add(\"大王\");\r\n        cards.add(\"小王\");\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(cards);\r\n        Collections.shuffle(cards);\r\n        System.out.println(cards);\r\n    }\r\n\r\n}\r\n~~~\r\n\r\n~~~\r\n[3♠, 3♥, 3♣, 3♦, 4♠, 4♥, 4♣, 4♦, 5♠, 5♥, 5♣, 5♦, 6♠, 6♥, 6♣, 6♦, 7♠, 7♥, 7♣, 7♦, 8♠, 8♥, 8♣, 8♦, 9♠, 9♥, 9♣, 9♦, 10♠, 10♥, 10♣, 10♦, J♠, J♥, J♣, J♦, Q♠, Q♥, Q♣, Q♦, K♠, K♥, K♣, K♦, A♠, A♥, A♣, A♦, 2♠, 2♥, 2♣, 2♦, 大王, 小王]\r\n[小王, 10♣, 3♦, J♦, A♠, 4♥, 6♠, J♥, J♣, 7♦, 3♣, Q♦, 5♥, 6♦, 5♠, A♥, 10♥, K♠, J♠, Q♣, 大王, Q♠, 3♠, 8♥, 9♦, 9♠, K♣, 8♠, K♥, 2♠, Q♥, 5♣, 4♠, 10♦, 4♦, 2♣, 9♥, 10♠, 6♥, A♦, 7♣, 4♣, 2♥, 8♦, 2♦, 9♣, 3♥, K♦, 7♠, A♣, 7♥, 6♣, 5♦, 8♣]\r\n~~~\r\n\r\n在启动系统时对数据进行初始化。\r\n使用静态代码块完成数据的初始化操作，代码优雅\r\n\r\n\r\n\r\n### 设计模式之单例\r\n\r\n- 什么是设计模式\r\n\r\n设计模式是一套被前人反复使用，多数人知晓，经过分类编目的代码设计经验总结，后来者可以直接拿来解决问题\r\n好的设计模式能够提高代码的重用性\r\n\r\n\r\n\r\n- 单例模式\r\n\r\n可以保证系统中，应用该模式的这个类永远只有一个实例，即一个类永远只能创建一个对象。\r\n例如任务管理器对象我们只需要一个就可以解决问题了，这样可以节省内存空间\r\n\r\n\r\n\r\n- 饿汉单例\r\n\r\n~~~java\r\npackage static_demo;\r\n\r\n/**\r\n * ClassName: SingleInstanceDemo1 <br/>\r\n * Description: <br/>\r\n * date: 2022/3/6 20:48<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class SingleInstanceDemo1 {\r\n    \r\n    public static SingleInstanceDemo1 singleInstanceDemo1 = new SingleInstanceDemo1();\r\n    private SingleInstanceDemo1() {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        SingleInstanceDemo1 s1 = singleInstanceDemo1;\r\n        SingleInstanceDemo1 s2 = singleInstanceDemo1;\r\n        SingleInstanceDemo1 s3 = singleInstanceDemo1;\r\n        System.out.println(s1==s2);//true\r\n        System.out.println(s1==s3);//true\r\n    }\r\n}\r\n~~~\r\n\r\n在用类获取对象的时候，对象已经提前为你创建好了\r\n\r\n\r\n\r\n- 懒汉单例\r\n\r\n~~~java\r\npackage static_demo;\r\n\r\n/**\r\n * ClassName: SingleInstanceDemo1 <br/>\r\n * Description: <br/>\r\n * date: 2022/3/6 20:48<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class SingleInstanceDemo2 {\r\n\r\n    private static SingleInstanceDemo2 singleInstanceDemo2;\r\n\r\n    private SingleInstanceDemo2() {\r\n\r\n    }\r\n\r\n    public static SingleInstanceDemo2 getInstance() {\r\n        if (singleInstanceDemo2 == null) {\r\n            singleInstanceDemo2 = new SingleInstanceDemo2();\r\n        }\r\n        return singleInstanceDemo2;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        SingleInstanceDemo2 s1 = getInstance();\r\n        SingleInstanceDemo2 s2 = getInstance();\r\n        SingleInstanceDemo2 s3 = getInstance();\r\n        System.out.println(s1 == s2);//true\r\n        System.out.println(s1 == s3);//true\r\n    }\r\n}\r\n~~~\r\n\r\n在真正需要该对象的时候，才去创建一个对象(延迟加载对象)\r\n\r\n\r\n\r\n### 面向对象三大特征之继承\r\n\r\n- 继承概念\r\n\r\n1. Java中提供一个关键字extends，用这个关键字，我们可以让一个类和另一个类建立起父子关系。\r\n\r\n   ~~~\r\n   public class Student extends People {}\r\n   ~~~\r\n\r\n   Student称为子类（派生类），People称为父类(基类 或超类)   子类 extends父类\r\n\r\n   \r\n\r\n2. 当子类继承父类后，就可以直接使用父类公共的属性和方法了。因此，用好这个技术可以很好的我们提高代码的复用性\r\n\r\n3. 子类 继承父类，子类可以得到父类的公开属性和行为，子类可以使用。\r\n\r\n4. Java中子类更强大\r\n\r\n\r\n\r\n- 初始继承\r\n\r\n~~~java\r\npackage inherit;\r\n\r\n/**\r\n * ClassName: Son <br/>\r\n * Description: <br/>\r\n * date: 2022/3/6 21:12<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class Son extends Father {\r\n    public void say() {\r\n        System.out.println(getName() + \"张开嘴巴啊啊啊\");//调用父类的公共方法\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final Son son = new Son();\r\n        son.setName(\"苏未晓\");//调用父类的公共方法,初始化父类的成员变量\r\n        son.say();\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n- 继承设计规范\r\n\r\n子类们相同特征（共性属性，共性方法）放在父类中定义，子类独有的的属性和行为应该定义在子类自己里面\r\n\r\n\r\n\r\n- 继承内存图\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-06_22-14-54.png)\r\n\r\n---\r\n\r\n1. 将Test.class文件加载进方法区，并暴露main方法的访问入口\r\n2. 在栈内存中开辟一块Student类型的空间，用于存储在堆内存中开辟的存放Student实例相关信息的空间，（其中包含成员属性和方法的引用）\r\n3. 通过句柄访问实例空间中的父类空间的方法\r\n4. 通过句柄访问实例空间中的子类空间的方法\r\n   ......\r\n\r\n\r\n\r\n\r\n\r\n- 继承的特点\r\n\r\n1. 子类可以继承父类的属性和行为，但是子类不能继承父类的构造器。子类有自己的构造器，父类构造器用于初始化父类对象\r\n2. Java是单继承模式：一个类只能继承一个直接父类。当多个父类中有相同名字的方法时引起二义性\r\n3. Java不支持多继承、但是支持多层继承，家族体系（当祖宗们有相同的方法时，使用离自己最近的，可以是自己）\r\n4. Java中所有的类都是Object类的子类\r\n5. 子类可以继承父类私有成员，只是不能直接访问（未证实）\r\n6. 子类可以直接使用父类的静态成员（共享），但子类不能继承父类的静态成员。因为静态成员随类加载一次，其并不存在于子类空间中；\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\npublic class Father {\r\n\r\n    public static void test(){\r\n        System.out.println(\"父类的静态方法\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\npublic class Son extends Father {\r\n\r\n    public static void main(String[] args) {\r\n        Son.test();//这里可以通过子类类名调父类的静态方法\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n- 在子类中访问成员（成员属性，成员方法）满足就近原则\r\n\r\n先子类局部范围找\r\n然后子类成员范围找\r\n然后父类成员范围找，如果父类范围还没有找到则报错\r\n如果子父类中，出现了重名的成员，会优先使用子类的，此时如果一定要在子类中使用父类的怎么办？\r\n可以通过super关键字，指定访问父类的成员，this关键字访问当前的成员变量\r\n\r\n\r\n\r\n~~~java\r\npackage inherit;\r\n\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        final Student student = new Student();\r\n        student.say();\r\n    }\r\n}\r\n\r\nclass People {\r\n    public String name = \"父类名字\";\r\n\r\n    public void say() {\r\n        System.out.println(name);\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n\r\nclass Student extends People {\r\n    public String name = \"子类名字\";\r\n\r\n    @Override\r\n    public void say() {\r\n        String name = \"子类局部名字\";\r\n        System.out.println(name);//子类局部名字 就近原则\r\n        System.out.println(this.name);//实例成员变量\r\n        System.out.println(super.name);//父类实例成员\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n子类局部名字\r\n子类名字\r\n父类名字\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage inherit;\r\n\r\n/**\r\n * ClassName: Demo <br/>\r\n * Description: <br/>\r\n * date: 2022/3/6 22:47<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        final Student student = new Student();\r\n        student.go();\r\n    }\r\n}\r\n\r\nclass People {\r\n    public void run() {\r\n        System.out.println(\"父类跑\");\r\n    }\r\n}\r\n\r\nclass Student extends People {\r\n    public void go() {//中转方法\r\n        run();//就近原则\r\n        super.run();\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"子类跑\");\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~\r\n子类跑\r\n父类跑\r\n~~~\r\n\r\n\r\n\r\n- 方法重写\r\n\r\n在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法\r\n\r\n方法重写的应用场景\r\n    当子类需要父类的功能，但父类的该功能不完全满足自己的需求时。\r\n    子类可以重写父类中的方法\r\n\r\n@Override重写注解\r\n    @Override是放在重写后的方法上，作为重写是否正确的校验注解。\r\n    加上该注解后如果重写错误，编译阶段会出现错误提示。\r\n    建议重写方法都加@Override注解，代码安全，优雅！\r\n\r\n方法重写注意事项和要求\r\n    重写方法的名称、形参列表必须与被重写方法的名称和参数列表一致。(方法名，形参列表，返回值类型【全部与父类一致】，修饰符【子类大于等于父类】)\r\n    私有方法不能被重写。（子类无法访问）\r\n    子类重写父类方法时，访问权限必须 大于或者等于 父类 （暂时了解 ：缺省 < protected < public）\r\n    子类不能重写父类的静态方法，如果重写会报错的；（子类没有继承父类的静态方法）\r\n\r\n\r\n\r\n- 子类构造器特点\r\n\r\n子类中 所有的 构造器默认都会先访问父类中 无参 的构造器，再执行自己\r\n\r\n为什么？\r\n    子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。\r\n    子类初始化之前，一定要调用父类构造器先完成父类数据空间的初始化\r\n\r\n子类构造器的第一行语句默认都是：super()，不写也存在\r\n\r\n~~~java\r\npackage inherit;\r\n\r\n\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        new Student();\r\n        System.out.println(\"--------------------------------------------\");\r\n        new Student(\"jjj\");\r\n    }\r\n}\r\n\r\nclass People {\r\n    public People() {\r\n        System.out.println(\"父类构造器\");\r\n    }\r\n}\r\n\r\nclass Student extends People {\r\n    private String name;\r\n\r\n    public Student(String name) {\r\n        this.name = name;\r\n        System.out.println(\"子类有参构造\");\r\n    }\r\n\r\n    public Student() {\r\n        System.out.println(\"子类构造器\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n父类构造器\r\n子类构造器\r\n--------------------------------------------\r\n父类构造器\r\n子类有参构造\r\n~~~\r\n\r\n\r\n\r\n- 子类构造器访问父类有参构造\r\n\r\nsuper调用父类有参数构造器的作用：\r\n   初始化继承自父类的数据。\r\n\r\n如果父类中没有无参数构造器，只有有参构造器，会出现什么现象呢？\r\n    会报错。因为子类默认是调用父类无参构造器的。\r\n\r\n如何解决？\r\n    子类构造器中可以通过书写 super(…)，手动调用父类的有参数构造器\r\n\r\n\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        final Student student = new Student(\"苏未晓\", \"睡觉\", true);\r\n        System.out.println(student.getName());\r\n        System.out.println(student.getHobbies());\r\n        System.out.println(student.isYoungster());\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\nclass People {\r\n    private String name;\r\n    private String hobbies;\r\n\r\n    public People() {//会被子类默认调用\r\n    }\r\n\r\n    public People(String name, String hobbies) {\r\n        this.name = name;\r\n        this.hobbies = hobbies;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getHobbies() {\r\n        return hobbies;\r\n    }\r\n\r\n    public void setHobbies(String hobbies) {\r\n        this.hobbies = hobbies;\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\nclass Student extends People {\r\n    private boolean youngster;\r\n\r\n    public Student(String name, String hobbies, boolean youngster) {\r\n        super(name, hobbies);//这里用父类的有参构造代替了默认的父类无参构造\r\n        this.youngster = youngster;\r\n    }\r\n\r\n    public Student() {//默认在所有子类构造器的第一行调用父类无参构造器\r\n    }\r\n\r\n    public boolean isYoungster() {\r\n        return youngster;\r\n    }\r\n\r\n    public void setYoungster(boolean youngster) {\r\n        this.youngster = youngster;\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n- this与super\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-07_08-25-05.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 通过this()调用本类的兄弟构造器\r\n\r\nthis(...)和super(…)使用注意点：\r\n子类通过 this (...）去调用本类的其他构造器，本类其他构造器会通过 super 去手动调用父类的构造器，最终还是会调用父类构造器的。\r\n注意：this(…) super(…) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中\r\n\r\n\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        final People people = new People(\"苏未晓\");\r\n        System.out.println(people.getHobbies());\r\n        System.out.println(people.getName());\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\nclass People {\r\n    private String name;\r\n    private String hobbies;\r\n\r\n    public People() {\r\n    }\r\n\r\n    public People(String name) {\r\n        //super();//这里不需要调用父类的构造器，因为兄弟构造器中已经调用了，不需要重复调用 \r\n        //this和super都只能放在构造器的第一行，所以两者不能共存于同一个构造器中\r\n        \r\n        this(name, \"睡觉\");//调用本类的其他构造器\r\n    }\r\n\r\n    public People(String name, String hobbies) {\r\n        this.name = name;\r\n        this.hobbies = hobbies;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getHobbies() {\r\n        return hobbies;\r\n    }\r\n\r\n    public void setHobbies(String hobbies) {\r\n        this.hobbies = hobbies;\r\n    }\r\n}\r\n\r\n\r\n~~~\r\n\r\n~~~\r\n睡觉\r\n苏未晓\r\n~~~\r\n\r\n', 'https://picsum.photos/seed/jnm00/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-06-16 21:38:07', '2022-06-16 22:14:49', 1, 1, 'static概述、成员变量分为两种、设计模式之单例、面向对象三大特征之继承', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (23, '面向对象中级(2)', '# 包\r\n\r\n## 1.0 概念\r\n\r\n1. 包是用来分门别类的管理各种不同类的、建包利于程序的管理和维护\r\n2. 建包的语法格式：package 公司域名倒写.技术名称。报名建议全部英文小写，且具备意义\r\n3. 建包语句必须在第一行，一般IDEA工具会帮助创建\r\n\r\n~~~java\r\n		package com.itheima.javabean;//建包语句\r\n        public class Student {\r\n        \r\n        }\r\n~~~\r\n\r\n~~~\r\n //带包编译某个目录下的全部java文件\r\n 注意：>javac -d . *.java \r\n~~~\r\n\r\n\r\n\r\n## 2.0 导包  \r\n\r\n相同包下的类可以直接访问，不同包下的 类必须导包,才可以使用！导包格式：import 包名.类名;\r\n假如一个类中需要用到不同类，而这个【两个类的名称】是一样的，那么默认只能导入一个类，另一个类要带包名访问。\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-07_09-01-53.png)\r\n\r\n---\r\n\r\n- 两个类名相同的包，一个可以导包，一个必须全类名\r\n\r\n~~~java\r\npackage package_demo;\r\n\r\npublic class Cat {\r\n    public void run() {\r\n        System.out.println(\"外猫跑\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        //一个包下的包与该包属于不同的包，所以要导包（当一个类中出现两个同名的类时，一个可以导包，一个需要用全限名访问）\r\n        final package_demo.inner_package.Cat cat = new package_demo.inner_package.Cat();\r\n        final Cat cat1 = new Cat();\r\n        cat.run();\r\n        cat1.run();\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage package_demo.inner_package;\r\n\r\npublic class Cat {\r\n    public void run(){\r\n        System.out.println(\"内猫跑\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n内猫跑\r\n外猫跑\r\n~~~\r\n\r\n\r\n\r\n# 权限修饰符\r\n\r\n\r\n\r\n## 1.0 什么是权限修饰符？\r\n\r\n\r\n\r\n什么是权限修饰符？\r\n    权限修饰符：是用来控制一个成员【**能够被访问**】的范围的。\r\n    可以修饰成员变量，方法，构造器，内部类(没有代码段)，不同权限修饰符修饰的成员能够被访问的范围将受到限制。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2.0 **权限修饰符的分类和具体作用范围：**\r\n\r\n权限修饰符：有四种作用范围由小到大（private -> 缺省 -> protected - > public ）\r\nprivate:本类中\r\n缺省:包权限\r\nprotected:包权限+子类\r\npublic:所有的类都可以\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-07_09-05-10.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n# final关键字\r\n\r\n\r\n\r\n## 1.0 概念\r\n\r\nfinal的作用：\r\nfinal 关键字是最终的意思，可以修饰（方法，变量，类）\r\n    修饰方法：表明该方法是最终方法，不能被重写。\r\n    修饰变量：表示该变量第一次赋值后，不能再次被赋值(有且仅能被赋值一次)。[所有变量，局部、成员]，基本数据类型数值不能改变，引用数据类型地址不能	改变（但对象内容可以改变）\r\n    修饰类：表明该类是最终类，不能被继承（java.lang.String）Enum\r\n    \r\n\r\n1. public static final修饰的变量称为常量，需要在定义的时候赋值；或者在静态代码块中赋值（静态代码块本来就是用于初始化静态成员变量）\r\n2. 用final修饰实例成员变量，此时该实例成员变量必须在定义的时候赋值（没有意义）【构造代码块、构造方法也可以】\r\n3. 用final修饰的局部成员变量可以不在定义的时候赋初始值【但使用之前必须赋值】\r\n\r\n\r\n\r\n\r\n\r\n# 常量\r\n\r\n\r\n\r\n## 1.0 常量概述和基本作用\r\n\r\n\r\n\r\n1. 常量是使用了public static final修饰的成员变量，必须有初始化值，而且执行的过程中其值不能被改变。\r\n2. 常量的作用和好处：可以用于做系统的配置信息，方便程序的维护，同时也能提高可读性\r\n3. 常量命名规范：英文单词全部大写，多个单词下划线连接起来。\r\n\r\n常量的执行原理\r\n    在编译阶段会进行“宏替换”，把使用常量的地方全部替换成真实的字面量。\r\n    这样做的好处是让使用常量的程序的执行性能与直接使用字面量是一样的。\r\n\r\n\r\n\r\n## 2.0 常量做信息标志和分类\r\n\r\n\r\n\r\n选择常量做信息标志和分类：\r\n    代码可读性好，实现了软编码形式\r\n\r\n\r\n\r\n~~~java\r\npackage constant_demo;\r\n\r\nimport com.sun.org.apache.bcel.internal.generic.BREAKPOINT;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\n\r\n/**\r\n * ClassName: ConstantDemo1 <br/>\r\n * Description: <br/>\r\n * date: 2022/3/7 9:55<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class ConstantDemo1 {\r\n\r\n    public static final int UP = 1;//使用常量作为信息分类的标志\r\n    public static final int DOWN = 2;\r\n    public static final int LEFT = 3;\r\n    public static final int RIGHT = 4;\r\n\r\n    \r\n    \r\n    public static void main(String[] args) {\r\n        final JFrame win = new JFrame();\r\n        final JPanel panel = new JPanel();\r\n\r\n        final JButton btn1 = new JButton(\"上\");\r\n        final JButton btn2 = new JButton(\"下\");\r\n        final JButton btn3 = new JButton(\"左\");\r\n        final JButton btn4 = new JButton(\"右\");\r\n\r\n        btn1.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(UP);\r\n            }\r\n        });\r\n        btn2.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(DOWN);\r\n            }\r\n        });\r\n        btn3.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(LEFT);\r\n            }\r\n        });\r\n        btn4.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(RIGHT);\r\n            }\r\n        });\r\n\r\n        panel.add(btn1);\r\n        panel.add(btn2);\r\n        panel.add(btn3);\r\n        panel.add(btn4);\r\n        win.add(panel);\r\n        win.setLocationRelativeTo(null);\r\n        win.setSize(300, 400);\r\n        win.setVisible(true);\r\n    }\r\n\r\n    public static void moveTo(int flag) {\r\n        switch (flag) {\r\n            case UP:\r\n                System.out.println(\"UP\");\r\n                break;\r\n            case DOWN:\r\n                System.out.println(\"DOWN\");\r\n                break;\r\n            case LEFT:\r\n                System.out.println(\"LEFT\");\r\n                break;\r\n            case RIGHT:\r\n                System.out.println(\"RIGHT\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n# 枚举\r\n\r\n\r\n\r\n## 1.0 枚举的概\r\n\r\n枚举是Java中的一种特殊 类型（特殊的类）\r\n枚举是多例模式（构造器是私有的，不能对外创建对象，且有多个实例；第一行罗列的名称就是实例的名字）\r\n枚举的作用：\"是为了做信息的标志和信息的分类\"。\r\n\r\n\r\n\r\n## 2.0 枚举定义的格式\r\n\r\n~~~\r\n 修饰符 enum 枚举名称{\r\n    第一行都是罗列枚举类实例的名称。\r\n}\r\n~~~\r\n\r\n- **java源文件**\r\n\r\n~~~java\r\n//java源文件\r\nenum Season{\r\n    SPRING , SUMMER , AUTUMN , WINTER;\r\n}\r\n~~~\r\n\r\n- **反编译文件**\r\n\r\n~~~java\r\n//将java源文件编译成字节码文件，再通过javap命令反编译，如下 \r\nCompiled from \"Season.java\"\r\n    public final class Season extends java.lang.Enum<Season> {\r\n        public static final Season SPRING = new Season();\r\n        public static final Season SUMMER = new Season();\r\n        public static final Season AUTUMN = new Season();\r\n        public static final Season WINTER = new Season();\r\n        \r\n        public static Season[] values();\r\n        public static Season valueOf(java.lang.String);\r\n    }\r\n~~~\r\n\r\n- 伪代码\r\n\r\n~~~java\r\npublic class Season extends Enum{\r\n        public static final Season SPRING;\r\n        public static final Season SUMMER;\r\n        public static final Season AUTUMN;\r\n        public static final Season WINTER;\r\n    \r\n    public Season(String name,int ori){\r\n        super(name,ori);\r\n    }\r\n    \r\n    static{\r\n          SPRING=new Season(\"SPRING\",1);\r\n          SPRING=new Season(\"SUMMER\",2);\r\n          SPRING=new Season(\"AUTUMN\",3);\r\n          SPRING=new Season(\"WINTER\",4);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 3.0枚举的特征\r\n\r\n\r\n\r\n1. 枚举类都是继承了枚举类型：java.lang.Enum\r\n2. 枚举都是最终类，不可以被继承。\r\n3. 构造器都是私有的，枚举对外不能创建对象。\r\n4. 枚举类的第一行默认都是罗列枚举对象的名称的。\r\n5. 枚举类相当于是多例模式\r\n\r\n\r\n\r\n## 4.0 使用枚举作为信息标志与分类\r\n\r\n选择常量做信息标志和分类：\r\n    虽然可以实现可读性，但是入参值不受约束，代码相对不够严谨\r\n\r\n枚举做信息标志和分类：\r\n    代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！建议使用\r\n\r\n\r\n\r\n~~~java\r\npackage constant_demo;\r\n\r\nimport com.sun.org.apache.bcel.internal.generic.BREAKPOINT;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\n\r\n/**\r\n * ClassName: ConstantDemo1\r\n * Description:\r\n * date: 2022/3/7 9:55\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class ConstantDemo1 {\r\n\r\n    public static void main(String[] args) {\r\n        final JFrame win = new JFrame();\r\n        final JPanel panel = new JPanel();\r\n\r\n        final JButton btn1 = new JButton(\"上\");\r\n        final JButton btn2 = new JButton(\"下\");\r\n        final JButton btn3 = new JButton(\"左\");\r\n        final JButton btn4 = new JButton(\"右\");\r\n\r\n        btn1.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(Direction.UP);//之前使用常量作为信息的标志与分类，不严谨；因为只要满足方法的参数列表类型的参数就可以填入，容易产生问题\r\n            }\r\n        });\r\n        btn2.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(Direction.DOWN);\r\n            }\r\n        });\r\n        btn3.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(Direction.LEFT);\r\n            }\r\n        });\r\n        btn4.addActionListener(new AbstractAction() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                moveTo(Direction.RIGHT);\r\n            }\r\n        });\r\n\r\n        panel.add(btn1);\r\n        panel.add(btn2);\r\n        panel.add(btn3);\r\n        panel.add(btn4);\r\n        win.add(panel);\r\n        win.setLocationRelativeTo(null);\r\n        win.setSize(300, 400);\r\n        win.setVisible(true);\r\n    }\r\n\r\n    public static void moveTo(Direction direction) {\r\n        switch (direction) {\r\n            case UP://switch兼容枚举类型，可以直接不带类名,\r\n                System.out.println(\"UP\");\r\n                break;\r\n            case DOWN:\r\n                System.out.println(\"DOWN\");\r\n                break;\r\n            case LEFT:\r\n                System.out.println(\"LEFT\");\r\n                break;\r\n            case RIGHT:\r\n                System.out.println(\"RIGHT\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage constant_demo;\r\n\r\npublic enum Direction {\r\n    UP, DOWN, LEFT, RIGHT;\r\n}\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n#  抽象类\r\n\r\n\r\n\r\n## 1.0 抽象类基本概述\r\n\r\n\r\n\r\n某个父类知道所有子类都要完成的功能，但是每个子类完成的情况又不一样，父类就只是定义该功能的基本要求，具体由子类实现，这个类就是抽象类\r\n\r\n抽象类其实是一种不完全的设计图\r\n\r\n\r\n\r\n- 抽象类定义格式\r\n\r\n~~~·\r\n修饰符 abstract class 类名{}\r\n\r\n必须用abstract修饰\r\n\r\n如果该类中有抽象方法，那么该类一定要定义成抽象类\r\n~~~\r\n\r\n- 抽象方法\r\n\r\n修饰符 abstract 返回值类型 方法名称(形参列表);\r\n	没有方法体，只有方法签名，必须用abstract修饰\r\n	抽象类的子类必须要实现父类的所有抽象方法，否则该子类也要申明成抽象类\r\n\r\n\r\n\r\n~~~java\r\npackage abstract_demo;\r\n\r\n/**\r\n * ClassName: Cards\r\n * Description:父类\r\n * date:2022/3/7\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic abstract class Cards {\r\n    private String name;\r\n    private double money;\r\n\r\n\r\n    public abstract void pay(double money);\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public double getMoney() {\r\n        return money;\r\n    }\r\n\r\n    public void setMoney(double money) {\r\n        this.money = money;\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage abstract_demo;\r\n\r\n/**\r\n * ClassName: GoldCard\r\n * Description:子类\r\n * date:2022/3/7\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class GoldCard extends Cards {\r\n    @Override\r\n    public void pay(double money) {\r\n        double rs = getMoney() - money * 0.8;\r\n        System.out.println(getName() + \"当前账户余额：\" + getMoney() + \"本次支付\" + money * 0.8 + \"账户剩余:\" + rs);\r\n        setMoney(rs);\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        final GoldCard goldCard = new GoldCard();\r\n        goldCard.setMoney(1000);\r\n        goldCard.setName(\"swx\");\r\n        goldCard.pay(100);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2.0 **特征和注意事项**\r\n\r\n1. 有得有失 得到了抽象方法，失去了创建对象的能力。\r\n\r\n2. 抽象类为什么不能创建对象？\r\n\r\n  因为抽象类中可能存在抽象方法，抽象方法没有方法体，不能实现功能\r\n\r\n3. 类有的成员（成员变量、方法、构造器）抽象类都具备\r\n\r\n4. 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类\r\n\r\n5. 一个类继承了抽象类必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。\r\n\r\n6. 不能用abstract修饰变量、代码块、构造器（abstract只能修饰类和方法）\r\n\r\n7. 抽象类必须有无参构造，因为抽象类必须有子类继承并实现抽象方法，子类实例自身时，需要先获取父类的属性、方法\r\n\r\n\r\n\r\n## 3.0 final和abstract是什么关系？\r\n\r\n互斥关系\r\n    abstract定义的抽象类作为模板让子类继承，final定义的类不能被继承\r\n\r\n​    抽象方法定义通用功能让子类重写，final定义的方法子类不能重写\r\n\r\n\r\n\r\n## 4.0 抽象类的应用知识：模板方法模式（设计模式）\r\n\r\n使用场景说明：当系统中出现同一个功能多处在开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候\r\n\r\n模板方法模式实现步骤\r\n\r\n​    把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码\r\n\r\n​    模板方法中不能决定的功能定义成抽象方法让具体子类去实现\r\n\r\n\r\n\r\n~~~java\r\npackage abstract_demo;\r\n\r\n/**\r\n * ClassName: Cards\r\n * Description:父类\r\n * date:2022/3/7\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic abstract class Cards {\r\n    private String name;\r\n    private String password;\r\n    private double money;\r\n\r\n    /**\r\n     * ClassName: Cards\r\n     * Description:模板方法\r\n     * date:2022/3/7\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    public final void handle(double money) {//模板方法是给子类直接使用的，不是让子类重写的，一旦子类重写了模板方法就失效了。\r\n\r\n        if (\"admin\".equals(name) && \"password\".equals(password)) {\r\n            System.out.println(\"登录验证成功\");\r\n\r\n            pay(money);//抽象方法，由子类具体实现\r\n\r\n            System.out.println(\"祝消费愉快\");\r\n        } else {\r\n            System.out.println(\"登录验证失败\");\r\n        }\r\n\r\n    }\r\n\r\n    public abstract void pay(double money);\r\n\r\n    public Cards() {\r\n    }\r\n\r\n    public Cards(String name, String password) {\r\n        this.name = name;\r\n        this.password = password;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public double getMoney() {\r\n        return money;\r\n    }\r\n\r\n    public void setMoney(double money) {\r\n        this.money = money;\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~java\r\n  package abstract_demo;\r\n\r\n/**\r\n * ClassName: GoldCard\r\n * Description:子类\r\n * date:2022/3/7\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class GoldCard extends Cards {\r\n    public GoldCard() {\r\n    }\r\n\r\n    public GoldCard(String name, String password) {\r\n        super(name, password);//直接把值传给父类构造器\r\n    }\r\n\r\n    @Override\r\n    public void pay(double money) {\r\n        double rs = getMoney() - money * 0.8;\r\n        System.out.println(getName() + \"当前账户余额：\" + getMoney() + \"本次支付\" + money * 0.8 + \"账户剩余:\" + rs);\r\n        setMoney(rs);\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        final GoldCard goldCard = new GoldCard(\"admin\", \"password\");\r\n        goldCard.handle(10000);//先是跑父类的模板方法，由于模板方法中存在抽象方法，所以此时跑的是子类实现的抽象方法，再回到模板方法\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n登录验证成功\r\nadmin当前账户余额：0.0本次支付8000.0账户剩余:-8000.0\r\n祝消费愉快 \r\n~~~\r\n\r\n\r\n\r\n- 模板方法我们是建议使用final修饰的，这样会更专业，那么为什么呢？\r\n      模板方法是给子类直接使用的，不是让子类重写的，一旦子类重写了模板方法就失效了\r\n\r\n- 模板方法模式解决了什么问题？\r\n\r\n 	极大的提高了代码的复用性\r\n 	 模板方法已经定义了通用结构，通用功能已经定义好了，差异化功能由子类具体实现；模板不能确定的定义成抽象方法。\r\n 	 使用者只需要关心自己需要实现的功能即可\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 接口\r\n\r\n\r\n\r\n## 1.0 什么是接口\r\n\r\n是一种规范\r\n\r\n\r\n\r\n## 2.0 接口格式\r\n\r\n~~~java\r\n//接口用关键字interface来定义\r\npublic interface 接口名 {\r\n       // 常量 (public static final )\r\n       // 抽象方法(public abstract)  1.8\r\n} \r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 3.0 注意\r\n\r\n\r\n\r\n1. JDK8之前接口中只能是抽象方法和常量，没有其他成分了。\r\n2. 接口不能实例化。\r\n3. 接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化\r\n4. 接口是更加具体的抽象，成员方法都是abstract修饰的\r\n\r\n\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\n/**\r\n * ClassName: User <br/>\r\n * Description: <br/>\r\n * date: 2022/3/8 7:48<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic interface User {\r\n    //    成员变量全是常量\r\n//    public static final String NAME = \"苏未晓\";\r\n    String NAME = \"苏未晓\";//接口成员变量都是常量，所以前面的修饰可以省略不写\r\n\r\n    //    public abstract void test(final String name);\r\n    void test(final String name);//接口是一种约束别人的规范，所以是方法是公开抽象的可以省略public abstract\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n## 4.0 接口与类的关系（多实现）\r\n\r\n1. 接口是用来被类实现（implements）的，实现接口的类称为实现类。实现类可以理解成所谓的子类。\r\n\r\n2. 格式：\r\n\r\n   ~~~java\r\n   修饰符 class 实现类 implements 接口1, 接口2, 接口3 , ... {\r\n   \r\n   }\r\n   ~~~\r\n\r\n   \r\n\r\n3. 实现的关键字：implements\r\n\r\n4. 接口可以被类单实现，也可以被类多实现。\r\n\r\n5. 一个类实现接口，必须重写完全部接口的全部抽象方法，否则这个类需要定义成抽象类\r\n\r\n\r\n\r\n~~~java\r\npublic interface Law {\r\n    void rule();\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npublic interface SportMan {\r\n    void eat();\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npublic class PingPongMan implements Law, SportMan {\r\n    @Override\r\n    public void rule() {\r\n        System.out.println(\"遵纪守法\");\r\n    }\r\n\r\n    @Override\r\n    public void eat() {\r\n        System.out.println(\"吃饭\");\r\n\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        final PingPongMan man = new PingPongMan();\r\n        man.eat();\r\n        man.rule();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\npublic abstract class PingPongMan implements Law, SportMan {\r\n    @Override\r\n    public void rule() {\r\n        System.out.println(\"遵纪守法\");\r\n    }\r\n\r\n    //当没有重写完所实现接口的所有抽象方法，就要将这个实现类定义为抽象类\r\n/*    @Override\r\n    public void eat() {\r\n        \r\n    }*/\r\n\r\n    public static void main(String[] args) {\r\n        //不能实例\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 5.0 接口与接口的关系（多继承）\r\n\r\n\r\n\r\n1. 接口和接口的关系：多继承，一个接口可以同时继承多个接口\r\n2. 接口多继承的作用\r\n   规范合并，整合多个接口为同一个接口，便于子类实现。\r\n3. 类和类的关系：单继承。\r\n4. 类和接口的关系：多实现\r\n\r\n\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\npublic interface Law {\r\n    void rule();\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\n\r\n\r\npublic interface SportMan {\r\n    void eat();\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\n/**\r\n * ClassName: User\r\n * Description:规范合并接口\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic interface User extends Law, SportMan {\r\n    String NAME = \"苏未晓\";//接口成员变量都是常量，所以前面的修饰可以省略不写\r\n\r\n    void test(final String name);//接口是一种约束别人的规范，所以是方法是公开抽象的可以省略public abstract\r\n\r\n    @Override\r\n    void eat();\r\n\r\n    void eat(int a);\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\n/**\r\n * ClassName: PingPongMan\r\n * Description:实现类\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class PingPongMan implements User {//只是继承了一个接口，但是因为所继承的接口多实现了其他接口（规范合并），所以也要遵守全部接口的规范\r\n\r\n    @Override\r\n    public void rule() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void eat() {//当多个接口都出现同一个一样的方法是，实现类仅仅需要实现一次，因为接口最终跑的是子类的方法\r\n\r\n    }\r\n\r\n    @Override\r\n    public void eat(int a) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void test(String name) {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final PingPongMan man = new PingPongMan();\r\n        man.rule();\r\n        man.eat();\r\n        man.test(\"a\");\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n- 规范冲突\r\n\r\n~~~java\r\n/**\r\n * ClassName: SportMan\r\n * Description:接口\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic interface SportMan {\r\n    void eat();//与Law中的eat方法一起形成规范冲突\r\n}\r\n\r\n\r\n/**\r\n * ClassName: Law\r\n * Description:接口\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic interface Law {\r\n    void rule();\r\n\r\n    String eat();//与SprotMan中的eat方法一起形成规范冲突\r\n}\r\n\r\n\r\n/**\r\n * ClassName: PingPongMan\r\n * Description:实现类\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic abstract class PingPongMan implements SportMan, Law {\r\n    //当所实现的两个不同的接口中出现，方法名相同，先参列表相同，不构成重构，但返回值类型不一致，形成了规范冲突\r\n}\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 6.0 JDK1.8开始接口的新增方法\r\n\r\n\r\n\r\n### 6.1 第一种：默认方法\r\n\r\n第一种：默认方法\r\n  类似于之前写的实例方法，必须用default修饰\r\n  默认会用public修饰\r\n  此方法只属于该接口的实现类，接口不能调用\r\n  默认方法可以实现，在丰富接口功能的同时又不对子类代码进行更改\r\n\r\n\r\n\r\n~~~java\r\npublic class PingPongMan implements SportMan {//如果所实现的接口全是默认方法，则该对象可以直接是实例出来\r\n    @Test\r\n    public void test1(){\r\n        final PingPongMan pingPongMan = new PingPongMan();\r\n        pingPongMan.run();\r\n    }\r\n}\r\n\r\n\r\ninterface SportMan {\r\n    default void run() {//默认方法只存在于接口中\r\n        System.out.println(\"只能由实现类调用的，默认方法！\");\r\n    }\r\n}\r\n//	默认方法！只能由实现类调用的\r\n~~~\r\n\r\n\r\n\r\n### 6.2 第二种:静态方法\r\n\r\n  默认会public修饰\r\n  必须用static修饰\r\n  接口的静态方法必须用本身的接口名来调用（与类区分开----》因为类的静态方法可以用对象调用，可以由子类类名调用）\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\ninterface SportMan {\r\n    static void go() {\r\n        System.out.println(\"接口中的静态方法\");\r\n    }\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npublic class PingPongMan implements SportMan {\r\n\r\n    @Test\r\n    public void test1() {\r\n        SportMan.go();//接口的静态方法只能由接口调用，不能由实现类调用（区别子类可以调用父类的静态方法------》共享，非继承）\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 6.3第三种:私有方法\r\n\r\n  必须使用private修饰\r\n  JDK 1.9才开始有的\r\n  只能在本类中被其他的默认方法或者私有方法访问\r\n\r\n\r\n\r\n~~~java\r\npublic class PingPongMan implements SportMan {\r\n\r\n    @Test\r\n    public void test1() {\r\n        new PingPongMan().go();//通过实例调用接口默认方法，再通过默认方法调用私有方法\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\ninterface SportMan {\r\n    default void go() {\r\n        System.out.println(\"默认方法，跑。。。\");\r\n        run();\r\n    }\r\n\r\n    /**\r\n     * 私有方法（实例方法）,实例方法不能被接口调用，但因为是私有权限，也不能被实现类调用；只能被本接口中的实例方法（默认方法）调用\r\n     */\r\n    private void run() {\r\n        System.out.println(\"私有方法\");\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 6.4 小结\r\n\r\n~~~java\r\npublic interface MyT {\r\n    private void test1(){\r\n        test2();//调用静态方法\r\n        test3();//调用默认方法\r\n        System.out.println(\"接口私有方法！\");\r\n    }\r\n    static void test2(){\r\n        System.out.println(\"接口静态方法\");\r\n    }\r\n    \r\n    default void test3(){\r\n        test1();//调用私有方法\r\n        test2();//调用静态方法\r\n        System.out.println(\"接口默认方法\");\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~\r\nCRTL+ALT+SHIFT+S--------------------->进入项目结构\r\nCRTL+ALT+S--------------------------->进入设置\r\n~~~\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-08_22-22-11.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-08_22-23-50.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n## 7.0 接口的注意事项\r\n\r\n1、接口不能创建对象\r\n\r\n\r\n\r\n2、一个类实现多个接口，多个接口中有同样的静态方法不冲突。接口的静态方法只能由接口调用，实现类不能调用；所以不会冲突\r\n\r\n\r\n\r\n3、一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的。如果子类重写了就使用子类的\r\n\r\n\r\n\r\n4、一个类实现了多个接口，多个接口中存在同名的 默认方法，不冲突，这个类重写该方法即可。\r\n\r\n​	 如果多个接口中存在**不构成同构【重载】的同名**方法，则存在规范冲突；不能实现这两个接口（不能多实现）\r\n\r\n5、一个接口继承多个接口，是没有问题的，如果多个接口中存在 规范冲突则 不能多继承。\r\n\r\n', 'https://picsum.photos/seed/mzaw8/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-06-16 22:16:47', '2022-06-16 22:16:47', 1, 1, '包、权限修饰符、final关键字、常量、枚举、抽象类、接口', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (24, '面向对象中级(3)', '\r\n\r\n# 一、面向对象的三大特征之多态\r\n\r\n## 1.0 什么是多态？\r\n\r\n- 同类型的对象，执行同一个行为，会表现出不同的行为特征\r\n\r\n\r\n\r\n## 2.0 多态的常见形式\r\n\r\n1. 父类类型 对象名称 = new 子类构造器;\r\n2. 接口 对象名称 = new 实现类构造器;\r\n\r\n\r\n\r\n## 3.0 多态中成员访问特点\r\n\r\n- 方法调用：编译看左边，运行看右边。\r\n- 变量调用：编译看左边，运行也看左边。（多态侧重行为多态）\r\n\r\n\r\n\r\n## 4.0 多态三前提\r\n\r\n1. 继承关系 \r\n2. 父句柄(引用)指向子类对象(向上转型) \r\n3. 方法重写\r\n\r\n\r\n\r\n## 5.0 注意\r\n\r\n- 多态是行为多态而不是属性多态\r\n\r\n\r\n\r\n## 6.0 多态**案例**\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\nimport javafx.animation.Animation;\r\n\r\n/**\r\n * ClassName: Animal\r\n * Description:\r\n * date:2022/3/8\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class Animal {\r\n    public String name = \"父类动物\";\r\n\r\n\r\n    public void run() {\r\n        System.out.println(\"动物跑\");\r\n    }\r\n}\r\n\r\n\r\nclass Dog extends Animal {\r\n    public String name = \"子类狗\";\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"狗刨\");\r\n    }\r\n}\r\n\r\nclass Cat extends Animal {\r\n    public String name = \"子类猫\";\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"猫跑\");\r\n    }\r\n}\r\n\r\nclass Test {\r\n    public static void main(String[] args) {\r\n        final Animal cat = new Cat();//1.继承关系 2.父句柄(引用)指向子类对象(向上转型) 3.方法重写 格式:父类类型/接口=new 子类构造器/实现类构造器\r\n        cat.run();//多态指的是方法多态，编译看左边，运行看右边（编译的时候看看左边类型的变量有没有这个方法，真正是运行右边的对象的方法）\r\n        System.out.println(cat.name);//对于变量就不涉及多态，即编译看左边，运行也看左边\r\n\r\n        final Animal dog = new Dog();\r\n        dog.run();\r\n        System.out.println(dog.name);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 7.0 多态优势\r\n\r\n- 在多态的形势下，右边的对象可以实现解耦合，便于扩展与维护\r\n\r\n  ```java\r\n  Animal a = new Dog();//这只狗可以随时替换掉，换成猫；下面的业务照跑\r\n  a.run();\r\n  ```\r\n\r\n- 定义方法的时候，使用父类型作为参数，该方法就可以接收这父类的一切子类对象，体现出多态的扩展性与便利\r\n\r\n~~~java\r\npackage inteface_demo;\r\n\r\n/**\r\n * ClassName: Animal\r\n * Description:\r\n * date:2022/3/8\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic abstract class Animal {\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public Animal(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    abstract void run();\r\n}\r\n\r\n~~~\r\n\r\n~~~java\r\nclass Dog extends Animal {\r\n    \r\n    public Dog(String name) {\r\n        super(name);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(getName() + \"狗刨\");\r\n\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\nCat extends Animal {\r\n    public Cat(String name) {\r\n        super(name);\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        System.out.println(getName() + \"猫跑\");\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\nclass MyTest {\r\n    //这个方法通过多态类型的局部变量来接收参数，提高了扩展性，可以接收这个类本类和所有的子类\r\n    public static void go(Animal animal) {\r\n        System.out.println(\"开始\");\r\n        animal.run();\r\n        System.out.println(\"结束\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final Dog dog = new Dog(\"旺财\");//局部变量收到该值（子类对象）时体现多态\r\n        final Animal dog2 = new Dog(\"旺财\");//此时就体现多态\r\n        final Cat cat = new Cat(\"Tom\");\r\n        final Animal cat2 = new Cat(\"Tom\");\r\n        go(dog);//这个被称为-------》对象回调，我把对象送过去，执行的是这个对象的方法\r\n        go(cat);\r\n    }\r\n\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n## 8.0 问题\r\n\r\n多态下不能使用子类的独有功能 \r\n原因编译看左边，运行看右边，所以编译时就会报错\r\n    解决：\r\n     向下转型，强制类型转化\r\n\r\n\r\n\r\n### 8.1 引用数据类型的类型转换\r\n\r\n- **自动类型转换**\r\n\r\n  > （从子到父)：子类对象赋值给父类类型的变量指向。\r\n\r\n- **强制类型转换**\r\n\r\n  > （从父到子)：此时必须进行强制类型转换：子类 对象变量 = (子类)父类类型的变量\r\n\r\n  注意\r\n\r\n  ~~~java\r\n  如果转型后的类型和对象真实类型不是同一种类型，那么在转换的时候就会出现ClassCastException;\r\n          Animal t = new Tortoise();\r\n  //有继承关系/实现的2个类型就可以进行强制转换，编译无问题;如果发现强制转换后的类型不是对象真实类型则出现异常 ClassCastException\r\n          Dog d = (Dog)t; \r\n          \r\n  Java建议强转转换前使用instanceof判断当前对象的真实类型，再进行强制转换\r\n      变量名 instanceof 真实类型\r\n      判断关键字左边的变量指向的对象的真实类型，是否是右边的类型或者是其子类类型，是则返回true，反之\r\n      \r\n      \r\n      //String与基本数据类型及其包装类之间不能强转-------》ClassCaseException\r\n      //搜索toString、valueOf、（String）区别\r\n         /*     \r\n          Object a = \"aaa\";\r\n          int b = (int) a;\r\n          Object a=123;\r\n          String b=(String) a;\r\n          */\r\n  ~~~\r\n\r\n  ~~~java\r\n  package inteface_demo;\r\n  \r\n  \r\n  /**\r\n   * ClassName: Animal\r\n   * Description:\r\n   * date:2022/3/8\r\n   *\r\n   * @author fgcy\r\n   * @since JDK 1.8\r\n   */\r\n  \r\n  public abstract class Animal {\r\n      private String name;\r\n  \r\n      public String getName() {\r\n          return name;\r\n      }\r\n  \r\n      public void setName(String name) {\r\n          this.name = name;\r\n      }\r\n  \r\n      public Animal(String name) {\r\n          this.name = name;\r\n      }\r\n  \r\n      abstract void run();\r\n  }\r\n  \r\n  /**\r\n   * ClassName: Animal\r\n   * Description:\r\n   * date:2022/3/9\r\n   *\r\n   * @author fgcy\r\n   * @since JDK 1.8\r\n   */\r\n  \r\n  class Dog extends Animal {\r\n      public Dog(String name) {\r\n          super(name);\r\n      }\r\n  \r\n      @Override\r\n      public void run() {\r\n          System.out.println(getName() + \"狗刨\");\r\n  \r\n      }\r\n  \r\n      public void eat() {\r\n          System.out.println(\"狗吃⑩\");\r\n      }\r\n  }\r\n  \r\n  /**\r\n   * ClassName: Animal\r\n   * Description:\r\n   * date:2022/3/9\r\n   *\r\n   * @author fgcy\r\n   * @since JDK 1.8\r\n   */\r\n  class Cat extends Animal {\r\n      public Cat(String name) {\r\n          super(name);\r\n      }\r\n  \r\n      @Override\r\n      public void run() {\r\n          System.out.println(getName() + \"猫跑\");\r\n      }\r\n  \r\n      public void eat() {\r\n          System.out.println(\"猫吃九\");\r\n      }\r\n  }\r\n  \r\n  class MyTest {\r\n      //这个方法通过多态类型的局部变量来接收参数，提高了扩展性，可以接收这个类本类和所有的子类\r\n      public static void go(Animal animal) {\r\n  		//判断左边是否是右边的本类型或者是子类型\r\n          if (animal instanceof Dog) {\r\n              //只要两者由继承关系，编译时就不会报错；但如果类型不一致，运行时就会报ClassCaseException\r\n              Dog dog = (Dog) animal;\r\n              dog.eat();\r\n          }\r\n          if (animal instanceof Cat) {\r\n              Cat cat = (Cat) animal;\r\n              cat.eat();\r\n          }\r\n      }\r\n  \r\n  \r\n      public static void main(String[] args) {\r\n          final Cat cat = new Cat(\"汤姆\");\r\n          go(cat);\r\n          final Dog dog = new Dog(\"谢狗\");\r\n          go(dog);\r\n      }\r\n  }\r\n  ~~~\r\n\r\n  好处\r\n\r\n  > 可以解决多态下的劣势，可以实现调用子类独有的功能\r\n\r\n  \r\n\r\n  ## 9.0 多态综合案例\r\n\r\n~~~java\r\npublic interface Usb {\r\n\r\n    void connect();\r\n\r\n    void unconnect();\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n/**\r\n * ClassName: Mouse\r\n * Description:鼠标类，Usb接口的实现类，是现有连接和断开连接的方法 还有自己独有的功能\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class Mouse implements Usb {\r\n    private String name;\r\n\r\n    public Mouse(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public void connect() {\r\n        System.out.println(getName() + \"已连接\");\r\n    }\r\n\r\n    @Override\r\n    public void unconnect() {\r\n        System.out.println(getName() + \"已移除\");\r\n    }\r\n\r\n    //自己独有的功能\r\n    public void click() {\r\n        System.out.println(\"鼠标点击\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\n/**\r\n * ClassName: Keyboard\r\n * Description:键盘类，Usb接口的实现类，是现有连接和断开连接的方法，还有自己独有的功能\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class Keyboard implements Usb {\r\n    private String name;\r\n\r\n    public Keyboard(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public void connect() {\r\n        System.out.println(getName() + \"已连接\");\r\n    }\r\n\r\n    @Override\r\n    public void unconnect() {\r\n        System.out.println(getName() + \"已移除\");\r\n    }\r\n    //自己独有的功能\r\n    public void write() {\r\n        System.out.println(\"键盘输入测试\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\n/**\r\n * ClassName: Computer\r\n * Description:调用USB实现类的方法\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class Computer {\r\n    private String name;\r\n\r\n    public Computer(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void start() {\r\n        System.out.println(getName() + \"电脑启动\");\r\n    }\r\n\r\n    public void connect(Usb usb) {\r\n        usb.connect();//USB接口的独有功能\r\n\r\n        if (usb instanceof Keyboard) {\r\n            Keyboard keyboard = (Keyboard) usb;\r\n            keyboard.write();\r\n        }\r\n        if (usb instanceof Mouse) {\r\n            Mouse mouse = (Mouse) usb;\r\n            mouse.click();\r\n        }\r\n        usb.unconnect();//USB接口的独有功能\r\n    }\r\n~~~\r\n\r\n~~~java\r\n   /**\r\n     * ClassName: Computer\r\n     * Description:面向对象编程（将鼠标和键盘组装到电脑中）\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    public static void main(String[] args) {\r\n        final Computer computer = new Computer(\"拯救者\");\r\n        final Keyboard keyboard = new Keyboard(\"罗技\");\r\n        final Mouse mouse = new Mouse(\"罗技\");\r\n        computer.start();\r\n        computer.connect(keyboard);//对象回调（将一个对象作为参数传递过去，实际调用的是该对象的方法）\r\n        computer.connect(mouse);//对象回调（将一个对象作为参数传递过去，实际调用的是该对象的方法）\r\n\r\n    }\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n救者电脑启动\r\n罗技已连接\r\n键盘输入测试\r\n罗技已移除\r\n罗技已连接\r\n鼠标点击\r\n罗技已移除\r\n~~~\r\n\r\n# 二、内部类\r\n\r\n## 1.0 内部类概念\r\n\r\n定义在一个类里面的类，里面的类可以理解成（寄生），外部类可以理解成（宿主）\r\n\r\n- 形式\r\n\r\n  ~~~java\r\n  public class People{\r\n      // 内部类\r\n      public class Heart{\r\n      }\r\n  }\r\n  ~~~\r\n\r\n- 特点\r\n\r\n1. 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构可以选择使用内部类来设计\r\n2. 内部类通常可以方便访问外部类的成员，包括私有的成员。\r\n3. 内部类提供了更好的封装性，内部类本身就可以用private protectecd等修饰，封装性可以做更多控制\r\n4. 内部类的修饰符可以是:private、缺省、protected、public，但类的修饰符只能是public（主类）和缺省（次类）\r\n\r\n\r\n## 2.0 静态内部类\r\n\r\n- 特点\r\n\r\n1.有static修饰，属于外部类本身\r\n\r\n2.它的特点和使用与普通类是完全一样的，类有的成分它都有，只是位置在别人里面而已\r\n\r\n3.静态内部类中可以直接访问外部类的静态成员，外部类的实例成员必须用外部类对象访问\r\n\r\n4.开发中实际上用的还是比较少\r\n\r\n- 格式\r\n\r\n~~~java\r\npublic class Outer{\r\n    // 静态成员内部类\r\n    public static class Inner{\r\n    }\r\n}\r\n~~~\r\n\r\n静态内部类创建对象的格式：   \r\n\r\n~~~java\r\n	外部类名.内部类名 对象名 = new 外部类名.内部类构造器;\r\n	范例：Outer.Inner in =  new Outer.Inner();\r\n~~~\r\n\r\n\r\n\r\n- 案例\r\n\r\n~~~java\r\npackage inner_class_demo;\r\n\r\n\r\npublic class StaticInnerClass {\r\n    private static int price;\r\n    private String sex;\r\n\r\n    public static class Inner {\r\n        private String name;//静态内部类可以有实例成员变量\r\n        private static String codeName;//静态内部类可以有静态成员变量\r\n\r\n\r\n        //静态内部类可以有实例成员方法\r\n        public String getName() {\r\n            return name;\r\n        }\r\n\r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n\r\n        public static String getCodeName() {\r\n            return codeName;\r\n        }\r\n\r\n        public static void setCodeName(String codeName) {\r\n            Inner.codeName = codeName;\r\n        }\r\n\r\n        public Inner() {\r\n        }\r\n\r\n        public Inner(String name) {\r\n            this.name = name;\r\n        }\r\n\r\n        //静态内部类可以有静态成员方法\r\n        public static void voice() {\r\n            System.out.println(\"静态内部类的静态方法访问外部类的静态变量\" + price);\r\n        }\r\n\r\n        public void init() {\r\n    	//System.out.println(sex);不能直接访问外部类的实例成员变量\r\n            //只能用外部类的实例来调用\r\n            final StaticInnerClass outClass = new StaticInnerClass();\r\n            System.out.println(outClass.sex);\r\n        }\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        //实例化静态内部类的格式 注意类型，走的还是构造器\r\n        StaticInnerClass.Inner inner = new StaticInnerClass.Inner(\"a\");\r\n        System.out.println(inner.getName());\r\n        inner.voice();//调用内部类的静态方法 不推荐写法\r\n        StaticInnerClass.Inner.voice();//调用内部类的静态方法 正确写法\r\n//        StaticInnerClass.voice();//调用内部类的静态方法 错误写法\r\n\r\n\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~\r\na\r\n静态内部类的静态方法访问外部类的静态变量0\r\n静态内部类的静态方法访问外部类的静态变量0\r\n~~~\r\n\r\n\r\n\r\n## 3.0 成员内部类\r\n\r\n1无static修饰，属于外部类的对象。\r\n\r\n2.JDK16之前，成员内部类中不能定义静态成员，JDK 16开始也可以定义静态成员了。\r\n	\r\n创建格式：\r\n\r\n~~~\r\n    格式：外部类名.内部类名 对象名 = new  外部类构造器.new 内部类构造器();\r\n​    范例：Outer.Inner in =  new Outer().new  Inner();\r\n\r\npublic class Outer {\r\n    // 成员内部类\r\n    public class Inner {\r\n    }\r\n}\r\n~~~\r\n\r\n3.成员内部类中是可以直接访问外部类的静态成员，外部类的静态成员只有一份可以被共享访问\r\n\r\n4、成员内部类的实例方法中可以直接访问外部类的实例成员，因为必须先有外部类对象，才能有成员内部类对象，所以可以直接访问外部类对象的实例成员\r\n\r\n5.静态内部类，内部类与外部类的关系相对独立；类似于定义了两个类；成员内部类则需要依赖外部类才能产生，可能更加契合面向对象语法\r\n\r\n~~~java\r\npackage inner_class_demo;\r\n\r\n\r\npublic class MemberClass {\r\n    private static String name;\r\n    private int sex;\r\n\r\n    public MemberClass(int sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    class Inner {\r\n        private String number;\r\n//        private static String hobbis;//jdk16之后才可以定义静态的变量和方法\r\n\r\n        public Inner(String number) {\r\n            this.number = number;\r\n        }\r\n\r\n        public String getNumber() {\r\n            return number;\r\n        }\r\n\r\n        public void setNumber(String number) {\r\n            this.number = number;\r\n        }\r\n\r\n        /*   public static void t(){\r\n            System.out.println(\"jdk16之后才可以定义静态的方法\");\r\n        }*/\r\n        public void get() {\r\n            System.out.println(\"外部类的实例变量\" + sex);\r\n            System.out.println(\"外部类的静态变量\" + name);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        //成员内部类实例需要使用外部类的实例调用内部类的构造器生成\r\n        final Inner inner = new MemberClass(12).new Inner(\"138\");\r\n        System.out.println(inner.getNumber());//访问成员内部类的成员方法\r\n        inner.get();\r\n//        MemberClass.Inner.t();//调用成员内部类的静态方法\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n\r\n\r\n## 4.0 面试题\r\n\r\n~~~java\r\n/**\r\n * ClassName: StaticInnerClass\r\n * Description:静态内部类访问不同位置的变量\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class StaticInnerClass {\r\n    private static int price;\r\n    private static String name = \"外部类变量\";\r\n\r\n    public static class Inner {\r\n        private String name = \"成员变量\";//静态内部类可以有实例成员变量\r\n\r\n        public void test() {\r\n            String name = \"局部变量\";\r\n            System.out.println(name);\r\n            System.out.println(this.name);\r\n\r\n            System.out.println(StaticInnerClass.name);\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        final Inner inner = new Inner();\r\n        inner.test();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n局部变量\r\n成员变量\r\n外部类变量\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n/**\r\n * ClassName: MemberClass\r\n * Description:成员内部类访问不同位置的变量\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\n\r\npublic class MemberClass {\r\n    private String name = \"外部类的变量\";\r\n\r\n    class Inner {\r\n        private String name = \"成员变量\";\r\n\r\n        public void test() {\r\n            String name = \"局部变量\";\r\n            System.out.println(name);\r\n            System.out.println(this.name);\r\n//（外部类类名.this.变量名） 访问的是成员内部类的外部类的变量 有this代表对象所以这种方式是成员内部类的方式\r\n            System.out.println(MemberClass.this.name);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final Inner inner = new MemberClass().new Inner();\r\n        inner.test();\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~\r\n局部变量\r\n成员变量\r\n外部类变量 \r\n~~~\r\n\r\n\r\n\r\n## 5.0 局部内部类\r\n\r\n（鸡肋语法，了解即可）\r\n局部内部类放在方法、代码块、构造器等执行体中。\r\n局部内部类的类文件名为： 外部类$N内部类.class。\r\n\r\n\r\n\r\n## 6.0 匿名内部类\r\n\r\n本质上是一个没有名字的局部内部类，定义在方法中、代码块中、等。\r\n作用：方便创建子类对象，最终目的为了简化代码编写\r\n\r\n格式：\r\n\r\n~~~java\r\n	new 类|抽象类名|或者接口名() {\r\n    重写方法;\r\n    };\r\n        Animal a = new Animal() {\r\n            public void run() {\r\n            }\r\n        };\r\n        a. run();\r\n~~~\r\n\r\n特点总结：\r\n    匿名内部类是一个没有名字的内部类。\r\n    匿名内部类写出来就会产生一个匿名内部类的对象。\r\n    匿名内部类的对象类型相当于是当前new的那个的类型的本类型或子类类型\r\n    局部内部类的类文件名为： 外部类$N内部类.class。\r\n\r\n\r\n\r\n~~~java\r\npublic class Father {\r\n    public void eat() {\r\n        System.out.println(\"父吃\");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n\r\n        //匿名内部类，存在与方法，代码块，构造器中（本质上就是局部内部类，并且没有引用指向）\r\n        //这里是类的匿名内部类\r\n        Father father = new Father() {\r\n            @Override\r\n            public void eat() {\r\n                super.eat();\r\n                System.out.println(\"子也吃\");\r\n            }\r\n        };\r\n        father.eat();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n父吃\r\n子也吃\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npublic abstract class Father {\r\n    public abstract void eat();\r\n\r\n    public static void main(String[] args) {\r\n\r\n        //匿名内部类，存在与方法，代码块，构造器中\r\n        //这里是抽象类的匿名内部类\r\n        //这里的匿名内部类会产生一个该抽象类的子类实例，通过父类型引用接\r\n        Father father = new Father() {\r\n            @Override\r\n            public void eat() {\r\n                System.out.println(\"通过匿名内部类获得匿名内部类对象（抽象类的子类实例）\");\r\n            }\r\n        };\r\n        father.eat();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n通过匿名内部类获得匿名内部类对象（抽象类的子类实例）\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\npublic class Test {\r\n\r\n    public static void main(String[] args) {\r\n        final Father father = new Father() {\r\n            @Override\r\n            public void eat() {\r\n                System.out.println(\"通过匿名内部类获得匿名内部类对象（接口实现类的实例）\");\r\n            }\r\n        };\r\n        father.eat();\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\ninterface Father {\r\n    void eat();//公开，抽象\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~\r\n通过匿名内部类获得匿名内部类对象（接口实现类的实例）\r\n~~~\r\n\r\n\r\n\r\n- \r\n- 实际开发案例\r\n\r\n~~~java\r\npackage incognit_demo;\r\n\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\n\r\n\r\npublic class PracticalDemo {\r\n    public static void main(String[] args) {\r\n        final JFrame win = new JFrame(\"登录\");\r\n\r\n        final JPanel panel = new JPanel();\r\n        final JButton btnLogin = new JButton(\"登录\");\r\n			//对象回调\r\n			//匿名内部类产生的匿名内部类对象作为入参\r\n   /*     btnLogin.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent e) {\r\n                JOptionPane.showMessageDialog(win, \"点击小子\");\r\n            }\r\n        });*/\r\n\r\n        //lambda表达式\r\n        btnLogin.addActionListener(e -> JOptionPane.showMessageDialog(win, \"点击小子2\"));\r\n        panel.add(btnLogin);\r\n        win.add(panel);\r\n        win.setVisible(true);//可见\r\n        win.setLocationRelativeTo(null);//居中\r\n        win.setSize(400, 300);//大小\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n开发中不是我们主动去定义匿名内部类的，而是别人需要我们写或者我们可以写的时候才会使用。\r\n匿名内部类的代码可以实现代码进一步的简化（回扣主题）\r\n\r\n类的四大金刚：\r\n    构造器，方法，属性，代码块\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n# 三、常用API\r\n\r\n- **API**\r\n\r\nAPI(Application Programming interface)  应用程序编程接口。\r\n简单来说：就是Java帮我们已经写好的一些方法，我们直接拿过来用就可以了\r\n\r\n\r\n\r\n## 1.0 **Object**\r\n\r\n一个类要么默认继承了Object类，要么间接继承了Object类，Object类是Java中的祖宗类\r\nObject类的方法是一切子类对象都可以直接使用的，所以我们要学习Object类的方法\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_13-44-29.png)\r\n\r\n---\r\n\r\n\r\n\r\n- **toString()**\r\n\r\nObject类中的toString方法，默认是返回一个字符串地址的\r\n但是，开发中直接输出对象，默认输出对象的地址其实是毫无意义的，开发中输出对象变量，更多的时候是希望看到对象的内容数据而不是对象的地址信息\r\n所以，toString存在的意义是为了被子类重写，以便返回对象的内容信息，而不是地址信息！！ \r\n\r\n\r\n\r\n~~~java\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{name=\'\" + name + \"\\\'\" +\r\n                \",dept=\'\" + depth + \"\\\'\" +\r\n                \",age=\" + age +\r\n                \",id=\'\" + id + \"\\\'}\";\r\n    }\r\n~~~\r\n\r\n~~~java\r\npublic static void main(String[] args) {\r\n        final Student student = new Student(\"张三\", \"调理农务系\", 18, \"1212121210\");\r\n//        System.out.println(student.toString());//本来需要这么写\r\n        System.out.println(student);//但是，是直接输出的话可以省略toString方法，他也会自动调用\r\n    }\r\n~~~\r\n\r\n~~~\r\n Student{name=\'张三\',dept=\'调理农务系\',age=18,id=\'1212121210\'}\r\n~~~\r\n\r\n\r\n\r\n- **equals()**\r\n\r\n1. Object的equals方法默认是比较两个对象地址是否相等，Object的equals方法和==是等价的，本质就是equals调用了==\r\n\r\n   ~~~java\r\n   public boolean equals(Object obj) {\r\n       return (this == obj);\r\n     }\r\n   ~~~\r\n\r\n   \r\n\r\n2. 父类equals方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则\r\n\r\n~~~java\r\n  @Override\r\n        public boolean equals(Object o) {\r\n            if (o instanceof Student) {\r\n                Student student = (Student) o;\r\n                return Objects.equals(this.name, student.getName()) &&\r\n                        Objects.equals(this.depth, student.getDepth()) && Objects.equals(this.id, student.getId()) &&\r\n                        this.age == student.getAge();\r\n            }\r\n            return false;\r\n        }\r\n\r\n\r\n   @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Student student = (Student) o;\r\n        return age == student.age && Objects.equals(name, student.name) && Objects.equals(depth, student.depth) && Objects.equals(id, student.id);\r\n    }\r\n~~~\r\n\r\n\r\n\r\n## 2.0 **Objects**\r\n\r\nObjects是一个工具类，提供了一些方法去完成一些功能，是Object的子类\r\n官方在进行字符串比较时，没有用字符串对象的的equals方法，而是选择了Objects的equals方法来比较\r\n使用Objects的equals方法在进行对象的比较会更安全\r\n\r\n\r\n\r\n~~~java\r\npublic static boolean equals(Object a, Object b) {\r\n        return (a == b) || (a != null && a.equals(b));\r\n}\r\n//首先看看是不是同一个对象，是直接返回真;否则看看调用者是否为null，若为null直接返回假，否则开始比较内容\r\n~~~\r\n\r\n\r\n\r\n## 3.0 **StringBuilder**\r\n\r\nStringBuilder是一个可变的字符串类，我们可以把它看成是一个对象容器。\r\n作用：提高字符串的操作效率，如拼接、修改等\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_14-44-51.png)\r\n\r\n---\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_14-45-09.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\npackage api_object;\r\n\r\n/**\r\n * ClassName: StringBuilderDemo\r\n * Description:\r\n * date:2022/3/10\r\n *\r\n * @author fgcy\r\n * @since JDK 1.8\r\n */\r\npublic class StringBuilderDemo {\r\n    public static void main(String[] args) {\r\n        final StringBuilder sb = new StringBuilder();\r\n        System.out.println(sb);//直接输出默认会调用该对象的toString方法 \"\"\r\n\r\n        sb.append(123).append(\'a\').append(true).append(12.3).append(\"时\");//支持链式编程\r\n        System.out.println(sb.toString());//直接输出默认会调用该对象的toString方法\r\n        \r\n		//将源对象的值反转，并返回一个带有反转后结果的StringBuilder对象\r\n        final StringBuilder reverse = sb.reverse();\r\n        System.out.println(reverse);\r\n\r\n        final String s = sb.toString();//将StringBuilder转为String\r\n        System.out.println(s);\r\n\r\n        System.out.println(sb.length());\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~\r\n123atrue12.3时\r\n时3.21eurta321\r\n时3.21eurta321\r\n13\r\n~~~\r\n\r\n\r\n\r\n### 3.1 String类拼接字符串原理图\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_15-03-54.png)\r\n\r\n---\r\n\r\n1. 首先将Test.class文件加载进方法区内存，并暴露访问静态方法的入口\r\n2. 将main方法提取到栈内存中运行\r\n3. 在栈内存中开辟一块存储String类型变量的空间，在字符串常量池中开辟一块空间存储字符“a”的实例把地址给到栈\r\n   3.在栈内存中开辟一块存储String类型变量的空间，在字符串常量池中开辟一块空间存储字符“b”的实例，然后在堆内存中创建一个StringBuilder的对象用于拼接字符串，然后将拼接好的StringBuilder对象转为String对象，再把地址给到栈中的变量\r\n4. 同理\r\n   .....\r\n   一个加号，堆内存中两对象\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_15-12-48.png)\r\n\r\n---\r\n\r\n1. 首先将Test.class文件加载进方法区内存，并暴露访问静态方法的入口\r\n2. 将main方法提取到栈内存中运行\r\n3. 在栈内存中创建一个StringBuilder类型的变量，在堆内存中创建一个StringBuilder对象，将对象的地址给到变量\r\n4. 在字符串常量池中创建一个对象，然后把字符串对象添加到StringBuilder对象中进行操作\r\n   ......\r\n\r\n\r\n\r\n- 总结\r\n\r\nString ：内容是不可变的、拼接字符串性能差。\r\nStringBuilder：内容是可变的、拼接字符串性能好、代码优雅。\r\n\r\n定义字符串使用String\r\n拼接、修改等操作字符串使用StringBuilder\r\n\r\n### 3.2 数组拼接输出\r\n\r\n~~~java\r\n public String concat(int[] arr) {\r\n        if (arr == null) return null;\r\n        final StringBuilder sb = new StringBuilder(\"[\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i == arr.length - 1 ? \"\" : \",\");\r\n        }\r\n        sb.append(\"]\");\r\n        return sb.toString();\r\n    }\r\n\r\n    @Test\r\n    public void test1() {\r\n        System.out.println(concat(null));\r\n        System.out.println(concat(new int[0]));\r\n        System.out.println(concat(new int[]{12, 55, 18, 34, 78, 145, 21}));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\nnull\r\n[]\r\n[12,55,18,34,78,145,21]\r\n~~~\r\n\r\n\r\n\r\n## 4.0 **Math**\r\n\r\n包含执行基本数字运算的方法，Math类没有提供公开的构造器。工具类一般都会私有构造器\r\n如何使用类中的成员呢？看类的成员是否都是静态的，如果是，通过类名就可以直接调用\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_15-30-26.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        System.out.println(Math.abs(-887));//887\r\n        System.out.println(Math.sqrt(9));//3\r\n        System.out.println(Math.max(12, 1 - 2));//12\r\n        final int i = (int) (Math.random() * 7) + 3;//3----9\r\n        System.out.println(i);\r\n        System.out.println(Math.pow(2, 10));//1024\r\n        System.out.println(Math.round(3.14));//3\r\n        System.out.println(Math.round(3.5));//4\r\n        System.out.println(Math.ceil(1.000001));//2\r\n        System.out.println(Math.ceil(1.0));//1\r\n        System.out.println(Math.floor(1.9999999999));//1\r\n        System.out.println(Math.floor(1.0));//1\r\n    }\r\n~~~\r\n\r\n\r\n\r\n## 5.0 System\r\n\r\nSystem也是一个工具类，代表了当前系统，提供了一些与系统相关的方法\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_15-50-24.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\npackage api_object;\r\n\r\nimport org.junit.Test;\r\n\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * ClassName: SystemDemo <br/>\r\n * Description: <br/>\r\n * date: 2022/3/10 15:51<br/>\r\n *\r\n * @author fgcy<br />\r\n * @since JDK 1.8\r\n */\r\npublic class SystemDemo {\r\n    @Test\r\n    public void test1() {\r\n\r\n        System.out.println(\"程序开始\");\r\n\r\n        final long start = System.currentTimeMillis();\r\n        int counter = 0;\r\n        for (int i = 0; i < 100000000; i++) {\r\n            counter++;\r\n        }\r\n        final long end = System.currentTimeMillis();\r\n        System.out.println(\"循环一亿次，耗时：\"+(end - start) / 1000.0);\r\n\r\n\r\n        final int[] ints1 = {12, 2, 1, 78, 45, 64, 55, 34};\r\n        final int[] ints2 = new int[5];\r\n        \r\n        System.arraycopy(ints1, 1, ints2, 2, 3);\r\n        System.out.println(Arrays.toString(ints2));\r\n        System.exit(0);//人为关掉JVM\r\n\r\n\r\n        System.out.println(\"程序结束\");\r\n\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n程序开始\r\n循环一亿次，耗时：0.002\r\n[0, 0, 2, 1, 78]   \r\n~~~\r\n\r\n\r\n\r\n1970年1月1日 算C语言的生日\r\n原因：\r\n       1969年8月，贝尔实验室的程序员肯汤普逊利用妻儿离开一个月的机会，开始着手创造一个全新的革命性的操作系统，他使用B编译语言在老旧的PDP-7机器上开发出了Unix的一个版本。\r\n         随后，汤普逊和同事丹尼斯里奇改进了B语言，开发出了C语言，重写了UNIX。\r\n\r\n计算机认为时间是有起点的，起始时间： 1970年1月1日  00:00:00\r\n\r\n时间毫秒值：指的是从1970年1月1日    00:00:00走到此刻的总的毫秒数，应该是很大的。 1s = 1000m s\r\n\r\n\r\n\r\n## 6.0 BigDecimal\r\n\r\n用于解决浮点型运算精度失真的问题\r\n\r\n- 失真问题\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        System.out.println(0.09 + 0.01);//0.09999999999999999\r\n        System.out.println(1.0 - 0.32);//0.6799999999999999\r\n        System.out.println(1.015 * 100);//101.49999999999999\r\n        System.out.println(1.301 / 100);//0.013009999999999999\r\n        System.out.println(\"-------------------------\");\r\n        double c = 0.1 + 0.2;//0.30000000000000004\r\n        System.out.println(c);\r\n    }\r\n~~~\r\n\r\n- 使用\r\n\r\n1. 创建对象BigDecimal封装浮点型数据（最好的方式是调用方法）\r\n   public static BigDecimal valueOf(double val):   包装浮点数成为BigDecimal对象。\r\n\r\n2. 通过BigDecimal类的构造器得到BigDecimal对象（比较麻烦，不推荐）\r\n   BigDecimal(String val)//Translates the string representation of a BigDecimal into a BigDecimal.\r\n3. 其他方法不推荐，存在精度问题\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_16-42-34.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        final BigDecimal a = new BigDecimal(\"0.1\");\r\n        final BigDecimal b = new BigDecimal(\"0.2\");\r\n        System.out.println(a.add(b));//0.3\r\n\r\n        final BigDecimal c = BigDecimal.valueOf(1.0);\r\n        final BigDecimal d = BigDecimal.valueOf(0.32);\r\n        System.out.println(c.subtract(d));//0.68\r\n\r\n        final BigDecimal e = BigDecimal.valueOf(1.015);\r\n        final BigDecimal f = BigDecimal.valueOf(100);\r\n        System.out.println(e.multiply(f));//101.500\r\n\r\n        final BigDecimal g = BigDecimal.valueOf(1.301);\r\n        System.out.println(g.divide(f));//0.01301\r\n\r\n    }\r\n~~~\r\n\r\n~~~java\r\n    @Test\r\n    public void test3(){\r\n        final BigDecimal a = new BigDecimal(\"10\");\r\n        final BigDecimal b = new BigDecimal(\"3\");\r\n        System.out.println(a.divide(b,2,BigDecimal.ROUND_UP));\r\n    }\r\n~~~\r\n\r\n参数1 :表示参与运算的BigDecimal 对象。\r\n    参数2 ，表示小数点后面精确到多少位\r\n    参数3 ，舍入模式\r\n    BigDecimal.ROUND_UP  进一法\r\n    BigDecimal.ROUND_FLOOR 去尾法\r\n    BigDecimal.ROUND_HALF_UP 四舍五入', 'https://picsum.photos/seed/aer777/800/450', '原创', 0, b'1', b'1', b'1', b'1', b'1', '2022-06-16 22:50:38', '2022-06-16 22:50:38', 1, 1, '面向对象的三大特征之多态、内部类、常用API', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (25, '常用API', '# 一、处理时间\r\n\r\n### 1.0 Date概念\r\n\r\nDate类代表当前所在系统的日期时间信息\r\n\r\n---\r\n\r\n\r\n\r\n### Date的构造器\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-13-54.png)\r\n\r\n---\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-14-20.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Date的常用方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-14-55.png)\r\n\r\n\r\n\r\n---\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-15-31.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: DateDemo\r\n     * Description:从现在开始向前走了一小时两分钟1秒\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    @Test\r\n    public void test1() {\r\n        final Date now = new Date();//通过无参构造获得当前日期对象\r\n        System.out.println(now);\r\n        final long nowTime = now.getTime();//将当前的日期对象转成时间毫秒值\r\n        //将当前的时间毫秒值加【一小时两分钟1秒】毫秒，将值注入到之前的日期对象中，此时日期对象的值已经改变\r\n        now.setTime(nowTime + (3600 + 121) * 1000);\r\n        System.out.println(now);\r\n    }\r\n~~~\r\n\r\n~~~\r\nThu Mar 10 18:00:42 CST 2022\r\nThu Mar 10 19:02:43 CST 2022\r\n~~~\r\n\r\n\r\n\r\n### 小结\r\n\r\n日期对象如何创建，如何获取时间毫秒值？\r\n\r\n~~~java\r\n    public  Date();//获得一个当前时间的日期对象\r\n\r\n​    public long getTime();//获得当前日期对象的时间毫秒值\r\n\r\n​    public Date(long time);//获得一个指定时间毫秒值时间的日期对象\r\n~~~\r\n\r\n时间毫秒值怎么恢复成日期对象\r\n\r\n\r\n\r\n~~~java\r\n    public Date(long time);//构造器，根据时间毫秒值获得一个日期对象\r\n\r\n​    public void setTime(long time);//通过当前对象设置时间毫秒值，改变日期对象\r\n~~~\r\n\r\n\r\n\r\n### 2.0 SimpleDateFormat\r\n\r\n### 构造器\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-44-19.png)\r\n\r\n---\r\n\r\n\r\n\r\n### 格式化方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-44-40.png)\r\n\r\n---\r\n\r\n\r\n\r\n### 解析方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-46-39.png)\r\n\r\n---\r\n\r\n\r\n\r\n### 格式化字符\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_17-46-06.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() throws Exception{\r\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH点mm分ss秒 EEE a\");\r\n        final Date date = sdf.parse(\"2021年08月06日 11点11分11秒 星期五 上午\");\r\n        System.out.println(sdf.format(date));\r\n        final long targetTime = date.getTime() + (3600L * 24 * 2 + 14 * 3600 + 49 * 60 + 6) * 1000;\r\n        date.setTime(targetTime);\r\n        System.out.println(sdf.format(date));\r\n    }\r\n~~~\r\n\r\n~~~\r\n2021年08月06日 11点11分11秒 星期五 上午\r\n2021年08月09日 02点00分17秒 星期一 上午\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 案例 秒杀活动\r\n\r\n~~~java\r\n@Test\r\n    public void test3() throws Exception {\r\n        String begin = \"2020年11月11日 0:00:00\";\r\n        String end = \"2020年11月11日 0:10:00\";\r\n        String jia = \"2020年11月11日 0:03:47\";\r\n        String pi = \"2020年11月11日 0:10:11\";\r\n\r\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 H:mm:ss\");\r\n        final Date begins = sdf.parse(begin);\r\n        final Date ends = sdf.parse(end);\r\n        final Date jias = sdf.parse(jia);\r\n        final Date pis = sdf.parse(pi);\r\n        if (pis.after(begins) && pis.before(ends)) {\r\n            System.out.println(\"小皮秒杀成功\");\r\n        } else {\r\n            System.out.println(\"小皮秒杀失败\");\r\n        }\r\n\r\n        if (jias.after(begins) && jias.before(ends)) {\r\n            System.out.println(\"小甲秒杀成功\");\r\n        } else {\r\n\r\n            System.out.println(\"小甲秒杀失败\");\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n小皮秒杀失败\r\n小甲秒杀成功\r\n~~~\r\n\r\n\r\n\r\n# 二、Calendar\r\n\r\n### 概述\r\n\r\nCalendar代表了系统此刻日期对应的日历对象。日期类有年月日时分秒星期等；日历的范围更广；\r\n\r\nCalendar是一个抽象类，不能直接创建对象。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 常用方法\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_20-19-06.png)\r\n\r\n----\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_20-19-27.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~JAVA\r\n    @Test\r\n    public void test1() {\r\n        final Calendar cal = Calendar.getInstance();//该类是抽象类，getInstance是通过调用该类的子类来获取实例\r\n        System.out.println(cal);\r\n        System.out.println(cal.get(Calendar.YEAR) + \"年\");\r\n        System.out.println(cal.get(Calendar.MONTH) + 1 + \"月\");\r\n        System.out.println(\"今年第\" + cal.get(Calendar.WEEK_OF_YEAR) + \"周\");\r\n        System.out.println(\"本月第\" + cal.get(Calendar.WEEK_OF_MONTH) + \"周\");\r\n        System.out.println(cal.get(Calendar.DAY_OF_MONTH) + \"日\");\r\n        System.out.println(\"今年第\" + cal.get(Calendar.DAY_OF_YEAR) + \"天\");\r\n        System.out.println(\"本周第\" + cal.get(Calendar.DAY_OF_WEEK) + \"天\");\r\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY) + \"点\");\r\n        System.out.println(cal.get(Calendar.MINUTE) + \"分\");\r\n        System.out.println(cal.get(Calendar.SECOND) + \"秒\");\r\n    }\r\n~~~\r\n\r\n~~~\r\n java.util.GregorianCalendar[time=1646915482381,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=2,WEEK_OF_YEAR=11,WEEK_OF_MONTH=2,DAY_OF_MONTH=10,DAY_OF_YEAR=69,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=31,SECOND=22,MILLISECOND=381,ZONE_OFFSET=28800000,DST_OFFSET=0]\r\n2022年\r\n3月\r\n今年第11周\r\n本月第2周\r\n10日\r\n今年第69天\r\n本周第5天\r\n20点\r\n31分\r\n22秒\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        final Calendar cal = Calendar.getInstance();//获取一个日历对象\r\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY));//获取日历对象中本月第几天\r\n        cal.add(Calendar.HOUR_OF_DAY, 3);//将日历对象中的小时数加三\r\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY));//\r\n        cal.set(Calendar.HOUR_OF_DAY, 0);//将日历对象中的小时数设置为零\r\n        System.out.println(cal.get(Calendar.HOUR_OF_DAY));\r\n        final Date date = cal.getTime();//根据该日历对象信息获取日期对象\r\n        System.out.println(date);\r\n        final long timeInMillis = cal.getTimeInMillis();//根据日历信息获取时间毫秒值\r\n        System.out.println(timeInMillis);\r\n    }\r\n~~~\r\n\r\n~~~\r\n20\r\n23\r\n0\r\nThu Mar 10 00:37:30 CST 2022\r\n1646843850105\r\n//注意：calendar是可变日期对象，一旦修改后其对象本身表示的时间将产生变化。\r\n~~~\r\n\r\n\r\n\r\n# 三、JDK8新增日期类\r\n\r\n1. 从Java 8开始，java.time包提供了新的日期和时间API\r\n\r\n\r\n\r\n1. 新增的API严格区分了时刻、本地日期、本地时间，并且，对日期和时间进行运算更加方便\r\n\r\n\r\n\r\n1. 新API的类型几乎全部是不变类型（和String的使用类似），可以放心使用不必担心被修改。\r\n\r\n\r\n\r\n### jdk新增的七个处理日期类\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_21-10-52.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n### **LocalDate、LocalTime、LocalDateTime**\r\n\r\n​				他们 分别表示日期，时间，日期时间对象，他们的类的实例是不可变的对象\r\n\r\n​				他们三者构建对象和API都是通用的\r\n\r\n\r\n\r\n### 通用获取对象方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_21-12-58.png)\r\n\r\n---\r\n\r\n\r\n\r\n### LocalDate, LocalTime, LocalDateTime获取信息的API.\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_21-14-06.png)\r\n\r\n---\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_21-45-44.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n/**\r\n     * ClassName: NewDemo\r\n     * Description:LocalDate\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    \r\n    @Test\r\n    public void test1() {\r\n        final LocalDate localDate = LocalDate.now();\r\n        System.out.println(localDate);\r\n        System.out.println(localDate.getYear() + \"年\");\r\n        System.out.println(localDate.getMonth());//MARCH\r\n        System.out.println(localDate.getMonthValue() + \"月\");\r\n        System.out.println(localDate.getDayOfMonth() + \"日\");\r\n        System.out.println(\"今年第\" + localDate.getDayOfYear() + \"天\");\r\n        System.out.println(localDate.getDayOfWeek());//THURSDAY\r\n        System.out.println(\"----------------\");\r\n        final LocalDate localDate1 = LocalDate.of(2023, 11, 11);\r\n        System.out.println(localDate1);\r\n        final LocalDate localDate2 = LocalDate.of(2023, Month.NOVEMBER, 11);//枚举\r\n        System.out.println(localDate2);\r\n    }\r\n~~~\r\n\r\n~~~\r\n2022-03-10\r\n2022年\r\nMARCH\r\n3月\r\n10日\r\n今年第69天\r\nTHURSDAY\r\n---------------\r\n2023-11-11\r\n2023-11-11\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: NewDemo\r\n     * Description:localTime\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test2() {\r\n        final LocalTime localTime = LocalTime.now();\r\n        System.out.println(localTime);\r\n        System.out.println(localTime.getHour() + \"时\");\r\n        System.out.println(localTime.getMinute() + \"分\");\r\n        System.out.println(localTime.getSecond() + \"秒\");\r\n        System.out.println(localTime.getNano() + \"纳秒\");\r\n        System.out.println(\"---------------------\");\r\n        final LocalTime of = LocalTime.of(21, 21, 21, 21);\r\n        System.out.println(of);\r\n        System.out.println(LocalTime.of(21, 12));\r\n        System.out.println(LocalTime.of(21, 21, 21));\r\n    }\r\n~~~\r\n\r\n~~~\r\n21:51:08.416\r\n21时\r\n51分\r\n8秒\r\n416000000纳秒\r\n-----------------\r\n21:21:21.000000021\r\n21:12\r\n21:21:21\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n     * ClassName: NewDemo\r\n     * Description:LocalDateTime\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test3() {\r\n        final LocalDateTime localDateTime = LocalDateTime.now();\r\n        System.out.println(localDateTime);\r\n        System.out.println(localDateTime.getYear() + \"年\");\r\n        System.out.println(localDateTime.getMonthValue() + \"月\");\r\n        System.out.println(localDateTime.getDayOfMonth() + \"日\");\r\n        System.out.println(localDateTime.getDayOfWeek());\r\n        System.out.println(\"今年第\" + localDateTime.getDayOfYear() + \"天\");\r\n        System.out.println(localDateTime.getHour() + \"时\");\r\n        System.out.println(localDateTime.getMinute() + \"分\");\r\n        System.out.println(localDateTime.getSecond() + \"秒\");\r\n        System.out.println(localDateTime.getNano() + \"纳秒\");\r\n        System.out.println(\"--------------------------\");\r\n        final LocalDate localDate = localDateTime.toLocalDate();\r\n        System.out.println(localDate);\r\n\r\n        final LocalTime localTime = localDateTime.toLocalTime();\r\n        System.out.println(localTime);\r\n\r\n        System.out.println(\"------------------------\");\r\n        final LocalDateTime of = LocalDateTime.of(2021, 11, 11, 11, 11, 11);\r\n        System.out.println(of);\r\n    }\r\n~~~\r\n\r\n~~~\r\n2022-03-10T21:54:29.027\r\n2022年\r\n3月\r\n10日\r\nTHURSDAY\r\n今年第69天\r\n21时\r\n54分\r\n29秒\r\n27000000纳秒\r\n-------------------\r\n2022-03-10\r\n21:54:29.027\r\n--------------------\r\n2021-11-11T11:11:11\r\n~~~\r\n\r\n\r\n\r\n### 修改相关的API\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-10_22-00-14.png)\r\n\r\n---\r\n\r\n\r\n\r\n修改相关的API\r\n    LocalDateTime 综合了 LocalDate 和 LocalTime 里面的方法，所以只用 LocalDate 和 LocalTime 来举例。\r\n    这些方法返回的是一个新的实例引用，因为LocalDateTime 、LocalDate 、LocalTime 都是不可变的。 \r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: NewDemo\r\n     * 日期时间比较操作\r\n     * Description:\r\n     * date:2022/3/10\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    @Test\r\n    public void test4() {\r\n        final LocalTime localTime = LocalTime.now();\r\n        System.out.println(localTime);\r\n        System.out.println(localTime.minusHours(1));\r\n        System.out.println(localTime.minusMinutes(1));\r\n        System.out.println(localTime.minusSeconds(1));\r\n        System.out.println(localTime.minusNanos(1));\r\n        System.out.println(\"---------------------\");\r\n        System.out.println(localTime.plusHours(1));\r\n        System.out.println(localTime.plusMinutes(1));\r\n        System.out.println(localTime.plusSeconds(1));\r\n        System.out.println(localTime.plusNanos(1));\r\n        System.out.println(localTime);\r\n        System.out.println(\"---------------------\");\r\n        final LocalDate of = LocalDate.of(2023, 11, 5);\r\n        final LocalDate now = LocalDate.now();\r\n        System.out.println(\"今天是2023-11-5吗？\" + of.equals(now));\r\n        System.out.println(\"今天在2023-11-5之前？\" + now.isBefore(of));\r\n        System.out.println(\"今天在2023-11-5之后？\" + now.isAfter(of));\r\n        System.out.println(\"---------------------\");\r\n        final LocalDate birthDate = LocalDate.of(2021, 3, 10);\r\n        final MonthDay birthMonthDay = MonthDay.of(birthDate.getMonthValue(), birthDate.getDayOfMonth());//通过月日的数值获取月日对象\r\n        final MonthDay nowMonthDay = MonthDay.from(now);//通过LocalDate对象获得月日对象\r\n        System.out.println(\"今天是你的生日吗？\" + birthMonthDay.equals(nowMonthDay));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n23:02:54.866\r\n22:02:54.866\r\n23:01:54.866\r\n23:02:53.866\r\n23:02:54.865999999\r\n---------------------\r\n00:02:54.866\r\n23:03:54.866\r\n23:02:55.866\r\n23:02:54.866000001\r\n23:02:54.866\r\n---------------------\r\n今天是2023-11-5吗？false\r\n今天在2023-11-5之前？true\r\n今天在2023-11-5之后？false\r\n---------------------\r\n今天是你的生日吗？true\r\n~~~\r\n\r\n\r\n\r\n### **Instant时间戳**\r\n\r\nJDK8获取时间戳特别简单，且功能更丰富。Instant类由一个静态的工厂方法now()可以返回当前时间戳\r\n时间戳是包含日期和时间的，与java.util.Date很类似，事实上Instant就是类似JDK8 以前的Date。\r\nInstant和Date这两个类可以进行转换;Date.from(instant); date.toInstant();\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final Instant instant = Instant.now();\r\n        System.out.println(instant);//重写了toString方法，输出默认世界时间\r\n        System.out.println(instant.atZone(ZoneId.systemDefault()));//改为系统默认时区，输出上海时间(返回值类型：ZonedDateTime)\r\n        System.out.println(Instant.ofEpochMilli(System.currentTimeMillis()));//根据时间毫秒值获取Instant对象\r\n\r\n        final Date date = Date.from(instant);//将Instant对象转为Date对象\r\n        System.out.println(date);\r\n        final Instant toInstant = date.toInstant();//将Date对象转为Instant对象\r\n        System.out.println(toInstant);\r\n    }\r\n~~~\r\n\r\n~~~\r\n2022-03-10T15:22:37.686Z\r\n2022-03-10T23:22:37.686+08:00[Asia/Shanghai]\r\n2022-03-10T15:22:37.728Z\r\nThu Mar 10 23:22:37 CST 2022\r\n2022-03-10T15:22:37.686Z\r\n~~~\r\n\r\n\r\n\r\n### **DateTimeFormatter**\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        final DateTimeFormatter ofPattern = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss EEE a\");\r\n        final LocalDateTime localDateTime = LocalDateTime.now();\r\n        final String format = ofPattern.format(localDateTime);//正向\r\n        System.out.println(format);\r\n        System.out.println(localDateTime.format(ofPattern));//反向\r\n\r\n        final LocalDateTime localDateTime1 = LocalDateTime.parse(\"2022-03-10 23:35:12 星期四 下午\", ofPattern);\r\n        System.out.println(\"今天是今年的第\" + localDateTime1.getDayOfYear() + \"天\");\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n2022-03-10 23:36:31 星期四 下午\r\n2022-03-10 23:36:31 星期四 下午\r\n今天是今年的第69天\r\n~~~\r\n\r\n\r\n\r\n### **Period**\r\n\r\n1. 在Java8中，我们可以使用以下类来计算日期间隔差异：java.time.Period\r\n2. 主要是 Period 类方法 getYears()，getMonths() 和 getDays() 来计算,只能精确到年月日。\r\n3. 用于 LocalDate 之间的比较\r\n\r\n~~~java\r\n    @Test\r\n    public void test3() {\r\n        final LocalDate now = LocalDate.now();\r\n        final LocalDate birthday = LocalDate.of(2000, 3, 2);\r\n        final Period period = Period.between(birthday, now);//前小后大\r\n        //模板字符串 类C printf()\r\n        System.out.printf(\"到目前为止，你已经活了%d年零%d个月零%d天\", period.getYears(), period.getMonths(), period.getDays());\r\n    }\r\n~~~\r\n\r\n~~~\r\n    到目前为止，你已经活了22年零0个月零8天\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### **Duration**\r\n\r\n1. 在Java8中，我们可以使用以下类来计算时间间隔差异：java.time.Duration\r\n2. 提供了使用基于时间的值测量时间量的方法。\r\n3. 用于 LocalDateTime 之间的比较。也可用于 Instant 之间的比较\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test4() {\r\n        final LocalDateTime localDateTime = LocalDateTime.now();\r\n        final LocalDateTime birthDateTime = LocalDateTime.of(2000, 3, 2, 14, 0, 0);\r\n        final Duration duration = Duration.between(birthDateTime, localDateTime);\r\n        System.out.printf(\"你到目前为止已经活了%d天即%d分钟即%d毫秒\", duration.toDays(), duration.toMinutes(), duration.toMillis());\r\n    }\r\n \r\n~~~\r\n\r\n~~~\r\n   你到目前为止已经活了8043天即11582522分钟即694951364440毫秒\r\n~~~\r\n\r\n注意：\r\n\r\n1、 Duration:  用于计算两个“时间”间隔。 \r\n2、 Period:      用于计算两个“日期”间隔\r\n\r\n\r\n\r\n### **ChronoUnit**\r\n\r\nChronoUnit类可用于在单个时间单位内测量一段时间，这个工具类是最全的了，可以用于比较所有的时间单位\r\njava.time.temporal.ChronoUnit\r\n\r\n\r\n\r\n~~~java\r\n  @Test\r\n    public void test5() {\r\n        final LocalDateTime today = LocalDateTime.now();\r\n        final LocalDateTime birthDate = LocalDateTime.of(2000, 3, 2, 14, 0, 0);\r\n        System.out.println(\"相差的年数：\" + ChronoUnit.YEARS.between(birthDate, today));\r\n        System.out.println(\"相差的月数：\" + ChronoUnit.MONTHS.between(birthDate, today));\r\n        System.out.println(\"相差的周数：\" + ChronoUnit.WEEKS.between(birthDate, today));\r\n        System.out.println(\"相差的天数：\" + ChronoUnit.DAYS.between(birthDate, today));\r\n        System.out.println(\"相差的时数：\" + ChronoUnit.HOURS.between(birthDate, today));\r\n        System.out.println(\"相差的分数：\" + ChronoUnit.MINUTES.between(birthDate, today));\r\n        System.out.println(\"相差的秒数：\" + ChronoUnit.SECONDS.between(birthDate, today));\r\n        System.out.println(\"相差的毫秒数：\" + ChronoUnit.MILLIS.between(birthDate, today));\r\n        System.out.println(\"相差的微秒数：\" + ChronoUnit.MICROS.between(birthDate, today));\r\n        System.out.println(\"相差的纳秒数：\" + ChronoUnit.NANOS.between(birthDate, today));\r\n        System.out.println(\"相差的半天数：\" + ChronoUnit.HALF_DAYS.between(birthDate, today));\r\n        System.out.println(\"相差的十年数：\" + ChronoUnit.DECADES.between(birthDate, today));\r\n        System.out.println(\"相差的世纪（百年）数：\" + ChronoUnit.CENTURIES.between(birthDate, today));\r\n        System.out.println(\"相差的千年数：\" + ChronoUnit.MILLENNIA.between(birthDate, today));\r\n        System.out.println(\"相差的纪元数：\" + ChronoUnit.ERAS.between(birthDate, today));\r\n    }\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 四、包装类\r\n\r\n### 	概念\r\n\r\n​			就是8种基本数据类型对应的引用类型。\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_09-17-34.png)\r\n\r\n---\r\n\r\n\r\n\r\n### 特点\r\n\r\n​		1.Java**为了实现一切皆对象**，为8种基本类型提供了对应的引用类型。\r\n​		2.后面的**集合和泛型其实也只能支持包装类型**，不支持基本数据类型.\r\n​		3.**自动拆箱**：包装类型的变量可以直接赋值给基本数据类型的变量\r\n​		4.**自动装箱**：基本类型的数据和变量可以直接赋值给包装类型的变量\r\n\r\n\r\n\r\n\r\n\r\n### 独有功能\r\n\r\n1.包装类的变量的**默认值可以是null**，**容错率更高**\r\n\r\n2.可以把基本类型的数据转换成字符串类型(用处不大)\r\n    调用toString()方法得到字符串结果。\r\n    调用Integer.toString(基本类型的数据)\r\n\r\n3.可以**把字符串类型的数值转换成真实的数据类型**（真的很有用）\r\n    Integer.parseInt(“字符串类型的整数”)\r\n    Double.parseDouble(“字符串类型的小数”)\r\n    Integer.valueOf(\"字符串类型的整数\")\r\n    Double.valueOf(\"字符串类型的小数\")\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: WrapDemo\r\n     * Description:z自动装箱，拆箱\r\n     * date:2022/3/11\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test1() {\r\n        Integer a = 1;\r\n        int b = a;//自动拆箱\r\n        System.out.println(b);\r\n        System.out.println(\"----------------\");\r\n        int c = 2;\r\n        Integer d = c;//自动装箱\r\n        System.out.println(d);\r\n    }\r\n~~~\r\n\r\n~~~\r\n1\r\n----------------\r\n2\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n		//int a=null;基本数据类型不能为null\r\n        Integer b = null;//包装类时对象可以为null\r\n        Integer integer = 12;\r\n        System.out.println(integer.toString() + 1);//数字转字符串1\r\n        System.out.println(Integer.toString(integer) + 1);//数字转字符串2\r\n        System.out.println(integer + \"\" + 1);//数字转字符串3\r\n        System.out.println(\"-----------------------\");\r\n        System.out.println(Integer.parseInt(\"123\") + 1);//字符串转数字1\r\n        System.out.println(Integer.valueOf(\"123\") + 1);//字符串转数字2\r\n        System.out.println(Double.valueOf(\"3.14\") + 0.01);//字符串转小数1\r\n        System.out.println(Double.parseDouble(\"3.14\") + 0.01);//字符串转小数2\r\n    }\r\n~~~\r\n\r\n~~~\r\n121\r\n121\r\n121\r\n-----------------------\r\n124\r\n124\r\n3.15\r\n3.15\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 总结\r\n\r\n1、包装类是什么，作用是什么？\r\n    基本数据类型对应的引用类型，实现了一切皆对象。\r\n    后期集合和泛型不支持基本类型，只能使用包装类。\r\n\r\n2、包装类有哪些特殊功能？\r\n    可以把基本类型的数据转换成字符串类型(用处不大)\r\n    **可以把字符串类型的数值转换成真实的数据类型**（真的很有用）\r\n\r\n\r\n\r\n注意：(String)  String.valueOf()    toString区别\r\n\r\n\r\n\r\n\r\n\r\n## 五、正则表达式\r\n\r\n### 概念\r\n\r\n正则表达式可以用一些规定的字符来制定规则，并用来校验数据格式的合法性\r\n\r\n**匹配字符的规则**\r\n\r\n\r\n\r\n\r\n\r\n### 使用详解\r\n\r\n**字符串对象提供了匹配正则表达式的方法**\r\n\r\n~~~jaVA\r\n  public boolean matches(String regex)\r\n~~~\r\n\r\n  判断是否匹配正则表达式，匹配返回true，不匹配返回false\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_09-55-10.png)\r\n\r\n---\r\n\r\n\r\n\r\n### **案例**\r\n\r\n~~~java\r\n    private static void checkMail() {\r\n        final Scanner sc = new Scanner(System.in);\r\n        while (true) {\r\n            System.out.print(\"请输入邮箱号:\");\r\n            final String mail = sc.nextLine();\r\n            //zwj1061499050@126.com\r\n            if (mail.matches(\"\\\\w{1,20}@[a-zA-Z0-9]{2,4}(\\\\.[a-z]{2,3}){1,2}\")) {\r\n                System.out.println(\"邮箱验证成功！\");\r\n                break;\r\n            } else {\r\n                System.out.println(\"邮箱格式有误\");\r\n            }\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n请输入邮箱号:@qq.com\r\n邮箱格式有误\r\n请输入邮箱号:132.fffd@fff.co\r\n邮箱格式有误\r\n请输入邮箱号:zwj1061499050@126.com.cn\r\n邮箱验证成功！\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n        private static void checkPhone() {\r\n        final Scanner sc = new Scanner(System.in);\r\n        while (true) {\r\n            System.out.print(\"请输入手机号:\");\r\n            final String phone = sc.nextLine();\r\n            if (phone.matches(\"1[3-9]\\\\d{9}\")) {\r\n                System.out.println(\"手机验证成功！\");\r\n                break;\r\n            } else {\r\n                System.out.println(\"手机格式有误\");\r\n            }\r\n        }\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n请输入手机号:123456789111\r\n手机格式有误\r\n请输入手机号:12345678911\r\n手机格式有误\r\n请输入手机号:aaaaaaaaaaa\r\n手机格式有误\r\n请输入手机号:17665661294\r\n手机验证成功！\r\n~~~\r\n\r\n\r\n\r\n### **正则表达式在字符串中的使用**\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_11-16-18.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final String data = \"闪避908_呼叫544ffff你爸妈14jkl吧那\";\r\n        final String[] strings = data.split(\"\\\\w+\");\r\n        for (String string : strings) {\r\n            System.out.println(string);\r\n        }\r\n        final String s = data.replaceAll(\"\\\\w+\", \",\");\r\n        System.out.println(s);\r\n    }\r\n~~~\r\n\r\n~~~\r\n闪避\r\n呼叫\r\n你爸妈\r\n吧那\r\n闪避,呼叫,你爸妈,吧那\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### **正则表达式爬取信息**\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        final String data = \"来黑马程序学习Java,电话020-43422424，或者联系邮箱\" +\r\n                \"itcast@itcast.cn,电话18762832633，0203232323\" +\r\n                \"邮箱bozai@itcast.cn，400-100-3233 ，4001003232\";\r\n\r\n        final Pattern pattern = Pattern.compile(\"(\\\\w{1,20}@[a-zA-Z0-9]{2,10}(\\\\.[a-z]{2,3}){1,2})|\" +\r\n                \"(1[3-9]\\\\d{9})|\" +\r\n                \"(0\\\\d{2,5}-?\\\\d{5,15})|(400-?\\\\d{3,8}-?\\\\d{3,8})\");\r\n\r\n        final Matcher matcher = pattern.matcher(data);\r\n        while (matcher.find()){\r\n            System.out.println(matcher.group());\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n020-43422424\r\nitcast@itcast.cn\r\n18762832633\r\n0203232323\r\nbozai@itcast.cn\r\n400-100-3233\r\n4001003232\r\n~~~\r\n\r\n\r\n\r\n## 操作数组元素\r\n\r\n### Arrays概念\r\n\r\n数组操作工具类，专门用于操作数组元素的\r\n\r\n\r\n\r\n\r\n\r\n### Arrays类的常用api\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_13-11-39.png)\r\n\r\n----\r\n\r\n\r\n\r\n\r\n\r\n### Arrays类常用功能演示\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final double[] doubles = {1.0, 42.5, 5, 4.21, 55, 17.5, 11.33};\r\n        System.out.println(Arrays.toString(doubles));//将数组转为字符串\r\n        Arrays.sort(doubles);//默认升序排序\r\n        System.out.println(doubles);\r\n        System.out.println(Arrays.toString(doubles));\r\n        //二分排序，前提有序，找到返回索引，找不到返回它应该插入的位置+1，然后总体取负数\r\n        System.out.println(Arrays.binarySearch(doubles, 12));\r\n        final int[] ints = {12, 44, 5, 32, 84, -4, 122};\r\n        //如果二分查找前，数组并没有排好序，也不会报错，就是结果不准确\r\n        System.out.println(Arrays.binarySearch(ints, 44));//应该时1，结果是-7\r\n    }\r\n~~~\r\n\r\n~~~\r\n[1.0, 42.5, 5.0, 4.21, 55.0, 17.5, 11.33]\r\n[D@3d82c5f3\r\n[1.0, 4.21, 5.0, 11.33, 17.5, 42.5, 55.0]\r\n-5\r\n-7\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Arrays类的排序\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_14-02-09.png)\r\n\r\n----\r\n\r\n自定义排序规则\r\n    设置Comparator接口对应的比较器对象，来定制比较规则\r\n    如果认为左边数据 大于 右边数据 返回正整数\r\n    如果认为左边数据 小于 右边数据  返回负整数\r\n    如果认为左边数据  等于 右边数据  返回0\r\n	**(o1-o2)升序排序，(o2-o1)降序排序**\r\n\r\n~~~java\r\n     @Test\r\n    public void test2() {\r\n        final Integer[] ints = {12, 55, 3, -7, 54, 34, 91, 4};\r\n	/*        \r\n			Arrays.sort(ints, new Comparator<Integer>() {\r\n            @Override\r\n            public int compare(Integer o1, Integer o2) {\r\n                return o2 - o1;\r\n            }\r\n        });\r\n     */\r\n        Arrays.sort(ints, (o1, o2) -> o2 - o1);\r\n        System.out.println(Arrays.toString(ints));\r\n\r\n    \r\n~~~\r\n\r\n~~~\r\n[91, 55, 54, 34, 12, 4, 3, -7]\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n    class Student {\r\n        private String name;\r\n        private double height;\r\n        private int age;\r\n\r\n\r\n        public Student() {\r\n        }\r\n\r\n        public Student(String name, double height, int age) {\r\n            this.name = name;\r\n            this.height = height;\r\n            this.age = age;\r\n        }\r\n\r\n    }\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test4() {\r\n        final Student[] students = new Student[3];\r\n        students[0] = new Student(\"张三\", 177, 15);\r\n        students[1] = new Student(\"未晓\", 175, 18);\r\n        students[2] = new Student(\"初沐\", 165, 20);\r\n        Arrays.sort(students, (o1, o2) -> o2.getAge() - o1.getAge());\r\n        System.out.println(Arrays.toString(students));\r\n    }\r\n~~~\r\n\r\n\r\n\r\n~~~\r\n[Student{name=\'初沐\', height=165.0, age=20}, \r\n Student{name=\'未晓\', height=175.0, age=18},\r\n Student{name=\'张三\', height=177.0, age=15}]\r\n~~~\r\n\r\n\r\n\r\n## 常见算法\r\n\r\n### 冒泡排序\r\n\r\n冒泡排序的思想\r\n	每次从数组中找出最大值放在数组的后面去\r\n	\r\n实现步骤：\r\n    确定总共需要做几轮： 数组的长度-1.\r\n    每轮比较几次\r\n    当前位置大于后一个位置则交换数据\r\n\r\n~~~java\r\n    /*\r\n     * 0 1 2 3\r\n     * 0   012\r\n     * 1   01\r\n     * 2   0\r\n     *\r\n     * 一共有四个数，经过每轮比较得到一个最大或最小的数；一共需要比较4-1次\r\n     * 每次比较都要确保除了已经比较完的最值外，其他所有数都要比较一次\r\n     * */\r\n    public void bubbleSorted(int[] arr) {\r\n        if (arr == null) {\r\n            System.out.println(\"null\");\r\n            return;\r\n        }\r\n        if (arr.length <= 0) {\r\n            System.out.println(\"空数组\");\r\n            return;\r\n        }\r\n        for (int i = 0; i < arr.length - 1; i++) {\r\n            for (int j = 0; j < arr.length - i - 1; j++) {\r\n                if (arr[j] > arr[j + 1]) {\r\n                    int temp = arr[j];\r\n                    arr[j] = arr[j + 1];\r\n                    arr[j + 1] = temp;\r\n                }\r\n            }\r\n        }\r\n        System.out.println(Arrays.toString(arr));\r\n    }\r\n\r\n\r\n    @Test\r\n    public void test1() {\r\n        final int[] ints = {12, 21, 43, 6, 94, -4, 0, 33};\r\n        bubbleSorted(ints);\r\n        bubbleSorted(null);\r\n        bubbleSorted(new int[0]);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[-4, 0, 6, 12, 21, 33, 43, 94]\r\nnull\r\n空数组\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 选择排序\r\n\r\n选择排序的思想\r\n    每轮选择当前位置，开始找出后面的较小值与该位置交换\r\n实现步骤：\r\n    确定总共需要选择几轮： 数组的长度-1.\r\n    控制每轮从以前位置为基准，与后面元素选择几次\r\n\r\n~~~java\r\n    /*\r\n     *\r\n     * 0 1 2 3 4\r\n     *\r\n     *\r\n     * 0 1234\r\n     * 1 234\r\n     * 2 34\r\n     * 3 4\r\n     * */\r\n    public void selectSorted(int[] arr) {\r\n        if (arr == null) {\r\n            System.out.println(\"null\");\r\n            return;\r\n        }\r\n        if (arr.length <= 0) {\r\n            System.out.println(\"空数组\");\r\n            return;\r\n        }\r\n        for (int i = 0; i < arr.length - 1; i++) {\r\n            for (int j = i + 1; j < arr.length; j++) {\r\n                if (arr[i] > arr[j]) {\r\n                    int temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }\r\n        System.out.println(Arrays.toString(arr));\r\n    }\r\n\r\n\r\n    @Test\r\n    public void test1() {\r\n        final int[] ints = {12, 21, 43, 6, 94, -4, 0, 33};\r\n        selectSorted(ints);\r\n        selectSorted(null);\r\n        selectSorted(new int[0]);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[-4, 0, 6, 12, 21, 33, 43, 94]\r\nnull\r\n空数组\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 二分查找\r\n\r\n1.在数据量特别大的时候，基本查找从前往后寻找的性能是很差的\r\n2.二分查询性能好，二分查找的前提是必须是排好序的数据\r\n3.二分查找相当于每次去掉一半的查找范围\r\n\r\n\r\n\r\n\r\n\r\n### 二分查找实现步骤\r\n\r\n定义变量记录左边和右边位置。\r\n使用while循环控制查询（条件是左边位置<=右边位置）\r\n循环内部获取中间元素索引\r\n判断当前要找的元素如果大于中间元素，左边位置=中间索引+1\r\n判断当前要找的元素如果小于中间元素，右边位置=中间索引-1\r\n判断当前要找的元素如果等于中间元素，返回当前中间元素索引。\r\n\r\n~~~java\r\n    @Test\r\n    public void test5() {\r\n        final int[] ints = {11, 13, 23, 27, 34, 65, 88};\r\n        System.out.println(binarySearch(ints, 27));\r\n    }\r\n\r\n    public int binarySearch(int[] arr, int target) {\r\n        if (arr == null || arr.length <= 0) {\r\n            return -1;\r\n        }\r\n        int left = 0;\r\n        int right = arr.length - 1;\r\n        while (left <= right) {\r\n            int mid = (left + right) / 2;\r\n            if (target > arr[mid]) {\r\n                left = mid + 1;\r\n            } else if (target < arr[mid]) {\r\n                right = mid - 1;\r\n            } else {\r\n                return mid;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n3\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## Lambda表达式\r\n\r\n### Lambda表达式的概述\r\n\r\n​	Lambda表达式是JDK 8开始后的一种新语法形式\r\n\r\n​	作用：**简化匿名内部类的代码写法**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### **Lambda**表达式的简化格式\r\n\r\n~~~\r\n(匿名内部类被重写方法的形参列表) -> {\r\n    被重写方法的方法体代码。\r\n}\r\n~~~\r\n\r\n注：-> 是语法形式，无实际含义\r\n\r\n注意：Lambda表达式**只能简化函数式接口的匿名内部类**的写法形式\r\n\r\n什么是函数式接口\r\n	首先必须是接口、其次**接口中有且仅有一个抽象方法**的形式\r\n	\r\n代码更少，关注点更加明确了\r\n\r\n注意：通常我们见到的函数式接口上都有一个**@FunctionalInterface注解**，标记该接口必须是满足函数式接口\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\npublic class LambdaDemo {\r\n    public static void main(String[] args) {\r\n        Swimming s1 = new Swimming() {\r\n            @Override\r\n            public void swim() {\r\n                System.out.println(\"老师游泳\");\r\n            }\r\n        };\r\n        Swimming s2 = () -> System.out.println(\"学生游泳\");\r\n        go(s1);\r\n        go(s2);\r\n    }\r\n\r\n    public static void go(Swimming swimming) {\r\n        System.out.println(\"开始\");\r\n        swimming.swim();\r\n        System.out.println(\"结束\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\n//该注解代表该接口时函数式接口即只有一个抽象方法，多写一个方法就会报错；Lambda表达式可以简化函数式接口；\r\n//不加注解也可以简化，前提是，该接口只有一个抽象方法\r\n@FunctionalInterface\r\ninterface Swimming {\r\n    void swim();\r\n}\r\n~~~\r\n\r\n~~~\r\n开始\r\n老师游泳\r\n结束\r\n开始\r\n学生游泳\r\n结束\r\n~~~\r\n\r\n\r\n\r\n### 总结\r\n\r\nLambda表达式的基本作用：\r\n	简化匿名内部类的写法\r\n\r\nLambda表达式的使用前提：\r\n	1.函数式接口，即是一个对象且对象中只有一个抽象方法\r\n	2.通过匿名内部类的方式创建对象\r\n	\r\nLambda表达式的好处：\r\n	简化代码，使得java语言的表达能力得到提高\r\n\r\n\r\n\r\n- Lambda表达式的省略规则\r\n\r\n​		参数类型可以省略不写。\r\n​		如果只有一个参数，参数类型可以省略，同时()也可以省略。\r\n​		如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写,同时要省略分号！\r\n​		如果Lambda表达式的方法体代码只有一行代码。可以省略大括号不写。\r\n\r\n​		此时，如果这行代码是return语句，【必须】省略return不写，同时也必须省略 \";\"\r\n\r\n', 'https://picsum.photos/seed/ok8s7h/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-06-16 23:08:46', '2022-06-16 23:08:46', 1, 1, '处理时间、Calendar、JDK8新增日期类、包装类、正则表达式、操作数组元素、常见算法、Lambda表达式', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (26, '集合(1)', '## 集合概述体系、常用API\r\n\r\n### 前提引入\r\n\r\n- 数组特点\r\n\r\n数组定义完成后，类型确定、长度固定。\r\n适合元素的个数和类型确定的业务场景，不适合做需要增删数据操作。\r\n\r\n\r\n\r\n- 集合的特点\r\n\r\n集合的大小不固定，启动后可以动态变化，类型也可以选择不固定\r\n集合非常适合做元素的增删操作\r\n\r\n\r\n\r\n- 集合数组对比\r\n\r\n1.数组和集合的元素存储的个数问题。\r\n    数组定义后类型确定，长度固定\r\n    集合类型可以不固定，大小是可变的。\r\n2、数组和集合存储元素的类型问题。\r\n    数组可以存储基本类型和引用类型的数据。\r\n    集合只能存储引用数据类型的数据。（包装类）\r\n3、数组和集合适合的场景\r\n    数组适合做数据个数和类型确定的场景。\r\n    集合适合做数据个数不确定，且要做增删元素的场景。\r\n\r\n\r\n\r\n### 两大种集合\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_16-40-42.png)\r\n\r\n---\r\n\r\n\r\n\r\nCollection：单列集合，每个元素（数据）只包含一个值。\r\nMap：双列集合，每个元素包含两个值（键值对）\r\n\r\n\r\n\r\n\r\n\r\n- **collection集合体系**\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_16-45-22.png)\r\n\r\n---\r\n\r\n\r\n\r\nList系列集合：添加的元素是有序、可重复、有索引。\r\n    ArrayList、LinekdList ：有序、可重复、有索引。\r\nSet系列集合：添加的元素是无序、不重复、无索引。\r\n    HashSet: 无序、不重复、无索引；\r\n    LinkedHashSet: 【有序】、不重复、无索引。\r\n    TreeSet：按照大小默认【升序排序】、不重复、无索引。\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ListDemo\r\n     * Description:List接口特点:有序，可重复，有索引\r\n     * date:2022/3/11\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test1() {\r\n        Collection list = new ArrayList<>();\r\n        list.add(\'a\');\r\n        list.add(97);\r\n        list.add(3.141592653578);\r\n        list.add(true);\r\n        list.add(\"java\");\r\n        list.add(\"java\");\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[a, 97, 3.141592653578, true, java, java]\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n     /**\r\n     * ClassName: ListDemo\r\n     * Description:set接口特点:无序，不重复，无索引\r\n     * date:2022/3/11\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test() {\r\n        Collection set = new HashSet();\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\'a\');\r\n        set.add(97);\r\n        set.add(true);\r\n        System.out.println(set);\r\n    }\r\n~~~\r\n\r\n~~~\r\n  [a, 97, java, true]  \r\n~~~\r\n\r\n\r\n\r\n### **集合对于泛型的支持**\r\n\r\n集合都是支持泛型的，可以在编译阶段约束集合只能操作某种数据类型（可以通过反射和通过赋值无泛型的引用越过泛型约束）\r\n集合和泛型都只能支持引用数据类型，不支持基本数据类型，所以集合中存储的元素都认为是对象\r\n集合中要存储基本类型的数据,需要将基本数据类型转换为包装类；\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        final Collection list1 = new ArrayList<String>();\r\n        final Collection list2 = new ArrayList<>();// JDK 1.7开始后面的泛型类型申明可以省略不写\r\n        final Collection<String> list3 = new ArrayList();//建议加上尖括号，规范\r\n//        final Collection<int> list = new ArrayList<>();//集合与泛型不支持基本数据类型，可以使用包装类\r\n    }\r\n~~~\r\n\r\n- 总结\r\n\r\n1、单列集合的代表是？\r\n    Collection接口。\r\n2、Collection集合分了哪2大常用的集合体系？\r\n    List系列集合：添加的元素是有序、可重复、有索引。\r\n    Set系列集合：添加的元素是无序、不重复、无索引。\r\n3、如何约定集合存储数据的类型，需要注意什么？\r\n    集合支持泛型。\r\n    集合和泛型不支持基本类型，只支持引用数据类型。\r\n\r\n\r\n\r\n### Collection常用API\r\n\r\nCollection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_18-28-36.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~JAVA\r\n    @Test\r\n    public void test1() {\r\n        Collection<String> list = new ArrayList<>();\r\n        System.out.println(\"添加元素\" + list.add(\"java\"));//返回真假，一般来说除了set有不能重复的限制外，其他一般为true\r\n        list.add(\"java\");\r\n        list.add(\"css\");\r\n        list.add(\"phthon\");\r\n        list.add(\"javascript\");\r\n        list.add(\"c#\");\r\n        System.out.println(\"目前集合元素个数\" + list.size());//目前集合中的元素个数\r\n        System.out.println(\"移除元素\" + list.remove(\"css\"));//是否删除成功\r\n        System.out.println(\"包含元素\" + list.contains(\"java\"));//是否包含某个元素\r\n        final Object[] array = list.toArray();\r\n        System.out.println(Arrays.toString(array));\r\n        System.out.println(\"集合是否为空\" + list.isEmpty());\r\n        list.clear();//清空集合\r\n        System.out.println(\"集合是否为空\" + list.isEmpty());\r\n        System.out.println(\"----------------------------\");\r\n        Collection<String> set = new HashSet<>();\r\n        Collection<String> set2 = new HashSet<>();\r\n        System.out.println(\"添加元素\" + set.add(\"java\"));\r\n        System.out.println(\"添加元素\" + set.add(\"java\"));\r\n        set.add(\"phthon\");\r\n        set2.add(\"c++\");\r\n        set2.add(\"c#\");\r\n\r\n        set.addAll(set2);//把set2中的元素拷贝到set中\r\n        System.out.println(set);\r\n        System.out.println(set2);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n添加元素true\r\n目前集合元素个数6\r\n移除元素true\r\n包含元素true\r\n[java, java, phthon, javascript, c#]\r\n集合是否为空false\r\n集合是否为空true\r\n----------------------------\r\n添加元素true\r\n添加元素false\r\n[c#, c++, java, phthon]\r\n[c#, c\r\n~~~\r\n\r\n\r\n\r\n### **Collection**集合存储自定义类型的对象\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_20-39-39.png)\r\n\r\n---\r\n\r\n集合中存储的是元素对象的地址\r\n\r\n\r\n\r\n\r\n\r\n## 集合迭代\r\n\r\n### 第一种遍历方式迭代器\r\n\r\n迭代器是集合的专用遍历方式\r\n遍历就是一个一个的把容器中的元素访问一遍。 \r\n迭代器在Java中的代表是Iterator\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_18-57-42.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        Collection list = new ArrayList<>();\r\n        list.add(\"a\");\r\n        list.add(\"b\");\r\n        list.add(\"c\");\r\n        final Iterator iterator = list.iterator();//获取该集合的迭代器，并指向第一个元素\r\n\r\n/*        System.out.println(iterator.next());//取出第一个元素，并移到下一个位置\r\n        System.out.println(iterator.next());\r\n        System.out.println(iterator.next());\r\n        System.out.println(iterator.next());//异常NoSuchElementException*/\r\n\r\n        while (iterator.hasNext()) {//看一下当前位置是否有元素\r\n            System.out.println(iterator.next());//取出当前位置的元素值，并把指向移到下一位\r\n        }\r\n    }\r\n~~~\r\n\r\n- 小结\r\n\r\n1、迭代器的默认位置在哪里。\r\n    Iterator\\<E> iterator()：得到迭代器对象，默认指向当前集合的索引0\r\n\r\n2、迭代器如果取元素越界会出现什么问题。\r\n    会出现NoSuchElementException异常。\r\n\r\n\r\n\r\n### 第二种遍历方式foreach也叫增强for循环\r\n\r\n增强for循环：既可以遍历集合也可以遍历数组\r\n\r\n格式：\r\n\r\n~~~JAVA\r\n    for(元素数据类型 变量名 : 数组或者Collection集合) {\r\n             //在此处使用变量即可，该变量就是元素\r\n    }\r\n~~~\r\n\r\n\r\n​    \r\n修改第三方变量的值不会影响到集合中的元素\r\n\r\n\r\n\r\n\r\n\r\n### 方式三：lambda表达式\r\n\r\nLambda表达式，提供了一种更简单、更直接的遍历集合的方式。\r\n集合才拥有Lambda表达式的遍历方法，数组没有\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_20-26-07.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 源码\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/image-20220311202419411.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test6() {\r\n        final int[] ints = {1, 2, 32, 5, -4, 0, 21};\r\n        Collection<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"spring\", \"springframe\", \"mybatis\", \"hibernate\", \"mysql\");\r\n\r\n        list.forEach(new Consumer<String>() {\r\n            @Override\r\n            public void accept(String s) {\r\n                System.out.println(s);\r\n            }\r\n        });//匿名内部类    \r\n//        list.forEach(s -> System.out.println(s));//Lanbda表达式简化写法\r\n//        list.forEach(System.out::println);//方法引用 Lambda表达式的简化写法，要求将接收到的参数直接输出sout\r\n    }\r\n~~~\r\n\r\n~~~\r\nspring\r\nspringframe\r\nmybatis\r\nhibernate\r\nmysql\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 常用数据结构\r\n\r\n### 数据结构概述、栈、队列\r\n\r\n- 数据机构概述\r\n\r\n数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。\r\n通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率\r\n\r\n\r\n\r\n- 常见的数据结构\r\n\r\n栈\r\n队列\r\n数组\r\n链表\r\n二叉树\r\n二叉查找树\r\n平衡二叉树\r\n红黑树\r\n....\r\n\r\n- **栈数据结构**\r\n\r\n特点：\r\n	后进先出，先进后出\r\n\r\n数据进入栈模型的过程称为：压/进栈\r\n数据离开栈模型的过程称为：弹/出栈\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_20-57-09.png)\r\n\r\n---\r\n\r\n\r\n\r\n- **队列**\r\n\r\n先进先出，后进后出\r\n数据从后端进入队列模型的过程称为：入队(列)\r\n数据从前端离开队列模型的过程称为：出队(列)\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_21-01-28.png)\r\n\r\n---\r\n\r\n\r\n\r\n- **数组**\r\n\r\n查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同。（元素在内存中是连续存储的）随机存储存取;通过索引查询的速度快\r\n删除效率低：要将原始数据删除，同时后面每个数据前移。\r\n添加效率极低：添加位置后的每个数据后移，再添加元素。\r\n\r\n\r\n\r\n\r\n\r\n- 链表\r\n\r\n链表中的元素是在内存中不连续存储的，每个元素节点包含数据值和下一个元素的地址。\r\n链表查询慢。无论查询哪个数据都要从头开始找(对比数组）\r\n链表增删相对快(对比数组）\r\n\r\n- 链表的结构\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_21-09-24.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 链表的种类\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_21-11-35.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 二叉树\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_21-14-32.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 二叉树的特点\r\n\r\n只能有一个根节点，每个节点最多支持2个直接子节点。\r\n节点的度： 节点拥有的子树的个数，二叉树的度不大于2 叶子节点 度为0的节点，也称之为终端结点。\r\n高度：叶子结点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高。\r\n层：根节点在第一层，以此类推\r\n兄弟节点 ：拥有共同父节点的节点互称为兄弟节点\r\n\r\n\r\n\r\n- 二叉查找树\r\n\r\n二叉查找树又称二叉排序树或者二叉搜索树\r\n\r\n特点：\r\n1，每一个节点上最多有两个子节点\r\n2，左子树上所有节点的值都小于根节点的值\r\n3，右子树上所有节点的值都大于根节点的值\r\n\r\n作用：\r\n	提高检索数据的性能\r\n\r\n\r\n\r\n- 平衡二叉树\r\n\r\n二叉查找树出现的问题：\r\n	出现瘸子现象(数据全存在树的一边)，导致查询的性能与单链表一样，查询速度变慢\r\n	\r\n平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。\r\n\r\n平衡二叉树的要求：\r\n	任意节点的左右两个子树的高度差不超过1，任意节点的左右两个子树都是一颗平衡二叉树\r\n\r\n\r\n\r\n- 红黑树\r\n\r\n红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。\r\n1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的\"红黑树\"。\r\n每一个节点可以是红或者黑；红黑树不是通过高度平衡的，它的平衡是通过“红黑规则”进行实现的\r\n\r\n\r\n\r\n- 红黑规则\r\n\r\n每一个节点或是红色的，或者是黑色的，根节点必须是黑色。\r\n如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)。\r\n对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点\r\n添加的节点的颜色.默认用红色效率高\r\n\r\n\r\n\r\n- 红黑树结构图\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_23-07-40.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 红黑树小结\r\n\r\n红黑树增删改查的性能都很好\r\n红黑树不是高度平衡的，它的平衡是通过\"红黑规则\"进行实现的\r\n\r\n\r\n\r\n- **各种数据结构的特点和作用**\r\n\r\n队列：先进先出，后进后出。\r\n栈：后进先出，先进后出。\r\n数组：内存连续区域，查询快，增删慢。\r\n链表：元素是游离的，查询慢，首尾操作极快。\r\n二叉树：永远只有一个根节点, 每个结点不超过2个子节点的树。\r\n查找二叉树：小的左边，大的右边，但是可能树很高，查询性能变差。\r\n平衡查找二叉树：让树的高度差不大于1，增删改查都提高了。\r\n红黑树（就是基于红黑规则实现了自平衡的排序二叉树）\r\n\r\n\r\n\r\n## List系列集合\r\n\r\n### List集合特点、特有API\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_23-22-35.png)\r\n\r\n---\r\n\r\n\r\n\r\nList系列集合特点:\r\n  ArrayList、LinekdList ：有序，可重复，有索引。\r\n    有序：存储和取出的元素顺序一致\r\n    有索引：可以通过索引操作元素\r\n    可重复：存储的元素可以重复\r\n\r\n\r\n\r\n\r\n\r\nList的实现类的底层原理\r\n    ArrayList底层是基于数组实现的，根据查询元素快，增删相对慢。(随机存储存取)\r\n    LinkedList底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的。\r\n\r\nList集合因为支持索引，所以多了很多索引操作的独特api，其他Collection的功能List也都继承了\r\n\r\n\r\n\r\n- **List集合特有API**\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_23-24-21.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-11_18-28-36-16553982339811.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test9() {\r\n        List<String> list = new ArrayList<>();\r\n        list.add(\"java\");//Collection\r\n        list.add(\"java\");//Collection\r\n        list.add(\"springmvc\");//Collection\r\n        list.add(\"spring\");//Collection\r\n        list.add(\"mongodb\");//Collection\r\n        System.out.println(list);\r\n        System.out.println(list.get(2));//List\r\n        System.out.println(list.remove(0));//List\r\n        System.out.println(list);\r\n        list.set(1, \"SpringMVC\");//List\r\n        System.out.println(list.contains(\"SpringMVC\"));//Collection\r\n        System.out.println(list.size());//Collection\r\n        System.out.println(list.remove(\"spring\"));//Collection\r\n        System.out.println(list);\r\n        final Object[] array = list.toArray();//Collection\r\n        System.out.println(Arrays.toString(array));//Collection\r\n        list.clear();//Collection\r\n        System.out.println(list.isEmpty());//Collection\r\n        System.out.println(list.size());//Collection\r\n    }\r\n~~~\r\n\r\n~~~\r\n[java, java, springmvc, spring, mongodb]\r\nspringmvc\r\njava\r\n[java, springmvc, spring, mongodb]\r\ntrue\r\n4\r\ntrue\r\n[java, SpringMVC, mongodb]\r\n[java, SpringMVC, mongodb]\r\ntrue\r\n0\r\n~~~\r\n\r\n\r\n\r\n### List集合的遍历方式小结\r\n\r\n1.迭代器 \r\n2.增强for循环\r\n3.Lambda表达式\r\n4.for循环（因为List集合存在索引）\r\n\r\n\r\n\r\n1. 迭代器\r\n\r\n~~~java\r\n    @Test\r\n    public void test12() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"Mybatis\", \"hibernate\", \"ObjectOrientedProgram\", \"redis\", \"tomcat\");\r\n        final Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()) {\r\n            System.out.println(iterator.next());\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\nMybatis\r\nhibernate\r\nObjectOrientedProgram\r\nredis\r\ntomcat\r\n~~~\r\n\r\n\r\n\r\n2. 增强for（foreach）\r\n\r\n~~~java\r\n    @Test\r\n    public void test12() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"Mybatis\", \"hibernate\", \"ObjectOrientedProgram\", \"redis\", \"tomcat\");\r\n        for (String s : list) {\r\n            System.out.println(s);\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\nMybatis\r\nhibernate\r\nObjectOrientedProgram\r\nredis\r\ntomcat\r\n~~~\r\n\r\n\r\n\r\n3. Lambda表达式\r\n\r\n~~~java\r\n    @Test\r\n    public void test12() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"Mybatis\", \"hibernate\", \"ObjectOrientedProgram\", \"redis\", \"tomcat\");\r\n//        list.forEach(System.out::println);//方法引用\r\n//        list.forEach(s -> System.out.println(s));//Lambda表达式\r\n        list.forEach(new Consumer<String>() {\r\n            @Override\r\n            public void accept(String s) {\r\n                System.out.println(s);\r\n            }\r\n        });\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\nMybatis\r\nhibernate\r\nObjectOrientedProgram\r\nredis\r\ntomcat\r\n~~~\r\n\r\n\r\n\r\n4. for循环\r\n\r\n~~~java\r\n    @Test\r\n    public void test12() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"Mybatis\", \"hibernate\", \"ObjectOrientedProgram\", \"redis\", \"tomcat\");\r\n        for (int i = 0; i < list.size(); i++) {\r\n            System.out.println(list.get(i));\r\n        }\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\nMybatis\r\nhibernate\r\nObjectOrientedProgram\r\nredis\r\ntomcat\r\n~~~\r\n\r\n\r\n\r\n### ArrayList集合的底层原理\r\n\r\nArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。\r\n第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。\r\nList集合的size和下一个元素插入的位置----------》当前元素的下一个位置（当前元素索引加一）\r\n当插入元素的位置与当前集合大小相等，就会扩容 >>1;\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-12_08-26-03.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n### LinkedList集合的底层原理\r\n\r\n底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-12_08-44-59.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ListDemo\r\n     * Description:LinkedList实现栈\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test13() {\r\n        LinkedList<String> linkedList = new LinkedList<>();\r\n        linkedList.push(\"第1\");//入栈 (内部封装了addFirst)\r\n        linkedList.addFirst(\"第2\");//在首位加入元素\r\n        linkedList.addFirst(\"第3\");//在首位加入元素\r\n        linkedList.addFirst(\"第4\");//在首位加入元素\r\n        linkedList.addFirst(\"第5\");//在首位加入元素\r\n        linkedList.addFirst(\"第6\");//在首位加入元素\r\n        System.out.println(linkedList);\r\n        System.out.println(linkedList.getFirst());\r\n        System.out.println(linkedList.pop());//出栈(内部封装了removeFirst)\r\n        System.out.println(linkedList.removeFirst());//取出并获取第二个元素\r\n        System.out.println(linkedList.removeFirst());//取出并获取第三个元素\r\n        System.out.println(linkedList.removeFirst());//取出并获取第四个元素\r\n        System.out.println(linkedList.removeFirst());//取出并获取第五个元素\r\n        System.out.println(linkedList.removeFirst());//取出并获取第六个元素\r\n    }\r\n~~~\r\n\r\n~~~\r\n[第6, 第5, 第4, 第3, 第2, 第1]\r\n第6\r\n第6\r\n第5\r\n第4\r\n第3\r\n第2\r\n第1\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n~~~JAVA\r\n   /**\r\n     * ClassName: ListDemo\r\n     * Description:LinkedList实现队列\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test14() {\r\n        LinkedList linkedList = new LinkedList();\r\n        linkedList.addLast(\"第一个\");//入队\r\n        linkedList.addLast(\"第二个\");//入队\r\n        linkedList.addLast(\"第三个\");//入队\r\n        linkedList.addLast(\"第四个\");//入队\r\n        linkedList.addLast(\"第五个\");//入队\r\n        System.out.println(linkedList);\r\n        System.out.println(linkedList.getFirst());//获取队头第一个元素\r\n        System.out.println(linkedList.removeFirst());//出队\r\n        System.out.println(linkedList.removeFirst());//出队\r\n        System.out.println(linkedList.removeFirst());//出队\r\n        System.out.println(linkedList.removeFirst());//出队\r\n        System.out.println(linkedList.removeFirst());//出队\r\n        System.out.println(linkedList);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[第一个, 第二个, 第三个, 第四个, 第五个]\r\n第一个\r\n第二个\r\n第三个\r\n第四个\r\n第五个\r\n[]\r\n~~~\r\n\r\n\r\n\r\n- **LinkedList是一种双向列表**\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-12_08-55-48.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n### **集合的并发修改异常问题**\r\n\r\n问题引出：\r\n	当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题\r\n如：\r\n    迭代器遍历集合且直接用集合删除元素的时候可能出现。\r\n    增强for循环遍历集合且直接用集合删除元素的时候可能出现（底层是foreach）\r\n    \r\n哪种遍历且删除元素不出问题:\r\n    迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。\r\n    使用for循环遍历并删除元素不会存在这个问题\r\n\r\n\r\n\r\n1. 迭代器\r\n\r\n~~~java\r\n     * ClassName: ListDemo\r\n     * Description:迭代器遍历删除元素，会出现并发修改的问题；可以解决\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    @Test\r\n    public void test15() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"spring\", \"spring\", \"jpa\", \"oracle\", \"mongodb\");\r\n        System.out.println(list);\r\n        final Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()) {\r\n            if (Objects.equals(\"spring\", iterator.next())) {\r\n                //会出现并发修改异常（漏删元素）\r\n//                list.remove(\"spring\");//java.util.ConcurrentModificationException\r\n                iterator.remove();//删除元素后会把索引减一，保证不会越过元素\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n~~~\r\n[spring, spring, jpa, oracle, mongodb]\r\n[jpa, oracle, mongodb]\r\n~~~\r\n\r\n\r\n\r\n2. foreach\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ListDemo\r\n     * Description:foreach遍历删除元素，会出现并发修改的问题；不可以解决\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    @Test\r\n    public void test16() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"spring\", \"spring\", \"jpa\", \"oracle\", \"mongodb\");\r\n        System.out.println(list);\r\n        for (String s : list) {\r\n            if (Objects.equals(s, \"spring\")) {\r\n                //会出现并发修改异常（漏删元素）不能解决\r\n                list.remove(\"spring\");//java.util.ConcurrentModificationException\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n3. Lambda\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ListDemo\r\n     * Description:Lambda表达式foreach遍历删除元素，会出现并发修改的问题；不可以解决\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    @Test\r\n    public void test16() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"spring\", \"spring\", \"jpa\", \"oracle\", \"mongodb\");\r\n        System.out.println(list);\r\n        list.forEach(s -> {\r\n            if (Objects.equals(s, \"spring\")) {\r\n                list.remove(\"spring\");\r\n            }\r\n        });\r\n        System.out.println(list);\r\n    }\r\n~~~\r\n\r\n4. for循环\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: ListDemo\r\n     * Description:for遍历删除元素，会出现漏删的问题，不会报错；可以解决\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n    @Test\r\n    public void test17() {\r\n        List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"spring\", \"spring\", \"jpa\", \"oracle\", \"mongodb\");\r\n        System.out.println(list);\r\n/*        //第一种方法：从后往前删\r\n        for (int i = list.size() - 1; i >= 0; i--) {\r\n            if (Objects.equals(\"spring\", list.get(i))) {\r\n                list.remove(i);\r\n            }\r\n        }*/\r\n        //第二种方法，成功删除元素后，将索引值减一\r\n        for (int i = 0; i < list.size(); i++) {\r\n            if (Objects.equals(\"spring\", list.get(i))) {\r\n                list.remove(i);\r\n                i--;\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[spring, spring, jpa, oracle, mongodb]\r\n[jpa, oracle, mongodb]\r\n~~~\r\n\r\n\r\n\r\n## 泛型深入\r\n\r\n### 泛型的概述和优势\r\n\r\n泛型概述：\r\n    泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。\r\n    泛型的格式：<数据类型>; 注意：泛型只能支持引用数据类型。\r\n    集合体系的全部接口和实现类都是支持泛型的使用的。\r\n    \r\n泛型的好处：\r\n    统一数据类型。\r\n    把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来    \r\n    \r\n    \r\n    \r\n泛型可以在很多地方进行定义:\r\n	类后面---------------------》泛型类\r\n	方法申明上---------------》泛型方法\r\n	接口后面------------------》泛型接口\r\n\r\n\r\n\r\n### 自定义泛型类\r\n\r\n- 泛型类概述\r\n\r\n定义类时同时定义了泛型的类就是泛型类。\r\n泛型类的格式：修饰符 class 类名<泛型变量>{}\r\n此处泛型变量可以随便写为任意标识，常见的如E、T、K、V等\r\n\r\n\r\n\r\n- 作用\r\n\r\n编译阶段可以指定数据类型，类似于集合的作用\r\n\r\n\r\n\r\n- **泛型类的原理**\r\n\r\n把出现泛型变量的地方全部替换成传输的真实数据类型\r\n\r\n~~~java\r\npublic class MyArrayList<E> {\r\n    private List list = new ArrayList();\r\n	//这个不是泛型方法，这里只是使用类定义的泛型变量\r\n    public boolean add(E e) {\r\n        return list.add(e);\r\n    }\r\n\r\n    public boolean remove(E e) {\r\n        return list.remove(e);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return list.toString();\r\n    }\r\n}\r\n~~~\r\n\r\n~~~JAVA\r\nclass Test {\r\n    public static void main(String[] args) {\r\n        final MyArrayList<String> my = new MyArrayList<>();\r\n        System.out.println(my.add(\"123\"));\r\n        System.out.println(my.add(\"456\"));\r\n        System.out.println(my.add(\"java\"));\r\n        System.out.println(my.add(\"spring\"));\r\n        System.out.println(my.add(\"mybatis\"));\r\n        System.out.println(my);\r\n        System.out.println(my.remove(\"java\"));\r\n        System.out.println(my);\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\ntrue\r\ntrue\r\ntrue\r\ntrue\r\ntrue\r\n[123, 456, java, spring, mybatis]\r\ntrue\r\n[123, 456, spring, mybatis]\r\n~~~\r\n\r\n\r\n\r\n### 自定义泛型方法\r\n\r\n- 泛型方法概述\r\n\r\n定义方法时同时定义了泛型的方法就是泛型方法。\r\n\r\n泛型方法的格式：修饰符 <泛型变量> 方法返回值 方法名称(形参列表){}\r\n   泛型变量定义在返回值之前\r\n\r\n范例： \r\n	public <T> void show(T t) {}\r\n	\r\n作用：\r\n	方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性\r\n	\r\n泛型方法的原理：\r\n    把出现泛型变量的地方全部替换成传输的真实数据类型\r\n\r\n\r\n\r\n~~~java\r\npublic class GenericMethodDemo {\r\n\r\n    public static void main(String[] args) {\r\n        final String[] strings = {\"阿黄\", \"阿雄\", \"阿刘\"};\r\n        printArrays(strings);\r\n        printArrays(shuffleArray(strings));\r\n\r\n        final Integer[] ints = {11, 52, 1, 47, -47, 0, 3};\r\n        printArrays(ints);\r\n        printArrays(shuffleArray(ints));\r\n    }\r\n\r\n\r\n    public static <T> void printArrays(T[] arr) {\r\n        if (arr == null) {\r\n            System.out.println(\"null\");\r\n            return;\r\n        }\r\n        final StringBuilder sb = new StringBuilder(\"[\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i == arr.length - 1 ? \"\" : \",\");\r\n        }\r\n        sb.append(\"]\");\r\n        System.out.println(sb);\r\n    }\r\n\r\n\r\n~~~\r\n\r\n~~~java\r\n    /**\r\n     * ClassName: GenericMethodDemo\r\n     * Description:返回值类型就是泛型\r\n     * date:2022/3/12\r\n     *\r\n     * @author fgcy\r\n     * @since JDK 1.8\r\n     */\r\n\r\n    public static <T> T[] shuffleArray(T[] arr) {\r\n        if (arr == null) return null;\r\n        final Random r = new Random();\r\n        for (int i = 0; i < arr.length - 1; i++) {\r\n            final int anInt = r.nextInt(arr.length);\r\n            T temp = arr[i];\r\n            arr[i] = arr[anInt];\r\n            arr[anInt] = temp;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n[阿黄,阿雄,阿刘]\r\n[阿雄,阿黄,阿刘]\r\n[11,52,1,47,-47,0,3]\r\n[0,1,47,52,-47,11,3]\r\n~~~\r\n\r\n\r\n\r\n### 自定义泛型接口\r\n\r\n- **泛型接口**的概述\r\n\r\n使用了泛型定义的接口就是泛型接口。\r\n\r\n泛型接口的格式：修饰符 interface 接口名称<泛型变量>{}\r\n\r\n作用：\r\n	泛型接口可以让实现类选择当前功能需要操作的数据类型（约束实现类操作的数据类型）\r\n	\r\n泛型接口的原理：\r\n	实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作\r\n	因为操作的类型在接口中定义了\r\n\r\n\r\n\r\n~~~java\r\npublic class GenericDemo2 {\r\n    public static void main(String[] args) {\r\n        final TeacherData teacherData = new TeacherData();\r\n        System.out.println(teacherData.findAllData());\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\ninterface Data<E> {\r\n    boolean removeData(int id);\r\n\r\n    boolean addData(E e);\r\n\r\n    List<E> findAllData();\r\n}\r\n~~~\r\n\r\n~~~java\r\nclass TeacherData implements Data<Teacher> {\r\n    @Override\r\n    public boolean removeData(int id) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public boolean addData(Teacher teacher) {\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public List<Teacher> findAllData() {\r\n        final List<Teacher> list = new ArrayList<>();\r\n        Collections.addAll(list, new Teacher(\"aaa\", 12), new Teacher(\"bbb\", 13), new Teacher(\"ccc\", 22));\r\n        return list;\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~~java\r\nclass Teacher {\r\n    private String name;\r\n    private int age;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Teacher{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \", age=\" + age +\r\n                \'}\';\r\n    }\r\n\r\n    public Teacher(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n~~~~\r\n\r\n~~~\r\n[Teacher{name=\'aaa\', age=12}, Teacher{name=\'bbb\', age=13}, Teacher{name=\'ccc\', age=22}]\r\n~~~\r\n\r\n\r\n\r\n### 泛型通配符、上下限\r\n\r\n通配符: ?\r\n    ? 可以在“使用泛型”的时候代表一切类型。 使用\r\n    E T K V 是在定义泛型的时候使用的。	 定义\r\n    \r\n泛型的上下限：\r\n	? extends Car: ?必须是Car或者其子类   泛型上限\r\n 	? super Car ： ?必须是Car或者其父类   泛型下限\r\n\r\n\r\n\r\n- 问题1：ArrayList\\<Car>类型与ArrayList\\<BMW>的类型没有关系\r\n\r\n~~~java\r\npublic class GenericDemo3 {\r\n\r\n\r\n    public static void go(List<Car> cars) {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final ArrayList<BENZ> list1 = new ArrayList<>();\r\n        Collections.addAll(list1, new BENZ(), new BENZ(), new BENZ());\r\n//        go(list1);//报错\r\n\r\n        final ArrayList<BMW> list2 = new ArrayList<>();\r\n        Collections.addAll(list2, new BMW(), new BMW(), new BMW());\r\n//        go(list2);//报错\r\n        //虽然BMW和BENZ都继承了Car但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系的！!\r\n        //Car类确实可以通过多态的方式接收子类的参数，但ArrayList<Car>是作为一个整体，一个类型，不存在之前的继承关系\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\nclass Car {\r\n}\r\n\r\nclass BENZ extends Car {\r\n}\r\n\r\nclass BMW extends Car {\r\n}\r\n~~~\r\n\r\n\r\n\r\n- 问题2：使用了 ？通配符 出现了新的问题\r\n\r\n~~~java\r\npackage generic_demo;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n\r\npublic class GenericDemo3 {\r\n\r\n    //使用了 ？通配符，代表可以使用任何类型\r\n    public static void go(List<?> cars) {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final ArrayList<BENZ> list1 = new ArrayList<>();\r\n        Collections.addAll(list1, new BENZ(), new BENZ(), new BENZ());\r\n        go(list1);//不报错\r\n\r\n        final ArrayList<BMW> list2 = new ArrayList<>();\r\n        Collections.addAll(list2, new BMW(), new BMW(), new BMW());\r\n        go(list2);//不报错\r\n\r\n        final ArrayList<Dog> list3 = new ArrayList<>();\r\n        Collections.addAll(list3, new Dog(), new Dog(), new Dog());\r\n        go(list3);//不报错,有问题：因为狗类与汽车类没有关系，不符合逻辑\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\nclass Car {\r\n}\r\n\r\n\r\nclass BENZ extends Car {\r\n}\r\n\r\nclass BMW extends Car {\r\n}\r\n\r\nclass Dog {\r\n}\r\n~~~\r\n\r\n\r\n\r\n- 使用泛型上限\r\n\r\n~~~java\r\npackage generic_demo;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n\r\npublic class GenericDemo3 {\r\n\r\n    //使用了 ？通配符，代表可以使用任何类型;但是这里做了限制: ? extends 父类 表示----> ? 只能代表夫类型或是父类型的子类型\r\n    public static void go(List<? extends Car> cars) {\r\n\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        final ArrayList<BENZ> list1 = new ArrayList<>();\r\n        Collections.addAll(list1, new BENZ(), new BENZ(), new BENZ());\r\n        go(list1);//不报错\r\n\r\n        final ArrayList<BMW> list2 = new ArrayList<>();\r\n        Collections.addAll(list2, new BMW(), new BMW(), new BMW());\r\n        go(list2);//不报错\r\n\r\n        final ArrayList<Dog> list3 = new ArrayList<>();\r\n        Collections.addAll(list3, new Dog(), new Dog(), new Dog());\r\n//        go(list3);//报错,没有问题：因为狗类与汽车类没有关系，符合逻辑\r\n\r\n\r\n        final ArrayList<Car> list4 = new ArrayList<>();\r\n        //集合里里面的类型,子类和父类还是有关系的,可以使用多态接收参数\r\n        Collections.addAll(list4, new Car(), new BMW(), new BMW());\r\n        go(list4);//不报错\r\n    }\r\n}\r\n~~~\r\n\r\n~~~java\r\nclass Car {\r\n\r\n}\r\n\r\n\r\nclass BENZ extends Car {\r\n\r\n}\r\n\r\nclass BMW extends Car {\r\n\r\n}\r\n\r\nclass Dog {\r\n\r\n}\r\n~~~\r\n\r\n', 'https://picsum.photos/seed/fc55/800/450', '原创', 0, b'1', b'1', b'1', b'1', b'1', '2022-06-17 01:00:58', '2022-06-17 01:00:58', 1, 1, '集合概述体系、常用API、集合迭代、常用数据结构、List系列集合、泛型深入', '1,15', 0, 0, b'0');
INSERT INTO `t_blog` VALUES (29, '不可变集合、Stream流、异常体系、异常体系', '## 不可变集合\r\n\r\n- 概念\r\n\r\n不可变集合，就是不可被修改的集合。\r\n集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。\r\n\r\n\r\n\r\n- 作用\r\n\r\n如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。\r\n或者当集合对象被不可信的库调用时，不可变形式是安全的\r\n\r\n- **如何创建不可变集合？**\r\n\r\n  在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合  【since 1.9】\r\n  这个集合不能添加，不能删除，不能修改。\r\n\r\n~~~java\r\nList.of();\r\nSet.of()\r\nMap.of()\r\n~~~\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_10-33-33.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    public static void main(String[] args) {\r\n        //不可变集合，从jdk1.9开始,只可以访问不可以操作\r\n        final List<Double> list = List.of(120.1, 22.4, 120.4, 111.2);\r\n//        list.add(111.2);//java.lang.UnsupportedOperationException\r\n//        list.set(1, 100.1);//java.lang.UnsupportedOperationException\r\n        list.forEach(System.out::println);\r\n    }\r\n~~~\r\n\r\n~~~\r\n120.1\r\n22.4\r\n120.4\r\n111.2\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        //不可变集合，不可以增删改，只可以查\r\n        final Set<Double> set = Set.of(120.1, 22.4, 120.4, 111.2);\r\n//        final Set<Double> set = Set.of(120.1, 22.4, 120.4, 111.2, 111.2);//当有重复值是也报错   java.lang.IllegalArgumentException: duplicate element: 111.2\r\n//        set.clear();//java.lang.UnsupportedOperationException\r\n        System.out.println(set);\r\n        set.forEach(System.out::println);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[120.1, 22.4, 111.2, 120.4]\r\n120.1\r\n22.4\r\n111.2\r\n120.4\r\n~~~\r\n\r\n\r\n\r\n## Stream流\r\n\r\n\r\n\r\n- 概念\r\n\r\n在Java 8中，得益于Lambda所带来的函数式编程， 引入了一个全新的Stream流概念。\r\n\r\n目的：用于简化集合和数组操作的API。\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_10-45-56.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 原生与Stream对比\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"张三丰\", \"张无忌\", \"赵敏\", \"任盈盈\", \"小龙女\", \"张强\");\r\n        final ArrayList<String> zhangThree = new ArrayList<>();\r\n        final ArrayList<String> zhangThree2 = new ArrayList<>();\r\n        System.out.println(list);\r\n        for (String s : list) {\r\n            if (s.startsWith(\"张\") && s.length() == 3) zhangThree.add(s);\r\n        }\r\n        System.out.println(zhangThree);\r\n        \r\n        System.out.println(\"----------------------------------------------\");\r\n        \r\n        list.stream().filter(s -> s.startsWith(\"张\")).filter(s -> s.length() == 3).forEach(s -> zhangThree2.add(s));\r\n        System.out.println(zhangThree2);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[张三丰, 张无忌, 赵敏, 任盈盈, 小龙女, 张强]\r\n[张三丰, 张无忌]\r\n----------------------------------------------\r\n[张三丰, 张无忌]\r\n~~~\r\n\r\n\r\n\r\n- **Stream流式思想的核心：**\r\n\r\n通过数组/集合.stream(),得到集合或者数组的Stream流（就是一根传送带）\r\n\r\n然后就用这个Stream流简化的API来方便的操作元素\r\n\r\n\r\n\r\n- **Stream**流的三类方法\r\n\r\n获取Stream流\r\n    创建一条流水线，并把数据放到流水线上准备进行操作\r\n\r\n中间方法\r\n    流水线上的操作。一次操作完毕之后，还可以继续进行其他操作\r\n\r\n终结方法 \r\n    一个Stream流只能有一个终结方法，是流水线上的最后一个操作foreach、count\r\n\r\n\r\n\r\n- 小结\r\n\r\nStream流的作用是什么，结合了什么技术？\r\n    简化集合、数组操作的API。结合了Lambda表达式。\r\n\r\n\r\n\r\n### Stream流的获取\r\n\r\n- 集合获取Stream流\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_11-07-55.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 数组获取Stream流方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_11-08-59.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n- 获取Stream流\r\n\r\n~~~java\r\n    @Test\r\n    public void test2() {\r\n        //Collection集合\r\n        final List<Object> list = new ArrayList<>();\r\n        final Stream<Object> stream1 = list.stream();\r\n\r\n        final Set<String> set = new HashSet<>();\r\n        final Stream<String> stream2 = set.stream();\r\n\r\n        //Map集合\r\n        final HashMap<String, Integer> map = new HashMap<>();\r\n        final Set<String> keySet = map.keySet();\r\n        final Collection<Integer> values = map.values();\r\n        final Set<Map.Entry<String, Integer>> entrySet = map.entrySet();\r\n        final Stream<String> stream3 = keySet.stream();\r\n        final Stream<Integer> stream4 = values.stream();\r\n        final Stream<Map.Entry<String, Integer>> stream5 = entrySet.stream();\r\n\r\n        //数组\r\n        final int[] ints = new int[4];\r\n        final IntStream stream7 = Arrays.stream(ints);\r\n        final Stream<int[]> stream6 = Stream.of(ints);\r\n        stream6.forEach(System.out::println);\r\n        stream7.forEach(System.out::println);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[I@9e89d68\r\n0\r\n0\r\n0\r\n0\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### Stream流的常用API\r\n\r\n- 中间方法\r\n\r\n----\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_11-27-14.png)\r\n\r\n---\r\n\r\n\r\n\r\n- 终结方法\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_13-45-54.png)\r\n\r\n---\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test3() {\r\n        final List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"张三丰\", \"张无忌\", \"赵敏\", \"任盈盈\", \"小龙女\", \"张强\");\r\n        final Stream<String> stream = list.stream();//得到stream流\r\n\r\n        // Stream<T> filter(Predicate<? super T> predicate);函数式接口\r\n        //filter()内部是一个函数式接口，该接口中有一个叫test()的方法\r\n        //filter()会遍历集合中的每一个元素，然后调用Predicate接口中的test方法，看是否满足条件，将不满足条件的干掉\r\n        //filter()是一个中间方法\r\n        stream.filter(new Predicate<String>() {\r\n            @Override\r\n            public boolean test(String s) {\r\n                return s.startsWith(\"张\");\r\n            }\r\n        }).forEach(System.out::println);//方法引用\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n张三丰\r\n张无忌\r\n张强\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test4() {\r\n        final List<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"张三丰\", \"张无忌\", \"赵敏\", \"任盈盈\", \"小龙女\", \"张强\", \"张作霖\", \"张自忠\", \"张三丰\");\r\n        //limit(n)取前几个\r\n//        list.stream().filter(s->s.startsWith(\"张\")).limit(3).forEach(System.out::println);//取前三个以张开头的\r\n\r\n        //skip(n)跳过前几个\r\n//        list.stream().filter(s -> s.startsWith(\"张\")).skip(3).forEach(System.out::println);//跳过三个以张开头的\r\n\r\n        //distinct()去重\r\n        //去重，如果是自定义类型，则根据hashcode和equals\r\n//        list.stream().filter(s -> s.startsWith(\"张\")).distinct().forEach(System.out::println);\r\n\r\n        //count()容器元素个数\r\n//        System.out.println(list.stream().filter(s -> s.startsWith(\"张\")).distinct().count());//获取过滤后元素个数\r\n\r\n        //map()加工方法，第一个参数:原材料，第二个参数:返回值 第一种\r\n        final ArrayList<Object> arrayList = new ArrayList<>();\r\n/*        list.stream().map(new Function<String, Student>() {\r\n            @Override\r\n            public Student apply(String s) {\r\n                return new Student(s);\r\n            }\r\n        }).forEach(student -> arrayList.add(student));\r\n*/\r\n\r\n\r\n        //map()加工方法，第一个参数:原材料，第二个参数:返回值 第二种\r\n        //首先把姓张的过滤下来，然后去重，接着拿到前两个，下一步将原来字符串的元素加工成学生类型，通过遍历，将流上的学生对象添加到List集合中\r\n//        list.stream().filter(s -> s.startsWith(\"张\")).distinct().limit(2).map(s -> new Student(s)).\r\n        //forEach(student -> arrayList.add(student));\r\n\r\n        //map()加工方法，第一个参数:原材料，第二个参数:返回值 第二种\r\n        //首先把姓张的过滤下来，然后去重，接着拿到前两个，下一步将原来字符串的元素加工成学生类型，通过遍历，将流上的学生对象添加到List集合中\r\n        //使用构造器引用（前提：将接到的参数直接用于构造器的入参，初始化对象）\r\n//        list.stream().filter(s -> s.startsWith(\"张\")).distinct().limit(2).map(Student::new).forEach(student -> arrayList.add(student));\r\n//        System.out.println(arrayList);\r\n\r\n\r\n        //concat()合并流\r\n        final Stream<String> stream1 = list.stream().filter(s -> !s.startsWith(\"张\"));\r\n        final Stream<String> stream2 = list.stream().skip(1).limit(4);\r\n\r\n        //    public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)\r\n//<T>表示这是一个泛型方法，Stream<T>表示的是返回值，入参的泛型表示，两个入参的泛型类型都要是返回值，或是返回值的子类；当两个入参的泛型类型不同时，可能要用Object\r\n        final Stream<String> concat = Stream.concat(stream1, stream2);\r\n        concat.forEach(s -> arrayList.add(s));\r\n        System.out.println(arrayList);\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[赵敏, 任盈盈, 小龙女, 张无忌, 赵敏, 任盈盈, 小龙女]\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n- 注意\r\n- \r\n\r\n中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。\r\n\r\n在Stream流中无法直接修改集合、数组中的数据。想要访问集合中的元素，还是要用集合中的方法；流只是用来过滤加工数据\r\n\r\n终结操作方法，调用完成后流就无法继续使用了，原因是不会返回Stream了\r\n\r\n\r\n\r\n\r\n\r\n### Stream流综合案例\r\n\r\n~~~java\r\npublic class StreamDemo2 {\r\n    private static double allMoney;\r\n    private static double allMoney2;\r\n\r\n    public static void main(String[] args) {\r\n        List<Employee> one = new ArrayList<>();\r\n        one.add(new Employee(\"猪八戒\", \'男\', 30000, 25000, null));\r\n        one.add(new Employee(\"孙悟空\", \'男\', 25000, 1000, \"顶撞上司\"));\r\n        one.add(new Employee(\"沙僧\", \'男\', 20000, 20000, null));\r\n        one.add(new Employee(\"小白龙\", \'男\', 20000, 25000, null));\r\n\r\n        List<Employee> two = new ArrayList<>();\r\n        two.add(new Employee(\"武松\", \'男\', 15000, 9000, null));\r\n        two.add(new Employee(\"李逵\", \'男\', 20000, 10000, null));\r\n        two.add(new Employee(\"西门庆\", \'男\', 50000, 100000, \"被打\"));\r\n        two.add(new Employee(\"潘金莲\", \'女\', 3500, 1000, \"被打\"));\r\n        two.add(new Employee(\"武大郎\", \'女\', 20000, 0, \"下毒\"));\r\n\r\n        /*\r\n         * 把拿到最高工资的封装成优秀员工对象\r\n         * */\r\n        final Optional<Topperformer> optional = one.stream().max((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(), 		                                            e2.getBonus() + e2.getSalary()))\r\n                .map(employee -> new Topperformer(employee.getName(), employee.getBonus() + employee.getSalary()));\r\n        final Topperformer topperformer = optional.get();\r\n        System.out.println(topperformer);\r\n\r\n\r\n\r\n        /*\r\n         * 开发一部，去掉一高一低两个工资，求平均工资\r\n         * */\r\n        one.stream().sorted((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))\r\n                .skip(1).limit(one.size() - 2).forEach(employee -> {\r\n            allMoney += employee.getBonus() + employee.getSalary();\r\n        });\r\n        System.out.println(\"开发一部平均工资为:\" + allMoney / (one.size() - 2));\r\n\r\n\r\n        \r\n        /*\r\n         * 开发一和二部，去掉一高一低两个工资，求平均工资\r\n         * */\r\n        final Stream<Employee> oneStream = one.stream();\r\n        final Stream<Employee> towStream = two.stream();\r\n        final Stream<Employee> concat = Stream.concat(oneStream, towStream);\r\n        concat.sorted((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(), e2.getSalary() + e2.getBonus()))\r\n                .skip(1).limit(one.size() + two.size() - 2).forEach(employee -> {\r\n            allMoney2 += employee.getBonus() + employee.getSalary();\r\n        });\r\n        final BigDecimal money = BigDecimal.valueOf(allMoney2);\r\n        final BigDecimal of = BigDecimal.valueOf(one.size() + two.size() - 2);\r\n        System.out.println(\"开发部平均工资为:\" + money.divide(of, 2, RoundingMode.HALF_UP));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n~~~\r\nTopperformer{name=\'猪八戒\', money=55000.0}\r\n开发一部平均工资为:42500.0\r\n开发部平均工资为:34285.71\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 收集Stream流\r\n\r\n- 概念\r\n\r\n\r\n\r\n收集Stream流的含义：就是把Stream流操作后的结果数据转回到集合或者数组中去\r\n\r\nStream流：方便操作集合/数组的手段\r\n\r\n集合/数组：才是开发中的目的\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_15-11-52.png)\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    @Test\r\n    public void test1() {\r\n        final ArrayList<String> list = new ArrayList<>();\r\n        Collections.addAll(list, \"房山\", \"张丹\", \"张三\", \"健康卡\", \"健康卡\");\r\n        final List<String> list1 = list.stream().skip(2).collect(Collectors.toList());\r\n        System.out.println(list1);\r\n\r\n        //注意注意注意：流只能使用一次，用过了foreach count collect toArray等方法后，流就没了\r\n        //重新获取流\r\n        final Set<String> set = list.stream().collect(Collectors.toSet());\r\n        System.out.println(\"set集合：\" + set);//去重\r\n\r\n\r\n//        final Object[] objects = list.stream().toArray();//这里的类型时Object,如果确定一定都是某个子类类型可以使用下面的方法\r\n/*        final String[] toArray = list.stream().toArray(new IntFunction<String[]>() {\r\n            @Override\r\n            public String[] apply(int value) {\r\n                return new String[value];\r\n            }\r\n        });*/\r\n        \r\n        \r\n        \r\n\r\n//        final String[] toArray = list.stream().toArray(v -> new String[v]);Lambda表达式简化\r\n        final String[] toArray = list.stream().toArray(String[]::new);//构造器引用\r\n        System.out.println(\"数组：\" + Arrays.toString(toArray));\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n[张三, 健康卡, 健康卡]\r\nset集合：[张丹, 张三, 健康卡, 房山]\r\n数组：[房山, 张丹, 张三, 健康卡, 健康卡]\r\n~~~\r\n\r\n\r\n\r\n## 认识异常体系\r\n\r\n\r\n\r\n### 异常概述、体系\r\n\r\n-  **什么是异常？**\r\n\r\n异常是程序在“编译”或者“执行”的过程中可能出现的问题\r\n\r\n​    注意：语法错误不算在异常体系中。 \r\n\r\n比如:数组索引越界、空指针异常、 日期格式化异常，等…\r\n\r\n\r\n\r\n- **为什么要学习异常**?\r\n\r\n\r\n\r\n异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止.\r\n\r\n研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性。\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_15-45-51.png)\r\n\r\n---\r\n\r\n\r\n\r\nError：\r\n    系统级别问题(操作系统出现问题)、JVM退出等，无法通过代码控制。\r\n\r\nException：\r\n    java.lang包下，称为异常类，它表示程序本身可以处理的问题\r\n    运行时异常：RuntimeException及其子类，编译阶段不会报错。 (空指针异常，数组索引越界异常) \r\n    编译时异常：除RuntimeException之外所有的异常，编译期必须处理的，否则程序不能通过编译。 (日期格式化异常)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_15-50-22.png)\r\n\r\n---\r\n\r\n\r\n\r\n简单来说：\r\n    编译时异常 就是在编译的时候出现的异常 Idea会帮我们同步编译;如果用记事本，则会在执行javac.exe的时候报错\r\n    运行时异常 就是在运行时出现的异常。 就是当jvm加载字节码文件时发现的异常\r\n\r\n\r\n\r\n- 小结\r\n\r\n异常是什么？\r\n    异常（Exception）是代码在编译或者执行的过程中可能出现的错误；\r\n\r\n异常分为几类？\r\n    编译时异常：没有继承RuntimeExcpetion的异常，编译阶段就会出错。\r\n    运行时异常：继承自RuntimeException的异常或其子类，编译阶段不报错，运行可能报错\r\n\r\n\r\n\r\n学习异常的目的？\r\n    避免异常的出现，同时处理可能出现的异常，让代码更稳健\r\n\r\n\r\n\r\n### 常见运行时异常\r\n\r\n直接继承自RuntimeException或者其子类，编译阶段不会报错，运行时可能出现的错误。\r\n\r\n\r\n\r\n- **运行时异常示例**\r\n\r\n\r\n\r\n\r\n\r\n数组索引越界异常: ArrayIndexOutOfBoundsException \r\n\r\n~~~java\r\n    int[] ints=new int[2];\r\n    System.out.println(ints[2]);\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n空指针异常 : NullPointerException，直接输出没有问题，但是调用空指针的变量的功能就会报错。\r\n\r\n~~~java\r\n	String a=null;\r\n	System.out.println(a);\r\n~~~\r\n\r\n\r\n\r\n数学操作异常：ArithmeticException\r\n\r\n~~~~java\r\n	int a=11/0;\r\n~~~~\r\n\r\n\r\n\r\n类型转换异常：ClassCastException\r\n\r\n~~~java\r\n	Object o = 12;\r\n	String s= (String) o;\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n	String a=\"123mm\";\r\n	Integer.valueOf(a);\r\n~~~\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_16-04-39.png)\r\n\r\n---\r\n\r\n最下面的方法最先调用\r\n\r\n\r\n\r\n~~~java\r\npublic class RuntimeExceptionDemo1 {\r\n    @Test\r\n    public void test1() {\r\n        System.out.println(\"程序开始-----------------\");\r\n        final int[] ints = new int[3];\r\n        System.out.println(ints[2]);\r\n        /*\r\n         * java.lang.ArrayIndexOutOfBoundsException: 3 【数组下标越界异常】运行时异常，都是RuntimeException的子类或孙子类\r\n         *\r\n         * class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException\r\n         *\r\n         * class IndexOutOfBoundsException extends RuntimeException\r\n         * */\r\n\r\n        //System.out.println(ints[3]);//运行时异常，如果出现并且没有try catch/throws jvm停止运行\r\n\r\n\r\n        \r\n        \r\n        \r\n        Object o = 12;\r\n        Integer integer = (Integer) o;//只要有继承关系，就可以强转\r\n        //String与基本数据类型及其包装类都不可以互相强转\r\n\r\n        /*\r\n         * java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\r\n         *\r\n         *class ClassCastException extends RuntimeException\r\n         * */\r\n\r\n        //String string = (String) o;//任何类都是Object的子类 【类型转换异常】 程序终止 运行时异常，是RuntimeException的子类\r\n\r\n\r\n        /*\r\n         * java.lang.ArithmeticException: / by zero\r\n         * public class ArithmeticException extends RuntimeException\r\n         * */\r\n\r\n//        int a = 12 / 0;//【数学操作异常】 程序终止 运行时异常，是RuntimeException的直接子类\r\n\r\n      \r\n        \r\n        \r\n            \r\n            \r\n    \r\n\r\n        String s1 = \"123\";\r\n        System.out.println(Integer.valueOf(s1));\r\n        String s2 = \"12aaa\";\r\n        /*\r\n         * java.lang.NumberFormatException: For input string: \"12aaa\"\r\n         * class NumberFormatException extends IllegalArgumentException\r\n         * class IllegalArgumentException extends RuntimeException\r\n         * */\r\n//        Integer.valueOf(s2);//【数字转换异常】程序终止 运行时异常，是RuntimeException的间接子类\r\n\r\n        \r\n        \r\n        \r\n        \r\n\r\n        String a1 = null;\r\n        System.out.println(a1);//直接输出没有问题，但调用功能时会出错\r\n        /*\r\n         * java.lang.NullPointerException\r\n         * class NullPointerException extends RuntimeException\r\n         *\r\n         * */\r\n        System.out.println(a1.length());//【空指针异常】 运行时异常 程序终止 是RuntimeException的直接子类\r\n\r\n        System.out.println(\"程序结束-----------------\");\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n\r\n\r\n\r\n运行时异常：一般是程序员业务没有考虑好或者是编程逻辑不严谨引起的程序错误，\r\n自己的水平有问题\r\n\r\n\r\n\r\n### 常见编译时异常\r\n\r\n- **编译时异常**\r\n- \r\n\r\n没有直接或间接继承RuntimeException，编译阶就报错，必须处理，否则代码不通过\r\n\r\n\r\n\r\n- **编译时异常的作用是什么**\r\n- \r\n\r\n是担心程序员的技术不行，在编译阶段就爆出一个错误, 目的在于提醒不要出错!（提醒程序员此处容易写错）\r\n\r\n即时出错了也会打出异常栈信息\r\n\r\n编译时异常是可遇不可求\r\n\r\n\r\n\r\n- 编译时异常示例\r\n\r\n~~~java\r\n    @Test\r\n    //使用大的Exception 可以外抛全部的异常\r\n    public void test1() throws Exception {\r\n        String date = \"2015-01-12 10:23:21\";\r\n        final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        final Date parse = sdf.parse(date);//此处提示有未处理的异常，此时我们自信往外抛\r\n        System.out.println(parse);\r\n    }\r\n~~~\r\n\r\n~~~\r\nMon Jan 12 10:23:21 CST 2015\r\n~~~\r\n\r\n\r\n\r\n### 异常的默认处理流程\r\n\r\n~~~java\r\n    public static void main(String[] args) {//3 抛给main方法，main抛给jvm，然后从异常点干掉程序\r\n        System.out.println(\"程序开始.....\");\r\n        divides(1, 0);//2异常会从方法中出现的点这里抛出给调用者\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void divides(int i, int j) {\r\n        System.out.println(i);\r\n        System.out.println(j);\r\n        int c = i / j;//1 默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。\r\n        System.out.println(c);\r\n    }\r\n\r\n\r\n~~~\r\n\r\n~~~\r\n程序开始.....\r\n1\r\n0\r\nException in thread \"main\" java.lang.ArithmeticException: / by zero\r\n	at exception_demo.ExceptionDemo.divides(ExceptionDemo.java:22)\r\n	at exception_demo.ExceptionDemo.main(ExceptionDemo.java:15)\r\n~~~\r\n\r\n\r\n\r\n1.默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException\r\n\r\n2.异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机\r\n\r\n3.虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据\r\n\r\n4.直接从当前执行的异常点干掉当前程序。\r\n\r\n5.后续代码没有机会执行了，因为程序已经死亡\r\n\r\n\r\n\r\n\r\n\r\n- 小结\r\n\r\n默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！\r\n\r\n\r\n\r\n### 编译时异常的处理机制\r\n\r\n编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过\r\n\r\n\r\n\r\n- **编译时异常的处理形式有三种：**\r\n\r\n\r\n\r\n1.出现异常直接抛出去给调用者，调用者也继续抛出去\r\n\r\n2.出现异常自己捕获处理，不麻烦别人\r\n\r\n3.前两者结合，出现异常直接抛出去给调用者，调用者捕获处理\r\n\r\n\r\n\r\n\r\n\r\n- **抛出异常格式：**\r\n\r\n~~~\r\n格式一：\r\n    方法 throws 异常1 ，异常2 ，异常3 ..{\r\n    }\r\n\r\n\r\n规范做法： \r\n    方法 throws Exception{\r\n\r\n    }\r\n    //代表可以抛出一切异常\r\n\r\n~~~\r\n\r\n\r\n\r\n- 方式一：外抛throws\r\n\r\n~~~java\r\n    public static void main(String[] args) throws FileNotFoundException, ParseException {\r\n        System.out.println(\"程序开始.....\");\r\n        format(\"1231321313\");//main方法也不处理，把异常抛给jvm\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void format(String s) throws ParseException, FileNotFoundException {\r\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        final Date date = simpleDateFormat.parse(s);//把异常抛给方法的调用者\r\n        System.out.println(date);\r\n        final FileInputStream is = new FileInputStream(\"D://aafdsa/a.txt\");\r\n        System.out.println(is);\r\n    }\r\n~~~\r\n\r\n\r\n\r\n- 方式二 try catch\r\n\r\n\r\n\r\n监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。\r\n\r\n这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行\r\n\r\n\r\n\r\n- 格式：\r\n\r\n~~~java\r\n   try{\r\n   // 监视可能出现异常的代码！\r\n   }catch(异常类型1 变量){\r\n   // 处理异常 一般是打印异常栈信息\r\n   }catch(异常类型2 变量){\r\n   // 处理异常 一般是打印异常栈信息\r\n   }\r\n   \r\n   建议格式：\r\n   try{\r\n   // 可能出现异常的代码！\r\n   }catch (Exception e){\r\n   e.printStackTrace(); // 直接打印异常栈信息\r\n   }\r\n\r\n	//Exception可以捕获处理一切异常类型！\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n    public static void main(String[] args) throws Exception {\r\n        System.out.println(\"程序开始.....\");\r\n        format(\"1231321313\");\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void format(String s) throws Exception {\r\n        try {\r\n            final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n            final Date date = simpleDateFormat.parse(s);//当此处出现异常时，下面的代码不会在执行；但还会跑try范围之外的代码，直到跑完\r\n            System.out.println(date);\r\n            final FileInputStream is = new FileInputStream(\"D://aafdsa/a.txt\");\r\n            System.out.println(is);\r\n        } catch (ParseException e) {//只会抓到一处异常，看谁先出异常\r\n            e.printStackTrace();\r\n        } catch (FileNotFoundException e) {//只会抓到一处异常，看谁先出异常\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n~~~\r\n\r\n~~~\r\n程序开始.....\r\njava.text.ParseException: Unparseable date: \"1231321313\"\r\n	at java.text.DateFormat.parse(DateFormat.java:366)\r\n	at exception_demo.ExceptionDemo.format(ExceptionDemo.java:28)\r\n	at exception_demo.ExceptionDemo.main(ExceptionDemo.java:21)\r\n程序结束.....\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\n    public static void main(String[] args) throws Exception {\r\n        System.out.println(\"程序开始.....\");\r\n        format(\"1231321313\");\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void format(String s) {\r\n\r\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        Date date = null;\r\n        try {\r\n            date = simpleDateFormat.parse(s);//当此处出现异常时，下面的代码不会在执行；但还会跑try范围之外的代码，直到跑完\r\n        } catch (ParseException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(date);\r\n        FileInputStream is = null;\r\n        try {\r\n            is = new FileInputStream(\"D://aafdsa/a.txt\");//这里也会跑，然后报错\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(is);\r\n\r\n    }\r\n~~~\r\n\r\n~~~\r\n程序开始.....\r\njava.text.ParseException: Unparseable date: \"1231321313\"\r\n	at java.text.DateFormat.parse(DateFormat.java:366)\r\n	at exception_demo.ExceptionDemo.format(ExceptionDemo.java:30)\r\n	at exception_demo.ExceptionDemo.main(ExceptionDemo.java:21)\r\njava.io.FileNotFoundException: D:\\aafdsa\\a.txt (系统找不到指定的路径。)\r\n	at java.io.FileInputStream.open0(Native Method)\r\n	at java.io.FileInputStream.open(FileInputStream.java:195)\r\n	at java.io.FileInputStream.<init>(FileInputStream.java:138)\r\n	at java.io.FileInputStream.<init>(FileInputStream.java:93)\r\n	at exception_demo.ExceptionDemo.format(ExceptionDemo.java:37)\r\n	at exception_demo.ExceptionDemo.main(ExceptionDemo.java:21)\r\nnull\r\nnull\r\n程序结束.....\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n- **异常处理方式**3 **——** **前两者结合**\r\n\r\n方法直接将异通过throws抛出去给调用者\r\n调用者收到异常后直接捕获处理\r\n\r\n\r\n\r\n~~~java\r\n    public static void main(String[] args) {\r\n        System.out.println(\"程序开始.....\");\r\n\r\n        try {\r\n            format(\"1231321313\");//由调用者经行捕获，由此可以得知方法执行情况；也可以通过返回值来判断\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void format(String s) throws Exception {//方法直接将异常抛给调用者\r\n\r\n        final SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        Date date = null;\r\n        date = simpleDateFormat.parse(s);//当此处出现异常时，下面的代码不会在执行；但还会跑try范围之外的代码，直到跑完\r\n\r\n        System.out.println(date);\r\n        FileInputStream is = null;\r\n        is = new FileInputStream(\"D://aafdsa/a.txt\");//这里也会跑，然后报错\r\n        System.out.println(is);\r\n    }\r\n~~~\r\n\r\n- 小结\r\n\r\n\r\n\r\n在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。\r\n\r\n实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。\r\n\r\n\r\n\r\n### 运行时异常的处理机制\r\n\r\n\r\n\r\n运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以\r\n\r\n按照规范建议还是处理：建议在最外层调用处集中捕获处理即可\r\n\r\n  因为编写出现异常的方法默认外抛RuntimeException\r\n\r\n\r\n\r\n~~~java\r\n    public static void main(String[] args) {\r\n        System.out.println(\"程序开始.....\");\r\n        chu(1, 0);//如果没有进行异常捕获，出现异常时，从这里开始就挂了；不会往下执行\r\n        System.out.println(\"程序结束.....\");\r\n    }\r\n\r\n    private static void chu(int a, int b) throws RuntimeException {//运行时异常默认是外抛RuntimeException,写不写都有\r\n        int c = a / b;//出现异常，外抛\r\n        System.out.println(c);\r\n    }\r\n~~~\r\n\r\n~~~\r\n程序开始.....\r\nException in thread \"main\" java.lang.ArithmeticException: / by zero\r\n	at exception_demo.ExceptionDemo.chu(ExceptionDemo.java:26)\r\n	at exception_demo.ExceptionDemo.main(ExceptionDemo.java:21)\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n- 异常处理时代码稳健案例\r\n\r\n~~~java\r\n    private static void guess() {\r\n        final Scanner sc = new Scanner(System.in);\r\n        while (true) {\r\n            try {\r\n                System.out.print(\"请输入数据：\");\r\n                final String data = sc.nextLine();\r\n                final Double value = Double.valueOf(data);\r\n                if (value > 0) {\r\n                    System.out.println(\"成功输入：\" + value);\r\n                    break;\r\n                } else {\r\n                    System.out.println(\"请输入正数！\");\r\n                }\r\n            } catch (Exception e) {\r\n                System.out.println(\"请输入合法数据\");\r\n            }\r\n        }\r\n    }\r\n\r\n~~~\r\n\r\n~~~\r\n请输入数据：.\r\n请输入合法数据\r\n请输入数据：.0\r\n请输入正数！\r\n请输入数据：0.1\r\n成功输入：0.1\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n### 自定义异常\r\n\r\n- **自定义异常的必要性**\r\n\r\n\r\n\r\nJava无法为这个世界上全部的问题提供异常类。\r\n如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了\r\n\r\n\r\n\r\n- **自定义异常的好处：**\r\n\r\n\r\n\r\n可以使用异常的机制管理业务问题，如提醒程序员注意\r\n\r\n同时一旦出现bug，可以用异常的形式清晰的指出出错的地方\r\n\r\n\r\n\r\n- **自定义异常的分类**\r\n\r\n\r\n\r\n1、自定义编译时异常       \r\n\r\n- 定义一个异常类继承Exception.\r\n\r\n- 重写构造器。\r\n\r\n- 在出现异常的地方用throw new 自定义对象抛出，\r\n\r\n  作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！\r\n\r\n  \r\n\r\n2、自定义运行时异常\r\n\r\n- 定义一个异常类继承RuntimeException.\r\n\r\n- 重写构造器\r\n\r\n- 在出现异常的地方用throw new 自定义对象抛出!\r\n\r\n  作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！\r\n\r\n\r\n\r\n~~~java\r\nclass AgeIllegalException extends Exception {\r\n    public AgeIllegalException() {\r\n    }\r\n\r\n    public AgeIllegalException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npackage exception_demo;\r\n\r\n\r\npublic class ExceptionDemo2 {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            checkAge(-12);//编译时异常,此时选择捕获\r\n        } catch (AgeIllegalException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(\"程序结束！\");\r\n    }\r\n\r\n\r\n    /*\r\n     throw:在方法内部创建一个异常对象，从此点抛出一个编译时异常;此时应该在方法申明上外抛给调用者\r\n     \r\n     throws:在方法申明上外抛方法内部的没有处理异常给调用者\r\n     * */\r\n    private static void checkAge(int age) throws AgeIllegalException {\r\n        if (age < 0 || age > 120) {\r\n            throw new AgeIllegalException(age + \" is ilegal!\");//从此点抛出一个编译时异常\r\n        }\r\n        System.out.println(\"Age is legal!Please go on!\");\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\nexception_demo.AgeIllegalException: -12 is ilegal!\r\n	at exception_demo.ExceptionDemo2.checkAge(ExceptionDemo2.java:31)\r\n	at exception_demo.ExceptionDemo2.main(ExceptionDemo2.java:15)\r\n程序结束！\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n~~~java\r\n/*\r\n * 当该异常不会经常被触发，或影响不是很大，就定义成运行时异常\r\n * */\r\nclass AgeIllegalException extends RuntimeException {\r\n    public AgeIllegalException() {\r\n    }\r\n\r\n    public AgeIllegalException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n~~~\r\n\r\n\r\n\r\n~~~java\r\npublic class ExceptionDemo2 {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            checkAge(-12);//运行时异常,此时选择捕获;可以不捕获运行时异常\r\n        } catch (AgeIllegalException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        System.out.println(\"程序结束！\");\r\n    }\r\n\r\n\r\n    /*\r\n     *throw:在方法内部创建一个异常对象，从此点抛出一个编译时异常;此时应该在方法申明上外抛给调用者\r\n     *\r\n     * throws:在方法申明上外抛方法内部的没有处理异常给调用者\r\n     * */\r\n    private static void checkAge(int age) {\r\n        if (age < 0 || age > 120) {\r\n            throw new AgeIllegalException(age + \" is ilegal!\");//从此点抛出一个编译时异常\r\n        }\r\n        System.out.println(\"Age is legal!Please go on!\");\r\n    }\r\n\r\n}\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n\r\n\r\n## 日志框架\r\n\r\n### 日志技术的概述\r\n\r\n程序中的日志： 程序中的日志可以用来记录程序运行过程中的信息，并可以进行永久存储\r\n\r\n\r\n\r\n- **输出语句的弊端**\r\n\r\n信息只能展示在控制台\r\n不能将其记录到其他的位置（文件，数据库）\r\n想取消记录的信息需要修改代码才可以完成\r\n\r\n\r\n\r\n- **日志技术具备的优势**\r\n\r\n可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。\r\n可以随时以开关的形式控制是否记录日志，无需修改源代码\r\n\r\n\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_20-43-49.png)\r\n\r\n---\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 日志技术体系\r\n\r\n---\r\n\r\n![](http://fgcy-pic.zhamao.ml/Snipaste_2022-03-13_20-48-00.png)\r\n\r\n---\r\n\r\n\r\n\r\n日志规范：一些接口，提供给日志的实现框架设计的标准。\r\n日志框架：牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。\r\n因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。\r\nlogback实现了Simple Logging Facade for java\r\n\r\n\r\n\r\n### Logback概述\r\n\r\n- 概述\r\n\r\nLogback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好\r\n\r\n> 官网地址：https://logback.qos.ch/index.html \r\n\r\nLogback是基于slf4j的日志规范实现的框架。logback是Simple Logging Facade for java的实现类\r\n\r\n\r\n\r\n- **Logback**主要分为四个技术模块\r\n\r\nlogback-core： logback-core 模块为其他两个模块奠定了基础，必须有。\r\nlogback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API。\r\nlogback-access 模块与 Tomcat 和 Jetty 等 Servlet 容器集成，以提供 HTTP 访问日志功能\r\nslf4j-api：日志规范 java并没有提供slf4j的接口文件\r\n\r\n\r\n\r\n### Logback快速入门\r\n\r\n1. 在项目下新建文件夹lib，导入Logback的相关jar包到该文件夹下，并添加到项目依赖库中去。(code、classic、slf4japi)到maven找\r\n\r\n2. 将Logback的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）\r\n\r\n3. 在代码中获取日志的对象\r\n\r\n   ~~~java\r\n   public static final Logger LOGGER = LoggerFactory.getLogger(\"类对象\");\r\n   ~~~\r\n\r\n4. 使用日志对象LOGGER调用其方法输出日志信息\r\n\r\n---\r\n\r\n\r\n\r\n- 快速入门\r\n\r\n~~~java\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\npublic class LogbackDemo {\r\n    private static final Logger LOGGER = LoggerFactory.getLogger(\"LogbackDemo.class\");\r\n\r\n    public static void main(String[] args) {\r\n        while (true) {\r\n            try {\r\n                LOGGER.info(\"程序即将执行.....\");\r\n                int a = 10;\r\n                LOGGER.trace(\"a=\" + a);\r\n                int b = 0;\r\n                LOGGER.trace(\"b=\" + b);\r\n                LOGGER.debug(\"a / b=\" + a / b);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                LOGGER.error(e + \"\");\r\n            }\r\n        }\r\n    }\r\n}\r\n~~~\r\n\r\n~~~\r\n2022-03-13 21:43:05.283 [INFO ] LogbackDemo.class [main] : 程序即将执行.....\r\n2022-03-13 21:43:05.283 [TRACE] LogbackDemo.class [main] : a=10\r\n2022-03-13 21:43:05.283 [TRACE] LogbackDemo.class [main] : b=0\r\n2022-03-13 21:43:05.283 [ERROR] LogbackDemo.class [main] : java.lang.ArithmeticException: / by zero\r\n~~~\r\n\r\n\r\n\r\n- **logback的配置文件**\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration>\r\n    <!--\r\n        CONSOLE ：配置输出到控制台的日志格式\r\n    -->\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <!--输出流对象 默认 System.out 改为 System.err所有用log输出的东西都死红色的-->\r\n        <target>System.out</target>\r\n        <encoder>\r\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度\r\n                %msg：日志消息，%n是换行符-->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %c [%thread] : %msg%n</pattern>\r\n        </encoder>\r\n    </appender>\r\n\r\n    <!-- FILE配置输出到文件的日志格式 -->\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <encoder>\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n            <charset>utf-8</charset>\r\n        </encoder>\r\n        <!--日志输出路径-->\r\n        <file>C:/code/itheima-data.log</file>\r\n        <!--指定日志文件拆分和压缩规则-->\r\n        <rollingPolicy\r\n                class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\r\n            <!--通过指定压缩文件名称，来确定分割文件方式-->\r\n            <fileNamePattern>D:\\learn\\黑马程序员\\java基础\\day18、日志框架、阶段项目\\\\data-%d{yyyy-MMdd}.log%i.gz</fileNamePattern>\r\n            <!--文件拆分大小-->\r\n            <maxFileSize>1MB</maxFileSize>\r\n        </rollingPolicy>\r\n    </appender>\r\n\r\n    <!--\r\n\r\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\r\n   ， 默认debug\r\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\r\n    -->\r\n    <root level=\"ALL\"><!-- 这里的ALL表示打印一切级别的日志-->\r\n        <appender-ref ref=\"CONSOLE\"/><!--  将信息打印到控制台    -->\r\n        <appender-ref ref=\"FILE\"/><!--  将信息打印到文件    -->\r\n    </root>\r\n</configuration>\r\n~~~\r\n\r\n\r\n\r\n### Logback配置详解-输出位置、格式设置\r\n\r\n- 核心配置文件\r\n\r\nLogback日志系统的特性都是通过核心配置文件logback.xml控制的\r\n\r\n\r\n\r\n- **Logback**日志输出位置、格式设置：\r\n\r\n通过logback.xml 中的\\<append>标签可以设置输出位置和日志信息的详细格式。\r\n通常可以设置2个日志输出位置：一个是控制台、一个是系统文件中\r\n 输出到控制台的配置标志\r\n  \\<appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n 输出到系统文件的配置标志\r\n \\<appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n\r\n\r\n\r\n### Logback配置详解-日志级别设置\r\n\r\n- 如果系统上线后只想记录一些错误的日志信息或者不想记录日志了，怎么办\r\n\r\n~~~\r\n可以通过设置日志的输出级别来控制哪些日志信息输出或者不输出。\r\n~~~\r\n\r\n- 日志级别\r\n\r\n级别程度依次是：TRACE< DEBUG< INFO<WARN<ERROR  ; 默认级别是debug（忽略大小写），对应其方法。\r\n作用：用于控制系统中哪些日志级别是可以输出的，只输出级别 不低于 设定级别的日志信息。\r\nDEBUG级别：只打INFO,WARN,ERRO,不大TRACE\r\n\r\nALL  和 OFF分别是打开全部日志信息，及关闭全部日志信息\r\n\r\n具体在\\<root level=\"INFO\">标签的level属性中设置日志级别\r\n\r\n~~~\r\n    <root level=\"INFO\">\r\n    <appender-ref ref=\"CONSOLE\"/>\r\n    <appender-ref ref=\"FILE\" />\r\n    </root>\r\n~~~\r\n\r\n\r\n\r\n- 小结\r\n\r\nLogback的日志级别是什么样的？\r\n级别程度依次是：TRACE< DEBUG< INFO<WARN<ERROR\r\n默认级别是debug（忽略大小写），只输出不低于当前级别的日志\r\nALL  和 OFF分别是打开全部日志和关闭全部日志', 'https://picsum.photos/seed/d/800/450', '原创', 1, b'1', b'1', b'1', b'1', b'1', '2022-06-17 10:57:53', '2022-06-17 11:06:03', 1, 1, '不可变集合、Stream流、异常体系、异常体系', '15,1', 0, 0, b'0');

-- ----------------------------
-- Table structure for t_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tag`;
CREATE TABLE `t_blog_tag`  (
  `blog_id` int NOT NULL,
  `tag_id` int NOT NULL,
  `id` bigint NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 80 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_tag
-- ----------------------------
INSERT INTO `t_blog_tag` VALUES (7, 11, 19);
INSERT INTO `t_blog_tag` VALUES (8, 1, 20);
INSERT INTO `t_blog_tag` VALUES (6, 11, 28);
INSERT INTO `t_blog_tag` VALUES (11, 11, 29);
INSERT INTO `t_blog_tag` VALUES (2, 12, 32);
INSERT INTO `t_blog_tag` VALUES (1, 13, 37);
INSERT INTO `t_blog_tag` VALUES (1, 14, 38);
INSERT INTO `t_blog_tag` VALUES (10, 11, 39);
INSERT INTO `t_blog_tag` VALUES (13, 1, 40);
INSERT INTO `t_blog_tag` VALUES (14, 1, 41);
INSERT INTO `t_blog_tag` VALUES (15, 1, 42);
INSERT INTO `t_blog_tag` VALUES (13, 1, 43);
INSERT INTO `t_blog_tag` VALUES (13, 15, 44);
INSERT INTO `t_blog_tag` VALUES (14, 1, 45);
INSERT INTO `t_blog_tag` VALUES (14, 15, 46);
INSERT INTO `t_blog_tag` VALUES (15, 1, 47);
INSERT INTO `t_blog_tag` VALUES (15, 15, 48);
INSERT INTO `t_blog_tag` VALUES (16, 1, 49);
INSERT INTO `t_blog_tag` VALUES (16, 15, 50);
INSERT INTO `t_blog_tag` VALUES (20, 1, 55);
INSERT INTO `t_blog_tag` VALUES (20, 1, 56);
INSERT INTO `t_blog_tag` VALUES (20, 15, 57);
INSERT INTO `t_blog_tag` VALUES (21, 1, 58);
INSERT INTO `t_blog_tag` VALUES (21, 15, 59);
INSERT INTO `t_blog_tag` VALUES (1, 1, 60);
INSERT INTO `t_blog_tag` VALUES (1, 4, 61);
INSERT INTO `t_blog_tag` VALUES (1, 13, 62);
INSERT INTO `t_blog_tag` VALUES (1, 14, 63);
INSERT INTO `t_blog_tag` VALUES (22, 1, 64);
INSERT INTO `t_blog_tag` VALUES (22, 15, 65);
INSERT INTO `t_blog_tag` VALUES (23, 1, 66);
INSERT INTO `t_blog_tag` VALUES (23, 15, 67);
INSERT INTO `t_blog_tag` VALUES (24, 1, 68);
INSERT INTO `t_blog_tag` VALUES (24, 15, 69);
INSERT INTO `t_blog_tag` VALUES (25, 1, 70);
INSERT INTO `t_blog_tag` VALUES (25, 15, 71);
INSERT INTO `t_blog_tag` VALUES (26, 1, 72);
INSERT INTO `t_blog_tag` VALUES (26, 15, 73);
INSERT INTO `t_blog_tag` VALUES (29, 15, 78);
INSERT INTO `t_blog_tag` VALUES (29, 1, 79);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `count` bigint NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (1, 'JAVA', 13);
INSERT INTO `t_tag` VALUES (2, 'MySQL', 0);
INSERT INTO `t_tag` VALUES (3, '数据库', 0);
INSERT INTO `t_tag` VALUES (6, 'jQuery', 0);
INSERT INTO `t_tag` VALUES (7, 'thymeleaf', 0);
INSERT INTO `t_tag` VALUES (11, 'redis', 4);
INSERT INTO `t_tag` VALUES (12, 'markdown', 1);
INSERT INTO `t_tag` VALUES (13, 'spring', 1);
INSERT INTO `t_tag` VALUES (14, 'springboot', 1);
INSERT INTO `t_tag` VALUES (15, '黑马吴磊2021', 12);
INSERT INTO `t_tag` VALUES (16, 'springsecurity', 0);

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '博客类型id',
  `name` char(5) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客类型',
  `count` int NULL DEFAULT NULL COMMENT '该种类型的博客数量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 24 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (1, '学习笔记', 17);
INSERT INTO `t_type` VALUES (2, '错误合集', 0);
INSERT INTO `t_type` VALUES (3, '转载文章', 0);
INSERT INTO `t_type` VALUES (4, '神仙句子', 0);

SET FOREIGN_KEY_CHECKS = 1;
